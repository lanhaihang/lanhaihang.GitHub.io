{"pages":[{"title":"","text":"","link":"/album/Untitled.html"},{"title":"关于我 & 本博客","text":"愿世间美好，与大家环环相扣 个人简介 分享很喜欢Martin Fowler的一句话： “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.“ —— Martin Fowler 其大致意思是： “任何一个傻子都能写出让电脑能懂的代码，而只有好的程序员可以写出让人能看懂的代码。“ —— 马丁·福勒 个人信息： 邮箱：lyh9420@icloud.com QQ：94207320 专业：数据科学与大数据技术 学历：本科 向往的工作方向：大数据开发工程师、Java后端开发 自我定位：编程路上的小学生，热爱技术，喜欢专研。对 Java 和 Python 有一定的了解。 博客信息 本博客是 hexo 静态博客，挂载在 GitHub 上。 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 建站初衷 我的建站初衷：记录成长路上的风景。 我为什么写博客： 写博客的目的 将一些自己学到的知识通过语言再次组织，记录下来，从而加深印象。 将踩过的坑尽量的都记下来，避免再次踩坑。 遗忘了的知识点，可以翻回博客，再次拾取回来。 锻炼自己的总结能力。 写博客是一件非常耗时的事情，很多时候，为了把一个问题描述清楚，需要进行语言的描述、绘图以及代码的验证。这些过程都是很耗时的，不过这个过程也是一个自我提升的过程。 时间轴记录 时间 事件 2018年8月31日 就读广州某所本科院校 2018年9月 第一次接触编程语言：C语言 2019年2月 继C语言入门之后，接触 Python 2019年6月2日 初次接触博客园 2019年9月3日 初次接触 Java 这门语言，写了我的第一个程序 2020年4月24日 搭建了我的个人博客：hexo博客 2020年9月10日 开始写我的第一个 Java 微服务项目：商城项目 我的其他站点 技术站点 博客园 CSDN 知乎 简书 SegmentFault 思否 掘金 GitHub 社交站点 微博 Twitter FaceBook QQ空间","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://www.stringbug.com/img/avatar.png 网站名称：Lee Hua 网站地址：https://www.stringbug.com/ 网站简介：编程路上的小学生，热爱技术，喜欢专研。 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"既然来了，就留个纪念吧！和我谈天论地吧！ 发邮箱可以快速联系我哦！邮箱：lyh9420@icloud.com","link":"/message/index.html"},{"title":"收藏的页面索引","text":"收藏索引丨Lee Hua footer.main-footer .go-up { width: 45px; float: right; position: fixed; right: -10px; bottom: 30px; z-index: 10; margin: 0; padding: 0; list-style: none } footer.main-footer .go-up a { display: inline-block; width: 35px; height: 35px; text-align: center; border-radius: 50%; background: rgba(123, 123, 123, .5); color: #fff; font-size: 20px; line-height: 35px; padding: 0 } 常用学术影视音乐工具图片社区素材生活常用百度GoogleMAGI秘迹网盘地图知乎云村B站Github学术百度必应知网小木虫万方影响因子iData影视妮可影视Neets巴士动漫CK电影疯狂电影音乐云音乐虾米QQ音乐酷我音乐酷狗音乐千千音乐工具权重查询友链检测备案查询PING检测死链检测关键词挖掘图片百度海洛图库Bing500PX社区知乎微信微博豆瓣搜外问答素材设计达人UI站酷素材呢图IconFinderNoun ProjectPPT生活淘宝京东下厨房香哈菜谱12306去哪儿快递导航内容不定期更新...开发社区Stack Overflow全球最受程序员欢迎的开发社区CSDN全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台博客园代码改变世界V2EXV2EX = way to explore掘金一个帮助开发者成长的社区SegmentFault改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功开源中国国内最大的开源技术社区ITeyeITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践51CTO技术成就梦想ITPUB全球最大的学习分享平台知乎国内最受欢迎的知识性问答社区简书创作你的创作云+社区来自腾讯的开发者技术分享社区云栖社区阿里云面向开发者的开放型技术平台极术社区全球软硬件资源信息，只要你有问题，我们就能解答。代码托管Github全球最大的面向开源及私有软件项目的托管平台Gitlab支持无限的公有项目和私有项目的代码托管平台Bitbucket同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发SourceForge又称 SF.net，是开源软件开发者进行开发管理的集中式场所Coding国内首个一站式云端软件服务平台Gitee国内最大的开源社区 OSChina 的代码托管平台阿里云代码托管阿里云旗下代码托管平台百度效率云百度云旗下的 Git 代码托管平台语言文档Zeal脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOSDash适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架DevDocs在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上C/C++C/C++ API 文档C#C# API 文档JavaJava API 文档.NET.NET API 文档PHPPHP API 文档JavaScriptJavaScript API 文档PythonPython API 文档AndroidAndroid API 文档iOSiOS API 文档SQLSQL API 文档SwiftSwift API 文档RubyRuby API 文档GOGO API 文档RR API 文档MATLABMATLAB API 文档Node.jsNode.js API 文档HTMLHTML API 文档CSSCSS API 文档RedisRedis API 文档MongoDBMongoDB API 文档DjangoDjango API 文档在线平台LeetCode全球极客挚爱的技术成长平台Topcoder全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛Codeforces俄罗斯最大的算法比赛网站Hihocoder技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务LintCode被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站SPOJ波兰的算法刷题网站NEUQ OJ一个在线的判题平台洛谷创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验牛客网中国最大的IT题库C语言网在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！计蒜客计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统Python 文档资料Python 官方文档Python 官方文档Python 标准库Python 标准库Python RequestsPython Requests 文档Python UrllibPython Urllib 文档Python SeleniumPython Selenium 中文翻译文档正则表达式Python 正则表达式官方文档Beautiful SoupBeautiful Soup 文档ScrapyScrapy 爬虫框架官方文档PySpiderPySpider 爬虫框架官方文档MatplotlibMatplotlib 2D绘图库 官方中文文档NumpyNumpy 科学计算 官方中文文档PandasPandas 结构化数据分析 官方中文文档博客收藏廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析捕蛇者说编程、程序员、PythonFxxkPython学习python的正确姿势wistbeanPython 大佬PigleiPython 大佬TendCodePython 大佬追梦人物的博客Python Django 大佬the5fire《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发小明明S À DOMICILE《Python Web开发实战》作者，Python 大佬Python之禅Python 大佬Python 知识圈Python知识圈 - 实用的Python教程网站Python 教程网小詹学Python，专注Python学习烂笔头 j_hao104Python大佬咸鱼日常专注Python爬虫，有许多JS逆向文章AnShengPython 全栈大佬夏溪辰云栖社区特邀爬虫工程师，Python大佬高级农民工Python大佬云爬虫技术研究笔记Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家云爬虫技术研究笔记(CSDN)Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家Jack CuiCSDN博客专家，Python 大佬爬虫相关镀金的天空GlidedSky 镀金的天空，在线爬虫练习题库夜幕爬虫安全论坛一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解西刺免费代理IP每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP爬虫IP代理池爬虫IP代理池云打码采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒超级鹰专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大八爪鱼采集器一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取Python 逆向Python 逆向相关资源Python 爬虫集合Python 爬虫集合Python 入门网络爬虫之精华版Python 入门网络爬虫之精华版爬虫项目进阶实战Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密Python 模拟登陆一些大型网站Python 模拟登陆一些大型网站系统化学习 Python 爬虫系统化学习 Python 爬虫Python3 网络爬虫实战Python3 网络爬虫实战在线视频腾讯课堂腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师网易云课堂网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作中国大学 MOOC中国大学MOOC(慕课)，国家精品课程在线学习平台黑马程序员致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构课工场更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程极客学院极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域慕课网 慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课尚硅谷尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！实验楼国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用优达学城 Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求51CTO学院 51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程CSDN 学院CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程老男孩IT教育隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构千锋教育千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌博客论坛鱼C工作室鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学吾爱破解致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护廖雪峰廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程崔庆才崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析莫烦Python专注Python、机器学习、深度学习唐松专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析阮一峰上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念学习平台菜鸟教程提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识W3school领先的 Web 技术教程C语言网C语言网 - 领先实用的编程在线学习网站前端网前端网，最好的自学web前端网站牛客网牛客网 - 互联网求职神器和备考学习平台How2JHow2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容IT工具箱在线工具 - 程序员的工具箱站长工具、代码格式化、压缩、加密、解密、下载链接转换等在线工具 - OSCHINA.NET社区常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等记磊工具箱Dns检测、CSS格式化、超级Ping、端口扫描等孟坤工具箱css一键美化、文本差异比较、代码高亮等Syntax HighlightSyntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码Text to ASCII Art GeneratorText to ASCII Art Generator，字符串转成 ASCII 码图案MDEditor开源在线 Markdown 编辑器临时邮箱匿名注册不常用的网站/论坛，保护隐私免骚扰SM.MSSM 免费图床，每个文件最大支持 5MB路过图床免费公共图床，支持最大10MB、批量上传Greasy Fork安全、实用的用户脚本大全Hello World 大全收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言动画展示各种路径搜索算法动画展示各种路径搜索算法IT eBooks可以下载IT电子书籍的网站（英文）GEEKTyper在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景免费计算机编程类中文书籍免费计算机编程类中文书籍EaseUS Partition Master磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间文件处理Convertio在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式Office-Converter免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式TinyPNGPNG/JPG图片在线压缩利器SquooshGoogle开源在线压缩、调整工具，支持WebPILoveIMG永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等SmallpdfSmallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等PHOTOMOSH故障艺术在线生成，可以输出jpg、gif和视频稿定抠图免费在线抠图软件,图片快速换背景-抠白底图U钙网完全免费的LOGO在线设计制作工具SVGOMGSVG在线压缩平台在线图片透明圆角处理在线图片透明圆角处理草料二维码国内创建二维码在线应用Logaster在线免费创建简单logo及名片设计PreloadersLoading 懒加载动画在线制作Loading制作GIF、SVG、CSS加载动画图标waifu2x图片智能无损放大2倍，适合动漫、插画等智图腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台音乐免费下载全网音乐免费下载工具OK资源采集OK资源采集-最新影视资源大全网易见外工作台针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用HiPDF一站式解决所有PDF相关的问题视频鱼在线下载各大网站视频的网站ScreenToGif开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF设计素材Iconfont阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能Font Awesome一个基于CSS 和 LESS 的字体和图标工具包Flaticon海量扁平化免费的图标库icons8独特系统平台风格和web图标库，下载免费图标，音乐千图网海量原创设计模板免费下载昵图网国内海量平面免费素材下载千库网免费 png 图片背景素材下载Pexels才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频必应壁纸必应每日高清壁纸Piqsels精美的免版税图库私藏字体优质字体免费下载站第一 PPT 网免费 PPT 模板下载吾道幻灯片全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片Mixkit免费、高质量、可商用的视频素材分享网站The Stocks对各大图片网站进行整合，免费优质图片下载极简壁纸高质量精品壁纸网站NASA Image and Video Library美国国家航天局的官方库，从此太空类的素材再也不是问题Unsplash质量超高的免费图片素材库，无需注册，直接下载WordArt文字云工具云服务商阿里云阿里云 - 为了无法计算的价值腾讯云腾讯云 - 产业智变 云启未来百度云百度云 - 计算无限可能华为云华为云 - +智能，见未来京东云京东云 - 遇见无限可能西部数码西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！景安云景安云 - 专业的数据中心服务商七牛云七牛云 - 国内领先的企业级云服务商又拍云又拍云 - 加速在线业务-CDN-云存储美橙互联美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！UCloudUCloud - 中立 安全 可信赖的云计算服务商AWSAWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商Microsoft AzureAzure. Invent with purpose.GoDaddyGoDaddy - 提供域名注册和互联网主机服务的美国公司CloudflareCloudflare - 网络性能和安全公司jsDelivrjsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub众包平台猿急送专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求开源众包开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单外包大师PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营人人开发集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台快码提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。我爱方案网专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发英选提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发智筹为企业&amp;创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务开发邦互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验码市Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作自由职客自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap解放号解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力程序员客栈领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付码易智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台电鸭社区电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态Sxsoft中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求实现网为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求智城外包网零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台更多导航创造狮导航 创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全大数据导航大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台优设导航优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引牛导航实用工具导航聚BT聚BT - 聚合最优质的BT、磁力资源ShareHubShareHub - 资源和工具的集合狼牌工作网址导航工具，资源，方法，All IN ONE的办公工作网址导航$(document).ready(function () { return $(document).on(\"click\", \".has-sub\", function () { var e = $(this); $(this).hasClass(\"expanded\") ? $(\".has-sub ul\").each(function (s, i) { var t = $(this); e.find(\"ul\")[0] != i && setTimeout(function () { t.attr(\"style\", \"\") }, 300) }) : setTimeout(function () { e.find(\"ul\").attr(\"style\", \"\") }, 300) }), $(\".user-info-menu .hidden-sm\").click(function () { $(\".sidebar-menu\").hasClass(\"collapsed\") ? $(\".has-sub.expanded > ul\").attr(\"style\", \"\") : $(\".has-sub.expanded > ul\").show() }), $(\"#main-menu li ul li\").click(function () { $(this).siblings(\"li\").removeClass(\"active\"), $(this).addClass(\"active\") }), $(\"a.smooth\").click(function (s) { s.preventDefault(), public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass(\"mobile-is-visible\"), ps_destroy(), $(\"html, body\").animate({ scrollTop: $($(this).attr(\"href\")).offset().top - 30 }, { duration: 500, easing: \"swing\" }) }), !1 }); var href = \"\", pos = 0; $(\"a.smooth\").click(function (s) { $(\"#main-menu li\").each(function () { $(this).removeClass(\"active\") }), $(this).parent(\"li\").addClass(\"active\"), s.preventDefault(), href = $(this).attr(\"href\"), pos = $(href).position().top - 30 })","link":"/navigation/index.html"}],"posts":[{"title":"CSS 的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 对 CSS 的初步了解 —— 什么是CSSCSS选择器参考手册CSS 的语法格式CSS 选择器之基础选择器CSS 选择器之扩展选择器CSS 字体属性和文本属性的初步了解CSS 边框属性和背景属性的初步了解CSS 盒子模型属性","link":"/p/521606202005/"},{"title":"Cookie 学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China 会话技术 概述 会话是浏览器和服务器之间的多次请求和响应。 也就是说，从浏览器访问服务器开始，到访问服务器结束，浏览器关闭为止的这段时间内容产生的多次请求和响应，合起来叫做浏览器和服务器之间的一次会话。 功能 实际上会话问题解决的还是客户端与服务器之间的通信问题，通过一些会话技术，可以将每个用户的数据以例如cookie/session的形式存储，方便以后用户访问web资源的时候使用 例如： 123假定场景：A和B两人在某个网上购物商场登陆账号后，A买了一个HHKB的键盘，而B则购买了一把民谣吉他，这些信息都会被保存下来用途是：保存账户信息，登录时询问日后是否自动登录，或者根据之前浏览，购买过的商品，分析用户喜欢什么类型的商品，做出精准推送 会话维持的方式 客户端会话技术：Cookie 服务器端会话技术：Session Cookie 快速入门 使用步骤 创建Cookie对象，绑定数据 1new Cookie(String name, String value) 发送Cookie对象 1response.addCookie(Cookie cookie) 获取Cookie，拿到数据 1Cookie[] request.getCookies() 实现 创建一个类，用来将数据绑定到Cookie对象上 12345678910111213141516171819202122232425import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo01\")public class CookieDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 创建 Cookie 对象 Cookie cookie = new Cookie(\"massage\", \"HelloCookie\"); // 发送 Cookie response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 创建一个类，用来获取Cookie对象中绑定到的数据 12345678910111213141516171819202122232425262728import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/cookieDemo02\")public class CookieDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取 Cookie Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { System.out.println(cookie.getName() + \":\" + cookie.getValue()); } } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器访问：http://localhost:8080/CookieStudy_war_exploded/cookieDemo01，绑定数据到Cookie对象 然后再访问：http://localhost:8080/CookieStudy_war_exploded/cookieDemo02，控制台输出： Cookie 技术 概述： Cookies 可以简单的理解为服务器暂存在你浏览器中的一些信息文件，它将你在网站上所输入的一些内容，或者一些选项记录下来，当下一次你访问同一个网站的时候，服务器就会主动去查询这个cookie资料，如果存在的话，将会根据其中的内容，提供一些特别的功能，例如记住账号密码等。 具体流程 浏览器访问服务器，如果服务器需要记录该用户的状态，就用response向浏览器发送一个cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址以及Cookie一同提交给服务器。 Cookie 的操作规则以及常用API一次发送多个 Cookie创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 举例： 创建一个类，用来将数据绑定到Cookie对象上 1234567891011121314151617@WebServlet(\"/cookieDemo03\")public class CookieDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) { // 创建 Cookie 对象 Cookie cookie1 = new Cookie(\"massage1\", \"HelloCookie1\"); Cookie cookie2 = new Cookie(\"massage2\", \"HelloCookie2\"); // 发送 Cookie response.addCookie(cookie1); response.addCookie(cookie2); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) { this.doGet(request, response); }} 创建一个类，用来获取Cookie对象中绑定到的数据 123456789101112131415161718@WebServlet(\"/cookieDemo04\")public class CookieDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) { // 获取 Cookie Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { System.out.println(cookie.getName() + \":\" + cookie.getValue()); } } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) { this.doGet(request, response); }} 启动服务器，浏览器访问：http://localhost:8080/CookieStudy_war_exploded/cookieDemo03，绑定数据到Cookie对象 然后再访问：http://localhost:8080/CookieStudy_war_exploded/cookieDemo02 控制台输出： cookie 的生命周期 默认情况下，当浏览器关闭后，Cookie数据被销毁 不过我们可以将Cookie存储到硬盘中，实现持久化存储 方法： 1setMaxAge(int seconds) seconds 为正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 seconds 为负数：当浏览器关闭后，Cookie数据被销毁（默认值） seconds 为零：删除cookie信息 就用上面 一次发送多个 Cookie 的例子。当我们访问 /cookieDemo03 后，再访问 /cookieDemo04，这个时候cookie是还没有没销毁的，因为我们没有关闭浏览器（Cookie存在内存中）。一旦我们关闭浏览器（释放内存）之前的cookie就会被删除。那么我们这时候，不去访问 /cookieDemo03 ，直接去访问 /cookieDemo04 ，控制台是不会输出 CookieDemo03.java 对应的 cookie 绑定到的数据的。假如想要cookie的有效时间更长，可以通过在绑定数据到Cookie对象的时候，设置Cookie可以存在硬盘中的时间。 如： 1234567891011121314151617@WebServlet(\"/cookieDemo05\")public class CookieDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) { // 创建 Cookie 对象 Cookie cookie = new Cookie(\"massage\", \"HelloCookie\"); // 设置 Cookie 的存在时间（实现 Cookie 的持久化存储） cookie.setMaxAge(30); // 发送 Cookie response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) { this.doGet(request, response); }} 关于 cookie 存储中文数据问题 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码（如：%E3） 在tomcat 8 之后，cookie支持中文数据。 特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie 共享问题假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中 cookie 默认情况下是不能共享的。 可以通过设置，来实现在同一个tomcat服务器、不同web项目中的 cookie 共享。 12setPath(String path)// 设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如：/CookieStudy01_war_exploded 项目虚拟路径和 /CookieStudy02_war_exploded项目虚拟路径，他们的cookie是不能共享的，如果想要实现共享，可以设置cookie的虚拟目录为这两个虚拟目录的公共目录（这里的是：/） 不同的tomcat服务器间cookie共享问题（了解）1234setDomain(String path)// 如果设置一级域名相同，那么多个服务器之间 cookie 可以共享// 举例如：setDomain(\".baidu.com\")，那么 tieba.baidu.com 和 news.baidu.com 中 cookie 可以共享 Cookie 的特点 cookie 存储数据在客户端浏览器 浏览器对于单个 cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) cookie一般用于存出少量的不太敏感的数据。 在不登录的情况下，完成服务器对客户端的身份识别。 Cookie 的使用案例 需求：记住用户上一次访问时间 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析： 在服务器中的Servlet判断是否有一个名为lastTime的cookie 用户不是第一次访问 响应数据：欢迎回来，您上次访问时间为:20XX年XX月XX日XX:XX:XX 写回Cookie当前访问时间：lastTime=20XX年XX月XX日XX:XX:XX 用户是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie当前访问时间：lastTime=20XX年XX月XX日XX:XX:XX 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLDecoder;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.Date;@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { // 设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=utf-8\"); // 获取所有Cookie Cookie[] cookies = request.getCookies(); // 默认没有cookie为lastTime boolean flag = false; // 遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0) { for (Cookie cookie : cookies) { // 获取cookie的名称 String name = cookie.getName(); // 判断名称是否是：lastTime if(\"lastTime\".equals(name)) { // 有cookie为lastTime，不是第一次访问 flag = true; // 获取当前时间的字符串 Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String stringDate = simpleDateFormat.format(date); // 由于stringDate字符串中存在特殊字符（空格），需要URL编码 String encodeCookie = URLEncoder.encode(stringDate, \"utf-8\"); // 重新设置Cookie的值 cookie.setValue(encodeCookie); // 设置cookie的存活时间：存活一个小时 cookie.setMaxAge(60 * 60); // 在响应对象中添加该设置的cookie response.addCookie(cookie); // 响应数据 // 获取Cookie的value（时间） String value = cookie.getValue(); // 对获取到的cookie值进行URL解码 String decodeValue = URLDecoder.decode(value, \"utf-8\"); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间为:\" + decodeValue + \"&lt;/h1&gt;\"); // 已经完成了需求 break; } } } // 假如上面遍历了所有的cookie，都没有cookie为lastTime，或者用户的请求中没有cookie，说明用户是第一次访问 if(cookies == null || cookies.length == 0 || flag == false) { // 获取当前时间的字符串 Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String stringDate = simpleDateFormat.format(date); // 由于stringDate字符串中存在特殊字符（空格），需要URL编码 stringDate = URLEncoder.encode(stringDate, \"utf-8\"); // 重新设置Cookie的值 Cookie cookie = new Cookie(\"lastTime\", stringDate); // 设置cookie的存活时间 cookie.setMaxAge(60 * 60); // 重新发送cookie response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;您好，欢迎您首次访问！&lt;/h1&gt;\"); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException { this.doGet(request, response); }} 启动服务器，首次访问：http://localhost:8080/CookieStudy_war_exploded/cookieTest 再次访问：http://localhost:8080/CookieStudy_war_exploded/cookieTest 参考文献 会话技术——Cookies和Session详解","link":"/p/082329202005/"},{"title":"BeautifulSoup 的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China Beautiful Soup初了解 解析工具Beautiful Soup，借助网页的结构和属性等特性来解析网页(简单的说就是python的一个HTML或XML的解析库) Beautiful Soup支持的解析器 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “ html. parser “) Python 的内 宜标准库、执行速度适中、文档容错能力强 Python 2.7.3及 Python3.2.2 之前的版本文档容错能力差 lxml HTML解析器 BeautifulSoup(markup,”lxml”) 速度快、文档容错能力强 需要安装c语言库 lxmlXML解析器 BeautifulSoup(markup,”xml”) 速度快、唯一支持 XML 的解析器 需要安装c语言库 html5lib BeautifulSoup(markup,”htmlSlib”) 最好的容错性、以浏览器的方式解析文梢、生成 HTML5格式的文档 速度慢、不依赖外部扩展 实例引入： 123456from bs4 import BeautifulSoupsoup = BeautifulSoup('&lt;p&gt;Hello&lt;/p&gt;', 'lxml')print(soup.p.string)# 输出：Hello BeautifulSoup 的基本用法实例引入： 12345678910111213141516171819from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.prettify(), soup.title.string, sep='\\n\\n')# 初始化BeautifulSoup时，自动更正了不标准的HTML# prettify()方法可以把要解析的字符串以标准的缩进格式输出# soup.title 可以选出HTML中的title节点，再调用string属性就可以得到里面的文本了 123456789101112131415161718192021222324252627282930313233343536# 输出：&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"title\" name=\"dromouse\"&gt; &lt;b&gt; The Dormouse's story &lt;/b&gt; &lt;/p&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;!-- Elsie --&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;The Dormouse's story 结点选择器 选择元素 1234567891011121314151617181920212223242526272829from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.title) # 打印输出title节点的选择结果print(type(soup.title)) # 输出soup.title类型print(soup.title.string) # 输出title节点的内容print(soup.head) # 打印输出head节点的选择结果print(soup.p) # 打印输出p节点的选择结果# 输出：&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;class 'bs4.element.Tag'&gt;The Dormouse's story&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; 提取信息 1234说明：调用string属性获取文本的值利用那么属性获取节点的名称调用attrs获取所有HTML节点属性 1234567891011121314151617181920212223242526html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.title.name) # 选取title节点，然后调用name属性获得节点名称# 输出：titleprint(soup.title.string) # 调用string属性，获取title节点的文本值# 输出：The Dormouse's storyprint(soup.p.attrs) # 调用attrs，获取p节点的所有属性# 输出：{'class': ['title'], 'name': 'dromouse'}print(soup.p.attrs['name']) # 获取name属性# 输出：dromouseprint(soup.p['name']) # 获取name属性# 输出：dromouse 关联选择 子节点和子孙节点 contents属性获取直接子结点（生的的是列表） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;!-- Elsie --&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')# 选取节点元素之后，可以调用contents属性获取它的直接子节点print(soup.p.contents)# 输出：['\\n Once upon a time there were three little sisters; and their names were\\n ', &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, '\\n ,\\n ', &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt;, '\\n and\\n ', &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt;, '\\n ;\\nand they lived at the bottom of a well.\\n ']# 返回结果是一个列表，列表中的元素是所选节点的直接子节点（不包括孙节点） children属性，返回结果是生成器类型。与contents属性一样，只是返回结果类型不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.p.children) # 输出：&lt;list_iterator object at 0x1159b7668&gt;for i, child in enumerate(soup.p.children): print(i, child)# for 循环的输出结果:0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 , 3 &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt;4 and 5 &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt;6 ;and they lived at the bottom of a well. 3. descendants属性会递归查询所有子节点，得到所有子孙节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from bs4 import BeautifulSouphtml = \"\"\" &lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.p.descendants) # 输出：&lt;generator object Tag.descendants at 0x1131d0048&gt;for i, child in enumerate(soup.p.descendants): print(i, child)# for 循环输出结果：0 Once upon a time there were three little sisters; and their names were 1 &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;span&gt;Elsie&lt;/span&gt;4 Elsie5 6 , 7 &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt;8 Lacie 9 and 10 &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt;11 Tillie 12 ;and they lived at the bottom of a well. 父节点和祖先节点 parent获取某个节点的一个父结点 12345678910111213141516171819202122232425262728293031323334from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.a.parent)# 输出：&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; parent获取所有祖先结点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from bs4 import BeautifulSoup 3 html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.a.parents, type(soup.a.parents), list(enumerate(soup.a.parents)), sep='\\n\\n')# 输出：&lt;generator object PageElement.parents at 0x11c76e048&gt;&lt;class 'generator'&gt;[(0, &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;), (1, &lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=\"story\"&gt; ... &lt;/p&gt;&lt;/body&gt;), (2, &lt;html&gt;&lt;head&gt;&lt;title&gt; The Dormouse's story &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=\"story\"&gt; ... &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;&lt;head&gt;&lt;title&gt; The Dormouse's story &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=\"story\"&gt; ... &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;)] 兄弟节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; , &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt; and &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print( # 获取下一个兄弟元素 {'Next Sibling': soup.a.next_sibling}, # 获取上一个兄弟元素 {'Previous Sibling': soup.a.previous_sibling}, # 返回后面的兄弟元素 {'Next Siblings': list(enumerate(soup.a.next_siblings))}, # 返回前面的兄弟元素 {'Previous Siblings': list(enumerate(soup.a.previous_siblings))}, sep='\\n\\n')# 输出：{'Next Sibling': '\\n ,\\n '}{'Previous Sibling': '\\n Once upon a time there were three little sisters; and their names were\\n '}{'Next Siblings': [(0, '\\n ,\\n '), (1, &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt; Lacie &lt;/a&gt;), (2, '\\n and\\n '), (3, &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt; Tillie &lt;/a&gt;), (4, '\\n ;\\nand they lived at the bottom of a well.\\n ')]}{'Previous Siblings': [(0, '\\n Once upon a time there were three little sisters; and their names were\\n ')]} 提取信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Bob&lt;/a&gt; &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print( 'Next Sibling:', [soup.a.next_sibling], # 获取上一个兄弟节点 # \\n type(soup.a.next_sibling), # 上一个兄弟节点的类型 # &lt;class 'bs4.element.NavigableString'&gt; [soup.a.next_sibling.string], # 获取上一个兄弟节点的内容 # \\n sep='\\n')print( 'Parent:', [type(soup.a.parents)], # 获取所有的祖先节点 # &lt;class 'generator'&gt; [list(soup.a.parents)[0]], # 获取第一个祖先节点 # &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Bob&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;&lt;/p&gt; [list(soup.a.parents)[0].attrs['class']], # 获取第一个祖先节点的\"class属性\"的值 # ['story'] sep='\\n')# 为了输出返回的结果，均以列表形式# 输出：Next Sibling:['\\n']&lt;class 'bs4.element.NavigableString'&gt;['\\n']Parent:[&lt;class 'generator'&gt;][&lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Bob&lt;/a&gt;&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;&lt;/p&gt;][['story']] 嵌套选择 12345678910111213141516from bs4 import BeautifulSouphtml = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.head.title)print(type(soup.head.title))print(soup.head.title.string)# 输出：&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;class 'bs4.element.Tag'&gt;The Dormouse's story 方法选择器1find_all(name=None, attrs={}, recursive=True, text=None, limit=None) 查询所有符合条件的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from bs4 import BeautifulSouphtml = \"\"\"&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/ul&gt;&lt;/div&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.find_all(name='li'), type(soup.find_all(name='li')[0]), sep='\\n\\n')# 输出：[&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;, &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;, &lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;, &lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;, &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt;]&lt;class 'bs4.element.Tag'&gt;# 返回值是一个列表，列表的元素是名为\"li\"的节点，每个元素都是bs4.element.Tag类型# 遍历每个a节点from bs4 import BeautifulSouphtml = \"\"\"&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/ul&gt;&lt;/div&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')li = soup.find_all(name='li')for a in li: print(a.find_all(name='a'))# 输出：[&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;][&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;][&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;][&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;][&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;] attires 参数 123456789101112131415161718192021222324252627from bs4 import BeautifulSouphtml = \"\"\"&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/ul&gt;&lt;/div&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')print(soup.find_all(attrs={'class': 'item-0'}))print(soup.find_all(attrs={'href': 'link5.html'}))# 输出：[&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt;][&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;]# 可以通过attrs参数传入一些属性来进行查询，即通过特定的属性来查询# find_all(attrs={'属性名': '属性值', ......}) text 参数 123456789101112131415161718192021222324252627from bs4 import BeautifulSoupimport rehtml = \"\"\"&lt;div class=\"panel\"&gt;&lt;div class=\"panel-body\"&gt;&lt;a&gt;Hello, this is a link&lt;/a&gt;&lt;a&gt;Hello, this is a link, too&lt;/a&gt;&lt;div/&gt;&lt;div/&gt;\"\"\"soup = BeautifulSoup(html, 'lxml')# 正则表达式规则对象regular = re.compile('link')# text参数课用来匹配节点的文本，传入的形式可以是字符串，也可以是正则表达式对象print(soup.find_all(text=regular))# 正则匹配输出print(re.findall(regular, html))# 输出：['Hello, this is a link', 'Hello, this is a link, too']['link', 'link'] 说明： 12find(name=None, attrs={}, recursive=True, text=None)# 仅返回与给定条件匹配标记的第一个元素 CSS选择器 Beautiful Soup 提供了CSS选择器，调用select()方法即可 css选择器用法：http://www.w3school.com.cn/cssref/css_selectors.asp 方法 1select(selector, namespaces=None, limit=None) 简单实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051html = '''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt;&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')ul_all = soup.select('ul')print(ul_all)for ul in ul_all: print() print( ul['id'], ul.select('li'), sep='\\n' )# 输出：[&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;, &lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;]list-1[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;]list-2[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;] 获取属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152html = '''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt;&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')ul_all = soup.select('ul')print(ul_all)for ul in ul_all: print() print( ul['id'], ul.attrs['id'], sep='\\n' )# 直接传入中括号和属性名 或者 通过attrs属性获取属性值 都可以成功获得属性值# 输出：[&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;, &lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;]list-1list-1list-2list-2 获取文本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253html = '''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt;&lt;ul class=\"list\" id=\"list-1\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;li class=\"element\"&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;ul class=\"list list-small\" id=\"list-2\"&gt;&lt;li class=\"element\"&gt;Foo&lt;/li&gt;&lt;li class=\"element\"&gt;Bar&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')ul_all = soup.select('li')print(ul_all)for li in ul_all: print() print( 'get_text()方法获取文本：'+li.get_text(), 'string属性获取文本：'+li.string, sep='\\n' )# 输出：[&lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;, &lt;li class=\"element\"&gt;Jay&lt;/li&gt;, &lt;li class=\"element\"&gt;Foo&lt;/li&gt;, &lt;li class=\"element\"&gt;Bar&lt;/li&gt;]get_text()方法获取文本：Foostring属性获取文本：Fooget_text()方法获取文本：Barstring属性获取文本：Barget_text()方法获取文本：Jaystring属性获取文本：Jayget_text()方法获取文本：Foostring属性获取文本：Fooget_text()方法获取文本：Barstring属性获取文本：Bar","link":"/p/261230202004/"},{"title":"Filter、Listener学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China Filter 简介 Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。 可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。 Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的： 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 Servlet 过滤器方法过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法： 序号 方法 &amp; 描述 1 public void doFilter (ServletRequest, ServletResponse, FilterChain) 该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。 2 public void init(FilterConfig filterConfig) web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 3 public void destroy() Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。 快速入门示例1过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。 Input web.xml 12345678910111213&lt;filter&gt; &lt;!-- 声明Filter名字 --&gt; &lt;filter-name&gt;demo01&lt;/filter-name&gt; &lt;!-- 对应的Filter类全名 --&gt; &lt;filter-class&gt;my.stringbug.FilterDemo01&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;!-- 对应声明的Filter名字 --&gt; &lt;filter-name&gt;demo01&lt;/filter-name&gt; &lt;!-- 过滤器的过滤路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; FilterDemo01.java 1234567891011121314151617public class FilterDemo01 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"FilterDemo01 过滤器给执行了 ～～\"); // 放行（假如没有放行，那么被该过滤器过滤的页面都不会有请求信息和响应信息） filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { }} index.jsp 123&lt;body&gt; &lt;h1&gt;Demo 01 ~~~~~&lt;/h1&gt;&lt;/body&gt; Output 控制台 1FilterDemo01 过滤器给执行了 ～～ 浏览器页面 1Demo 01 ~~~~~ 示例2使用注解的方式进行声明，映射到对应的应用程序的部署描述符中的 Servlet 名称或 URL 模式。 Input FilterDemo02.java 12345678910111213141516171819// \"/*\" 访问所有资源之前，都会执行该过滤器@WebFilter(\"/*\")public class FilterDemo02 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"FilterDemo02 过滤器给执行了 ～～\"); // 放行（假如没有放行，那么被该过滤器过滤的页面都不会有请求信息和响应信息） filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { }} index.jsp 123&lt;body&gt; &lt;h1&gt;Demo 02 ~~~~~&lt;/h1&gt;&lt;/body&gt; Output 控制台 1FilterDemo02 过滤器给执行了 ～～ 浏览器页面 1Demo 02 ~~~~~ Filter 执行流程 &amp; Filter 生命周期Filter 执行流程 Filter 接口中有一个doFilter 方法，当咱们编写好 Filter，并配置对哪个 web 资源进行拦截后，web 服务器每次在调用 web 资源的 service 方法之前，都会先调用一下 Filter 的 doFilter 方法，因此，在该方法内编写代码可达到如下的： 调用目标资源之前，让一段代码执行； 是否调用目标资源，即是否让用户访问 web 资源； 调用目标资源之后，让一段代码执行。 web 服务器在调用 doFilter 方法时，会传递一个 filterChain 对象进来，filterChain 对象是 filter 接口中最重要的一个对象，它也提供了一个 doFilter 方法，开发人员可以根据需求决定是否调用此方法。如果调用该方法，则 web 服务器就会调用 web 资源的 service 方法，即 web 资源就会被访问；否则的话， web 资源就不会被访问。 Filter 生命周期 init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 Filter 配置说明拦截路径配置 具体资源路径，如：/index.jsp 拦截某个目录，如：/directory1/directory2/* 后缀名拦截，如：*.html 拦截所有资源，如：/* 拦截方式配置 注解配置 属性 类型 说明 asyncSupported boolean 指定Filter是否支持异步模式 dispatcherTypes DispatcherType[ ] 指定Filter对哪种方式的请求进行过滤。支持的属性：ASYNC、ERROR、FORWARD、INCLUDE、REQUEST；默认过滤所有方式的请求 filterName String Filter名称 initParams WebInitParam[ ] 配置参数 displayName String Filter显示名 servletNames String[ ] 指定对哪些Servlet进行过滤 urlPatterns/value String[ ] 两个属性作用相同，指定拦截的路径 web.xml配置 &lt;filter&gt;指定一个过滤器。 &lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。 &lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。 &lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;param-name&gt;指定参数的名字，&lt;param-value&gt;指定参数的值。 在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。 &lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。 一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径 &lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字 &lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式) &lt;servlet-name&gt;指定过滤器所拦截的Servlet名称。 &lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt;子元素用来指定 Filter 对资源的多种调用方式进行拦截。 &lt;dispatcher&gt;子元素可以设置的值及其意义 REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 过滤器链有多个过滤器，过滤器的执行顺序和拦截顺序说明。 过滤器先后顺序问题 注解配置：按照类名的字符串比较规则比较，值小的先执行。 如： AFilter 和 BFilter，AFilter先执行。 web.xml配置：谁定义在上边，谁先执行 过滤器执行顺序如果有两个过滤器：过滤器1和过滤器2 过滤器1 12345678910111213141516171819@WebFilter(value = \"/index.jsp\")public class FilterDemo04 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"小明通过过滤器1，去服务器了\"); // Filter1 放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"小明通过过滤器1，从服务器回来了\"); } @Override public void destroy() { }} 过滤器2 12345678910111213141516171819@WebFilter(value = \"/index.jsp\")public class FilterDemo05 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"小明通过过滤器2，去服务器了\"); // Filter2 放行 filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"小明通过过滤器2，从服务器回来了\"); } @Override public void destroy() { }} index.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Filter And Listener Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% System.out.println(\"服务器资源被访问了\"); %&gt; &lt;/body&gt;&lt;/html&gt; 启动服务器，访问index.jsp资源，控制台输出： 12345小明通过过滤器1，去服务器了小明通过过滤器2，去服务器了服务器资源被访问了小明通过过滤器2，从服务器回来了小明通过过滤器1，从服务器回来了 Listener 学习笔记简介监听器就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。监听器可以用来检测网站的在线人数，统计网站的访问量等 监听器涉及三个组件：事件源，事件对象，事件监听器 当事件源发生某个动作的时候，它会调用事件监听器的方法，并在调用事件监听器方法的时候把事件对象传递进去。 ServletContextListenerServletContextListener：监听ServletContext对象的创建和销毁 12345void contextDestroyed(ServletContextEvent sce)// ServletContext对象被销毁之前会调用该方法void contextInitialized(ServletContextEvent sce)// ServletContext对象创建后会调用该方法 快速入门 实现ServletContextListener接口 复写方法 配置(web.xml配置或注解配置) 实现ServletContextListener接口，复写方法 12345678910111213141516171819public class ContextLoaderListener implements ServletContextListener { /** * 监听ServletContext对象创建的。ServletContext对象在服务器启动后自动创建。 */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) { // ServletContext对象创建后会调用该方法 System.out.println(\"ServletContext 对象被创建了\"); } /** * 在服务器关闭后，ServletContext对象被销毁。当服务器正常关闭后，该方法会被执行。 */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { // ServletContext对象被销毁之前会调用该方法 System.out.println(\"ServletContext 对象被销毁了\"); }} web.xml配置 123&lt;listener&gt; &lt;listener-class&gt;my.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注解配置：在实现监听接口的方法上面添加注解 1@WebListener(\"my/listener/contextLoaderListener\") 正常的启动服务器，和关闭服务器：控制台输出 启动服务器 1ServletContext 对象被创建了 关闭服务器 1ServletContext 对象被销毁了 参考文献 Servlet 编写过滤器 | 菜鸟教程 详述 Java 中过滤器 Filter 的工作原理及使用方法 Servlet3.0下@WebFilter注解配置Filter 监听器入门看这篇就够了","link":"/p/421227202006/"},{"title":"HTML 的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China HTML 的简单了解HTML 标签（详细）HTML 文本标签的学习HTML 图片标签的学习HTML 列表标签的学习HTML 链接标签的学习HTML 块标签的学习（样式/节）HTML 页眉、页脚标签的学习（样式/节）HTML table表格标签的学习HTTP 中 GET 与 POST 的区别HTML 表单标签之form标签的学习HTML 表单标签之input标签的学习HTML 表单标签之select标签的学习HTML 表单标签之textarea标签的学习","link":"/p/431606202005/"},{"title":"HTTP 协议的学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China 请求消息 请求消息：客户端发送给服务器端的数据。 数据格式：请求行、请求头、请求空行、请求体 响应消息 响应消息：服务器端发送给客户端的数据。 数据格式： 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码分类： 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 如： in-line：默认值，在当前页面内打开。 attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体（传输的数据） 响应字符串格式1234HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 参考文献无","link":"/p/180028202005/"},{"title":"Hadoop 分布式下安装和配置 HBase（CentOS 7系统）","text":"@Author: YiHua Lee @Address: Guangdong province, China 软件版本 电脑系统：macOS 10.14.6 虚拟机软件：Parallels Desktop15 Hadoop各节点节点操作系统：CentOS-7-x86_64-Minimal-1908.iso CentOS 7 JDK版本：jdk1.8.0_162 Hadoop版本：hadoop-2.7.7 ZooKeeper版本：zookeeper-3.4.13 HBase版本：hbase-1.3.1 环境配置说明 电脑配置：MacBook Pro 13（8G + 256G） 三台 CentOS 7 配置：内存1G、硬盘13G（与Mac完全隔离的虚拟机） 三台 CentOS 7 的名字及IP：node1（10.211.55.18）、node2（10.211.55.19）、node3（10.211.55.20） 三台虚拟机的用户名：lyh node为主结点、node2、node3为次节点 一定要注意：标注是操作哪台node主机，默认是node1 安装前提 安装好JDK、Hadoop 安装好ZooKeeper 参考文献：Hadoop分布式集群搭建、Hadoop 分布式下安装和配置 ZooKeeper（CentOS 7系统） 下载并上传HBase安装包 下载HBase安装包：https://archive.apache.org/dist/hbase/1.3.1/hbase-1.3.1-bin.tar.gz 将下载好的HBase安装包上传到node1 1scp -r ~/Desktop/hbase-1.3.1-bin.tar.gz lyh@10.211.55.18:/app 进入node1，解压压缩包 1cd /app 1tar -zxvf hbase-1.3.1-bin.tar.gz 将hbase-1.3.1-bin 名字修改为 hbase-1.3.1 1mv hbase-1.3.1-bin hbase-1.3.1 创建 hbase 软链接 1ln -s hbase-1.3.1 hbase 安装并配置 HBase配置Linux环境变量1vim /etc/profile 添加环境变量： 123# HBASEexport HBASE_HOME=/app/hbaseexport PATH=$HBASE_HOME/bin:$PATH 保存并退出，使环境变量生效： 1source /etc/profile 集群配置HBase 资源配置 配置 hbase-env.sh 文件 12cd /app/hbase/confvim hbase-env.sh 修改如下： 配置文件中的JAVA_HOME路径 1export JAVA_HOME=/app/jdk 注释掉对jdk7的优化，因为这里使用的jdk是8版本 12# export HBASE_MASTER_OPTS=&quot;$HBASE_MASTER_OPTS -XX:PermSize=128m -XX:MaxPermSize=128m&quot;# export HBASE_REGIONSERVER_OPTS=&quot;$HBASE_REGIONSERVER_OPTS -XX:PermSize=128m -XX:MaxPermSize=128m&quot; 开启 manages zookeeper（不使用hbase自带的zk） 1export HBASE_MANAGES_ZK=false 指定PID路径 12# 自定义HBase PID位置export HBASE_PID_DIR=/app/pids HBase 集群配置 向 hbase-site.xml 文件中添加配置 1cd /app/hbase/conf 1vim hbase-site.xml 添加如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;configuration&gt; &lt;!-- Hbase的数据保存在HDFS对应的目录下：注意端口，与HDFS的一样 --&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://node1:8020/hbase&lt;/value&gt; &lt;/property&gt; &lt;!-- 是否是分布式环境 --&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 配置ZK的地址，3个节点都启用ZooKeeper --&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;node1,node2,node3&lt;/value&gt; &lt;/property&gt; &lt;!-- 冗余度 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;!-- 主节点和从节点允许的最大时间误差 --&gt; &lt;property&gt; &lt;name&gt;hbase.master.maxclockskew&lt;/name&gt; &lt;value&gt;180000&lt;/value&gt; &lt;/property&gt; &lt;!-- zookeeper数据目录 --&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/app/hbase/zookeeperData&lt;/value&gt; &lt;/property&gt; &lt;!-- 手动配置管理web端口，默认是 16010 --&gt; &lt;property&gt; &lt;name&gt;hbase.master.info.port&lt;/name&gt; &lt;value&gt;60010&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 列出所有运行hbase的机器：修改regionservers文件 1cd /app/hbase/conf 1vim regionservers 删除原有内容，添加如下内容： 123node1node2node3 指明备用的 master 节点：backup-masters（这个文件是不存在的，需要新建） 1cd /app/hbase/conf 1vim backup-masters 以这里为例，配置如下： 1node2 HDFS 客户端配置 进入 /app/hadoop/etc/hadoop 文件夹，修改 hadoop-env.sh 中的配置（修改PID生成的位置，node1、node2、node3都要修改） 1cd /app/hadoop/etc/hadoop 1vim hadoop-env.sh 要被修改的内容是： 12export HADOOP_PID_DIR=${HADOOP_PID_DIR}export HADOOP_SECURE_DN_PID_DIR=${HADOOP_PID_DIR} 将其路径修改为上面创建的 pids 文件夹 12export HADOOP_PID_DIR=/app/pidsexport HADOOP_SECURE_DN_PID_DIR=/app/pids 修改yarn-env.sh （自定义PID生成位置，node1、node2、node3都要修改） 1cd /app/hadoop/etc/hadoop 1vim yarn-env.sh 添加如下内容： 1export YARN_PID_DIR=/app/pids 如果您在 Hadoop 集群上进行了 HDFS 客户端配置的更改，比如将副本系数 dfs.replication 设置成 5，则必须使用以下方法之一来使 HBase 知道，否则 HBase 将依旧使用默认的副本系数 3 来创建文件。 解决方式有三种，如下面： 将 Hadoop 配置文件的位置信息添加到 hbase-env.sh 的 HBASE_CLASSPATH 属性 12cd /app/hbase/confvim hbase-env.sh 配置信息如下 1export HBASE_CLASSPATH=/app/hadoop/etc/hadoop 将 Hadoop 的 hdfs-site.xml 和 core-site.xml 拷贝到 ${HBASE_HOME}/conf 目录下 123cd /app/hadoop/etc/hadoopcp core-site.xml /app/hbase-1.3.1/conf/cp hdfs-site.xml /app/hbase-1.3.1/conf/ 在 ${HBASE_HOME}/conf 目录下，创建hdfs-site.xml 和 core-site.xml 的软链接 123cd /app/hadoop/etc/hadoopln -s core-site.xml /app/hbase/conf/core-site.xmlln -s core-site.xml /app/hbase/conf/hdfs-site.xml 按照前面配置，创建对应目录 进入 hbase-1.3.1 文件夹，创建 zookeeperData 文件夹 进入 app 文件夹，创建pids文件夹，赋予权限，node1、node2、node3都需要创建pids文件 12cd /app/hbasemkdir zookeeperData 123cd /appmkdir pidschown -R root:root pids 安装包分发 将 hbase-1.3.1 分发到到 node2、node3 1cd /app 12scp -r hbase-1.3.1 node2:/appscp -r hbase-1.3.1 node3:/app 分别到 node2、node3 创建 hbase-1.3.1 的软链接 12cd /appln -s hbase-1.3.1 hbsae 启动和关闭 HBase HBase 的启动前需要先启动Hadoop和ZooKeeper 启动Hadoop node1 中输入：start-dfs.sh 和 start-yarn.sh 启动ZooKeeper node1、node2、node3中都要输入：zkServer.sh start 为了避免没启动ZooKeeper，可以查看zookeeper的启动状态：zkServer.sh status 启动HBase node1 中输入：start-hbase.sh 进入和退出 HBase Shell 进入HBase Shell：hbase shell 退出HBase Shell：exit Web 端访问 HBase 页面：http://10.211.55.18:60010 访问的时候，可能会有如下提示（HBase集群中Master服务挂掉了）： The load balancer is not enabled which will eventually cause performance degradation in hbase as regions will not be distributed across all regionservers.The balancer is only expected to be disabled during rolling upgrade scenarios. 解决办法：进入HBase Shell，输入并执行 balance_switch true ，这个时候再访问 HBase Web端，就不会有该提示了。 关闭 HBase，在关闭 HBase之前，一定不要先关闭Hadoop和ZooKeeper 关闭HBase node1 中输入：stop-hbase.sh 关闭ZooKeeper node1、node2、node3中都要输入：zkServer.sh stop 关闭Hadoop node1 中输入：stop-all.sh 参考文献 HBase 系列（四）—— HBase 集群环境配置 HBase运维系列：Regions In Transition","link":"/p/471209202007/"},{"title":"Hadoop 分布式下安装和配置 ZooKeeper（CentOS 7系统）","text":"@Author: YiHua Lee @Address: Guangdong province, China 软件版本 电脑系统：macOS 10.14.6 虚拟机软件：Parallels Desktop15 Hadoop各节点节点操作系统：CentOS-7-x86_64-Minimal-1908.iso CentOS 7 JDK版本：jdk1.8.0_162 Hadoop版本：hadoop-2.7.7 ZooKeeper版本：zookeeper-3.4.13 环境配置说明 电脑配置：MacBook Pro 13（8G + 256G） 三台 CentOS 7 配置：内存1G、硬盘13G（与Mac完全隔离的虚拟机） 三台 CentOS 7 的名字及IP：node1（10.211.55.18）、node2（10.211.55.19）、node3（10.211.55.20） 三台虚拟机的用户名：lyh node为主结点、node2、node3为次节点 安装前提安装jdk，并配置好Linux环境变量。 参考文献：Hadoop分布式集群搭建 的JDK安装部分 ZooKeeper的安装与配置三台node主机都需要配置，这里没有采用配置好一台，分发到另外两台的方式。 本地下载zookeeper-3.4.13.tar.gz：https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz 将下载好的zookeeper-3.4.13.tar.gz上传到node1、node2、node3 1scp -r ~/Desktop/zookeeper-3.4.13.tar.gz lyh@10.211.55.18:/app 1scp -r ~/Desktop/zookeeper-3.4.13.tar.gz lyh@10.211.55.19:/app 1scp -r ~/Desktop/zookeeper-3.4.13.tar.gz lyh@10.211.55.20:/app 将上传上来的zookeeper-3.4.13.tar.gz解压 1cd /app 1tar -zxvf zookeeper-3.4.13.tar.gz 为zookeeper-3.4.13创建软链接 1ln -s zookeeper-3.4.13 zookeeper 拷贝simple_zoo.cfg 为 zoo.cfg 1cd /app/zookeeper/conf 1cp zoo_sample.cfg zoo.cfg 编辑zoo.cfg文件 1cd /app/zookeeper/conf 1vim zoo.cfg 修改内容如下（可以参考）： 123456789101112131415161718192021222324252627# 服务器与服务器之间 或 客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳。tickTime=2000# 配置 Zookeeper 接受客户端（此客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个# 心跳时间间隔数。当已超过initLimit个tickTime长度后 Zookeeper 服务器还没有收到客户端的返回信息，则表明客户端连接失败。总的时间长度就是 initLimit * tickTime 秒。initLimit=10# 配置 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 syncLimit * tickTime 秒。syncLimit=5# Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。dataDir=/app/zookeeper/data# dataDir和dataLogDir分到不同的目录里dataLogDir=/app/zookeeper/dataLog# Zookeeper服务器监听的端口，以接受客户端的访问请求。clientPort=2181# 服务器名称与地址:集群信息# server.A=B:C:D# A 为服务器编号、B 为服务器的 ip 地址、C 为这个服务器与集群中的 Leader 服务器交换信息的端口# D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，此端口就是用来执行选举时服务器相互通信的端口。# 2888端口是zookeeper服务相互通信使用的，3888端口是zookeeper服务选举使用的server.1=node1:2888:3888server.2=node2:2888:3888server.3=node3:2888:3888 配置 ZooKeeper 环境变量 1vim /etc/profile 添加如下内容： 123# ZOOKEEPERexport ZOOKEEPER_HOME=/app/zookeeperexport PATH=$ZOOKEEPER_HOME/bin:$PATH 使配置生效 1source /etc/profile 创建对应配置文件信息的文件夹 123cd /app/zookeepermkdir datamkdir dataLog 配置 myid 文件 这个文件在上述dataDir 指定的目录下，这个文件里面就只有一个数据，就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。 方式1 node1: 1echo \"1\" &gt;&gt; /app/zookeeper/data/myid node2: 1echo \"2\" &gt;&gt; /app/zookeeper/data/myid node3: 1echo \"3\" &gt;&gt; /app/zookeeper/data/myid 方式2 node1 12touch /app/zookeeper/data/myidvim /app/zookeeper/data/myid 添加内容：1 node2 12touch /app/zookeeper/data/myidvim /app/zookeeper/data/myid 添加内容：2 node3 12touch /app/zookeeper/data/myidvim /app/zookeeper/data/myid 添加内容：3 启动ZooKeeper 在ZooKeeper集群的每个结点上，执行启动ZooKeeper服务的脚本。zkServer.sh start 123[root@node1 ~ ]# zkServer.sh start[root@node2 ~ ]# zkServer.sh start[root@node3 ~ ]# zkServer.sh start 验证个节点的状态。zkServer.sh status 123[root@node1 zookeeper]# zkServer.sh status[root@node2 zookeeper]# zkServer.sh status[root@node3 zookeeper]# zkServer.sh status 关闭ZooKeeper 在ZooKeeper集群的每个结点上，执行关闭ZooKeeper服务的脚本。zkServer.sh stop 123[root@node1 zookeeper]# zkServer.sh stop[root@node2 zookeeper]# zkServer.sh stop[root@node3 zookeeper]# zkServer.sh stop 参考文献 CentOS7安装配置zookeeper集群","link":"/p/201205202007/"},{"title":"Hadoop分布式集群搭建","text":"@Author: YiHua Lee @Address: Guangdong province, China 环境准备软件版本 电脑系统：macOS 10.14.6 虚拟机软件：Parallels Desktop15 Hadoop各节点节点操作系统：CentOS-7-x86_64-Minimal-1908.iso CentOS 7 JDK版本：jdk1.8.0_162 Hadoop版本：hadoop-2.7.7 环境配置说明 电脑配置：MacBook Pro 13（8G + 256G） 三台 CentOS 7 配置：内存1G、硬盘13G（与Mac完全隔离的虚拟机） 三台 CentOS 7 的名字及IP：node1（10.211.55.18）、node2（10.211.55.19）、node3（10.211.55.20） 三台虚拟机的用户名：lyh 操作说明 下面所有的操作，都是在root权限下进行的：su root 进入root权限 下面所有的操作，都是用 Mac 的终端远程连接（ssh）三台 CentOS 7 进行的，这样会比较方便快捷 由于centos虚拟机网络环境没有本机好，所以这里采用的是本地下载好所需文件包，然后通过MacOS 终端上传到虚拟机，大家也可以采取直接从虚拟机上下载所需的文件包。 免密登录配置vim 的安装CentOS-7-Minimal 刚安装好，需要给三台主机都安装vim编辑器： 1yum install vim -y 如果不确定vim是否安装成功，可以输入vim -h 查看是否有vim命令 host配置 开启虚拟机，默认是在 /home/lyh 目录下的，host配置文件在根目录下的 etc 文件夹下，给三台虚拟机均进行配置。 注意，下面的host配置，一定要根据自己的主机名和ip进行配置，三台主机的配置均一样。 根目录下，输入：vim ../../etc/hosts ，最后面添加如下内容： 12310.211.55.18 node110.211.55.19 node210.211.55.20 node3 关闭防火墙三台主机都需要进行该配置。 查看防火墙状态 1firewall-cmd --state 停止防火墙 1systemctl stop firewalld.service 禁止防火墙开机启动 1systemctl disable firewalld.service 关闭selinux 第一步：在 /home/lyh'目录下，输入： 1vim ../../etc/selinux/config 注释掉 SELINUX=enforcing ，添加如下内容： 1SELINUX=disabled 也可以直接将enforcing修改为disabled。 配置所有各自服务器本身公钥和免密： 1ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa 将公钥追加到”authorized_keys”文件 1cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 免密登录公钥分发 每台主机，互相分发公钥，实现各个主机之间的免密登录。 说明：三台主机对应的IP 123node1（10.211.55.18）node2（10.211.55.19）node3（10.211.55.20） node1 分发给：node2、node3 1ssh-copy-id -i ~/.ssh/id_dsa.pub 10.211.55.19 1ssh-copy-id -i ~/.ssh/id_dsa.pub 10.211.55.20 node2 分发给：node1、node3 1ssh-copy-id -i ~/.ssh/id_dsa.pub 10.211.55.18 1ssh-copy-id -i ~/.ssh/id_dsa.pub 10.211.55.20 node3 分发给：node1、node2 1ssh-copy-id -i ~/.ssh/id_dsa.pub 10.211.55.18 1ssh-copy-id -i ~/.ssh/id_dsa.pub 10.211.55.19 免密登录配置，已经完成，可以进行测试 12345ssh node1ssh node2ssh node3 三台主机之间可以实现免密登录了 下载并配置JDK下载JDK并上传到虚拟机大家可以去到：https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html，选择自己需要下载的JDK版本，我这里下载的是 jdk-8u162-linux-x64.tar.gz，下载好后，通过终端，分别上传到三台虚拟机： 1scp -r 本地下载好的JDK路径 虚拟机用户名@虚拟机ip:要上传到虚拟机的路径 如：下载好的JDK包在桌面，要上传到 lyh 用户的 /app 路径下，该用户的IP为 10.211.55.18 。 1scp -r ~/Desktop/jdk-8u162-linux-x64.tar.gz lyh@10.211.55.18:/app 这里上传到虚拟机根目录的 app 文件夹下，app 文件夹是需要自己创建的。 解压JDK包并配置Linux环境变量进入 app 文件夹（三台虚拟机都需要安装JDK） 解压JDK包 1tar -zxvf jdk-8u162-linux-x64.tar.gz 创建为JDK软链接 1ln -s jdk1.8.0_162 jdk 配置环境变量 在根目录/ 下，输入vim /etc/profile，添加如下内容： 12345# JAVAexport JAVA_HOME=/app/jdkexport JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:.export PATH=${JAVA_HOME}/bin:$PATH 路径要根据自己的实际情况来更改，如我这里的是：/app/jdk 如果不能写入，说明没有前面没有进入root权限，请按下esc后，强制写入保存： 输入： 1:w !sudo tee % 回车后，需要输入用户密码，以及输入字母 O 确认。 然后退出：:!q 使刚刚的配置生效 1source /etc/profile 验证JDK安装是否完成 1java -version 出现以下字眼说明安装成功了 123java version &quot;1.8.0_162&quot;Java(TM) SE Runtime Environment (build 1.8.0_162-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode) 安装Hadoop-2.7.7三台虚拟机都需要安装Hadoop-2.7.7 下载hadoop2.7.7并上传到虚拟机下载地址：https://archive.apache.org/dist/hadoop/core/hadoop-2.7.7/ 选择hadoop-2.7.7.tar.gz进行下载，这里默认将文件下载到 ~/Desktop，上传到虚拟机的 /app 目录下 分别上传到三台虚拟机： 1src -r ~/Desktop/hadoop-2.7.7.tar.gz lyh@10.211.55.18:/app 1src -r ~/Desktop/hadoop-2.7.7.tar.gz lyh@10.211.55.19:/app 1src -r ~/Desktop/hadoop-2.7.7.tar.gz lyh@10.211.55.20:/app 解压安装包并配置Linux环境变量 解压Hadoop安装包 1tar -zxvf hadoop-2.7.7.tar.gz 为hadoop-2.7.7创建软链接 1ln -s hadoop-2.7.7 hadoop 配置Linux环境变量 进入根目录 / 1vim /etc/profile 添加如下内容 123# HADOOPexport HADOOP_HOME=/app/hadoopexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 保存并退出，是写入的内容生效 1source /etc/profile 检查是否安装成功 输入：whereis hdfs 输出： 1hdfs: /app/hadoop-2.7.7/bin/hdfs.cmd /app/hadoop-2.7.7/bin/hdfs 输入：whereis start-all.sh 输出： 1start-all: /app/hadoop-2.7.7/sbin/start-all.cmd /app/hadoop-2.7.7/sbin/start-all.sh 这时候说明安装成功了 Hadoop 配置时间同步配置三台虚拟机都需要安装。 1yum install -y ntp 设置NTP服务开机启动 1chkconfig ntpd on 查看ntp进程是否启动 1ps aux | grep ntp 在node1进行文件配置修改目录 ${HADOOP_HOME}/etc/hadoop 目录中的文件1cd ${HADOOP_HOME}/etc/hadoop 设置 hadoop-env.sh 编辑hadoop-env.sh文件，找到export JAVA_HONE，修改如下： 1export JAVA_HOMT=/app/jdk 修改 core-site.xml 配置文件 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node1:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/app/hadoop/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 hdfs-site.xml 配置文件 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将 mapred-site.xml.template 复制为文件名是 mapred-site.xml 的文件 1cp mapred-site.xml.template mapred-site.xml 修改 mapred-site.xml 配置文件 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 yarn-site.xml 配置文件 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;!-- Site specific YARN configuration properties --&gt;&lt;/configuration&gt; 修改 slaves 文件，删除原有内容，修改为如下内容： 12node2node3 分发配置到 node2、node3 虚拟机 将 hadoop/etc目录下的 hadoop 文件夹分发给另外两台虚拟机 1cd ${HADOOP_HOME}/etc 1scp -r hadoop lyh@node2:/app/hadoop/etc/ 1scp -r hadoop lyh@node3:/app/hadoop/etc/ 初始化及启动 在此之前需要先下载openjdk-devel 1yum install java-1.8.0-openjdk-devel.x86_64 在 node1 格式化 hdfs 1hdfs namenode -format 启动Hadoop服务 启动HDFS：start-dfs.sh 启动YARN：start-yarn.sh 启动all：start-all.sh 输入 jps 可以查看进程 关闭Hadoop服务 1stop-all.sh 参考文献 Hadoop分布式安装 Mac系统下，Hadoop集群的搭建 hadoop分布式集群搭建 CentOS7查看和关闭防火墙 Hadoop集群SSH服务和免密码登录的配置 vim /etc/profile 写入时 出现 E121:无法打开并写入文件解决方案 jps命令无法找到","link":"/p/582327202005/"},{"title":"Hadoop 分布式集群中安装 Hive（CentOS 7系统）","text":"@Author: YiHua Lee @Address: Guangdong province, China 软件版本 电脑系统：macOS 10.14.6 虚拟机软件：Parallels Desktop15 Hadoop各节点节点操作系统：CentOS-7-x86_64-Minimal-1908.iso CentOS 7 JDK版本：jdk1.8.0_162 Hadoop版本：hadoop-2.7.7 Hive版本：hive-2.3.3 MySQL版本：mysql-5.7.30 环境配置说明 电脑配置：MacBook Pro 13（8G + 256G） 三台 CentOS 7 配置：内存1G、硬盘13G（与Mac完全隔离的虚拟机） 三台 CentOS 7 的名字及IP：node1（10.211.55.18）、node2（10.211.55.19）、node3（10.211.55.20） 三台虚拟机的用户名：lyh node为主结点、node2、node3为次节点 安装前提 安装jdk，并配置好Linux环境变量。 安装好Hadoop完全分布式 参考文献：Hadoop分布式集群搭建 安装并配置MySQL卸载node1、node2、node3中系统自带的Maria DB 说明： 三台node都可以不用卸载Maria DB，使用Maria DB。 也可以不用卸载node2、node3中的Maria DB，只卸载node1中的Maria DB，因为node2、node3中的Maria DB不影响Hive的搭建。 本博文教程中，MySQL只在node1中安装。卸载node1、node2、node3中系统自带的Maria DB。 查看进程 1ps -f | grep mysqld 杀死进程 1pkill -9 mysqld 查看是否已安装MariaDB、或一些MariaDB相关的模块 1rpm -qa | grep mariadb 卸载MariaDB 1yum -y remove mariadb* 再次检查卸载干净，若已看不到相关mariadb打印了即可 1rpm -qa | grep mariadb 将mysql安装包上传到node1 本地下载mysql-5.7.30安装包（下载到了桌面） http://ftp.ntu.edu.tw/MySQL/Downloads/MySQL-5.7/mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz 将安装包上传到node1中的 /app 文件夹下 1scp -r ~/Desktop/mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz lyh@10.211.55.18:/app 安装依赖libaio 查看是否已经安装libaio 12ps aux | grep libaiops -ef | grep libaio 没有的话，就安装： 12yum install -y libaioyum install -y cmake make gcc gcc-c++ libaio ncurses ncurses-devel 安装 MySQL 查询全部用户（检查mysql组和用户是否存在） 1cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F \":\" '{print $1 \"|\" $3 \"|\" $4}' | more 1234# 我这里显示如下：root|0|0sync|5|0lyh|1000|1000 或者： 12cat /etc/group | grep mysqlcat /etc/passwd | grep mysql 创建用户和组（若不存在，则创建mysql组和用户） 创建mysql用户组 1groupadd mysql 创建一个用户名为mysql的用户，并加入mysql用户组 1useradd -g mysql mysql 将mysql用户的密码指定为 123456 1passwd mysql 解压刚刚下载mysql安装包 1cd /app 1tar -zxvf mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz 创建为mysql软链接 1ln -s mysql-5.7.30 mysql 更改所属的组和用户 1cd /app 12chown -R mysql mysql/chgrp -R mysql mysql/ 1cd mysql/ 12mkdir datachown -R mysql:mysql data 在 /etc 文件夹下创建my.cnf文件 1touch /etc/my.cnf 1chown 777 /etc/my.cnf 编辑my.cnf文件 1vim /etc/my.cnf 添加如下内容： 123456789101112131415161718192021222324252627[mysql]socket=/var/lib/mysql/mysql.sock# set mysql client default chararterdefault-character-set=utf8[mysqld]skip-grant-tablessocket=/var/lib/mysql/mysql.sock# set mysql server portport = 3306# set mysql install base dirbasedir=/app/mysql# set the data store dirdatadir=/app/mysql/data# set the number of allow max connnectionmax_connections=200# set server charactre default encodingcharacter-set-server=utf8# the storage enginedefault-storage-engine=INNODBlower_case_table_names=1max_allowed_packet=16Mexplicit_defaults_for_timestamp=true[mysql.server]user=mysqlbasedir=/app/mysql 进入mysql文件夹，安装mysql 1cd /app/mysql 1bin/mysql_install_db --user=mysql --basedir=/app/mysql/ --datadir=/app/mysql/data/ 1cp ./support-files/mysql.server /etc/init.d/mysqld 1chmod +x /etc/init.d/mysqld 1mkdir /var/lib/mysql 1chmod 777 /var/lib/mysql 启动mysql 1/etc/init.d/mysqld restart 说明： 启动过程中可能会出现如下问题： 解决办法： 找到是否已经有进程占用 1ps aux|grep mysql 123root 15163 0.0 0.1 113416 1604 pts/0 S 05:31 0:00 /bin/sh /app/mysql/bin/mysqld_safe --datadir=/app/mysql/data --pid-file=/app/mysql/data/node1.pidmysql 15394 0.3 17.0 1119928 172140 pts/0 Sl 05:31 0:00 /app/mysql/bin/mysqld --basedir=/app/mysql --datadir=/app/mysql/data --plugin-dir=/app/mysql/lib/plugin --user=mysql --log-error=node1.err --pid-file=/app/mysql/data/node1.pid --socket=/var/lib/mysql/mysql.sock --port=3306root 15425 0.0 0.0 112828 980 pts/0 R+ 05:33 0:00 grep --color=auto mysql 关闭进程 1kill -9 15394 确认是否还占用 1ps aux|grep mysql 1root 15436 0.0 0.0 112824 976 pts/0 S+ 05:34 0:00 grep --color=auto mysql 重启mysql 1/etc/init.d/mysqld restart 设置开机启动MySQL1cd /app/mysql 12chkconfig --level 35 mysqld onchkconfig --list mysqld 123chmod +x /etc/rc.d/init.d/mysqldchkconfig --add mysqldchkconfig --list mysqld 查看mysql状态 1service mysqld status 修改配置文件1vim /etc/profile 修改/etc/profile，在最后添加如下内容 1export PATH=$PATH:/app/mysql/bin 保存并退出，然后是修改内容生效 1source /etc/profile 获取MySQL初始密码1cat /root/.mysql_secret 12初始密码：#(6aFtq&lt;zLi2 修改MySQL初始密码 进入mysql命令行 1mysql -uroot -p 然后输入获取到的初始密码，如这里获取到的初始密码为：#(6aFtq&lt;zLi2 没有修改密码的时候 在mysql命令行修改密码 设置密码为：123456 1set PASSWORD = PASSWORD('123456'); 更新 1flush privileges; 验证新密码是否登录成功 1mysql -uroot -p123456 添加远程访问权限123use mysql;update user set host='%' where user='root';select host,user from user; 重启MySQL，使刚刚的配置生效： 1/etc/init.d/mysqld restart node1 安装并配置Hive下载Hive、上传到node1、2、3 下载 Hive https://archive.apache.org/dist/hive/hive-2.3.3/apache-hive-2.3.3-bin.tar.gz 将Hi 册上传到node1、node2、node3的 /app 文件夹下 1scp -r ~/Desktop/apache-hive-2.3.3-bin.tar.gz lyh@10.211.55.18:/app 1scp -r ~/Desktop/apache-hive-2.3.3-bin.tar.gz lyh@10.211.55.19:/app 1scp -r ~/Desktop/apache-hive-2.3.3-bin.tar.gz lyh@10.211.55.20:/app 解压apache-hive-2.3.3-bin.tar.gz 1tar -zxvf apache-hive-2.3.3-bin.tar.gz 重命名 apache-hive-2.3.3-bin 1mv apache-hive-2.3.3-bin hive-2.3.3 创建软链接 1ln -s hive-2.3.3 hive 删除apache-hive-2.3.3-bin.tar.gz 1rm -rf apache-hive-2.3.3-bin.tar.gz 配置 Hive 环境 进入mysql命令行（node1） 创建可以登录mysql下的hive用户，密码设置为 123456 1mysql -uroot -p123456 1USE mysql; 12-- 用户名：hive 密码：123456CREATE USER hive IDENTIFIED BY '123456'; 12-- 为 hive 用户分配所有权限，该用户可以在任何电脑上登录 mysql 服务器GRANT ALL PRIVILEGES ON *.* TO 'hive'@'%' IDENTIFIED BY 'hive'; 使用 hive 用户登录 mysql 1mysql -uhive -p123456 创建 hive 专用数据库 1create database hive; 笨蛋下载mysql-connector-java-5.1.48.jar 将本地下载好的mysql-connector-java-5.1.48.jar上传到node1的/app/hive/lib 目录下 1scp -r ~/Desktop/mysql-connector-java-5.1.48.jar lyh@10.211.55.18:/app/hive/lib 配置Linux环境变量(node1、node2、node3都需要配置) 1vim /etc/profile 12export HIVE_HOME=/app/hiveexport PATH=$PATH:$HIVE_HOME/bin 1source /etc/profile 创建hive-site.xml并编辑（node1） 1cd /app/hive/conf 1vim hive-site.xml 添加如下内容 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?&gt;&lt;configuration&gt; &lt;!-- 连接mysql地址 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/hive?useSSL=false&lt;/value&gt; &lt;/property&gt; &lt;!-- 数据库驱动 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.otion.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;!-- 连接MySQL用户名 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;/property&gt; &lt;!-- 连接MySQL密码 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; node1 上面如果将localhost改成主机名会导致，hive数据库初始化失败，最终虽然能登录hive，但不能用。 初始化 hive 数据库（node1） 1cd /app/hive/bin 1schematool -dbType mysql -initSchema 登录hive用户，查看hive数据库中是否有初始化生成的表（node1） 1mysql -uhive -p123456 1use hive; 1show tables; 测试hive（node1） 首先需要启动Hadoop 1start-all.sh 进入hive命令行 1hive 由于配置了hive环境变量，所有没有固定目录即可进入hive命令行 hive命令行执行如下操作 12-- 查看databaseshow databases; 12-- 查看tableshow tables; 12-- 创建一个数据库create database hive_test_db; &lt;img src=&apos;https://raw.githubusercontent.com/LeeYiua/FigureBed/master/img/July%202020/20200704224930.png&apos; alt=&apos;20200704224930&apos;/&gt; 12-- quit命令退出hive命令行，只能说quit，使用exit命令不可以。quit; node2、node3中 hive 的配置方法1将node1中配置好的hive文件分发到node2、node3，然后稍做修改。 将node1中的hive文件夹分发到node2、node3 1cd /app 1scp -r hive-2.3.3/ lyh@node2:/app/hive-2.3.3/ 1scp -r hive-2.3.3/ lyh@node3:/app/hive-2.3.3/ 然后修改部分hive-site.xml 的配置（node2、node3都一样的配置） 1cd /app/hive 1vim hive-site.xml 修改连接mysql地址 12345&lt;!-- 连接mysql地址 --&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://node1:3306/hive?useSSL=false&lt;/value&gt;&lt;/property&gt; 添加如下内容 12345&lt;!-- 指定多个 remote Metoresores --&gt;&lt;property&gt; &lt;name&gt;hive.metastore.uris&lt;/name&gt; &lt;value&gt;thrift://node1:9083&lt;/value&gt; &lt;/property&gt; 方法2 创建hive-site.xml并编辑（node2、node3） 1cd /app/hive/conf 1vim hive-site.xml 添加如下内容 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?&gt;&lt;configuration&gt; &lt;!-- 连接mysql地址 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://node1:3306/hive?useSSL=false&lt;/value&gt; &lt;/property&gt; &lt;!-- 数据库驱动 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.otion.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;!-- 连接MySQL用户名 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;/property&gt; &lt;!-- 连接MySQL密码 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt; &lt;!-- Hive 连接到其中一个 URI，以对 remote Metastore(以逗号分隔的 URI 列表)发出元数据请求 --&gt; &lt;property&gt; &lt;name&gt;hive.metastore.uris&lt;/name&gt; &lt;value&gt;thrift://node1:9083&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 提示：在使用客户端访问 hive 之前，在主机中执行 hive --service metastore &amp; 来启动metastore服务。这个时候，node2、node3使用hive命令了，数据库是node1中的hive数据库 执行了 hive --service metastore &amp;之后，node1中使用jps命令查看进程： 多了一个进程：RunJar Hive的安装和基本配置，已经完成。 参考文献 centos7卸载mariadb 安装mysql Linux 系统安装 MySQL 的官方文档 centos7下使用mysql离线安装包安装mysql5.7 在Hadoop分布式集群中安装hive Apache Hive 中文手册","link":"/p/472304202007/"},{"title":"JDBC 快速入门（MySQL）","text":"@Author: YiHua Lee @Address: Guangdong province, China 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库。 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 JDBC快速入门，Java程序实现： 连接Study数据库，向account表中的id=1的balance字段值加上500。表数据如下： 导入驱动jar包：mysql-connector-java-5.1.48.jar 复制mysql-connector-java-5.1.37-bin.jar到项目的一个目录下 右键–&gt;Add as Library 注册驱动 12// 2、注册驱动Class.forName(\"com.mysql.jdbc.Driver\"); Driver所在的包： 1package com.mysql.jdbc; 获取数据库连接对象 Connection 1234// 3、获取数据库连接对象Connection connection = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/Study\", \"用户名\", \"密码\"); 定义SQL语句 123// 4、定义SQL语句// 将account表中的id=1的balance字段值加上500String sql = \"UPDATE account Set balance = balance + 500 WHERE id = 1;\"; 获取执行SQL语句的对象 Statement 12// 5、获取执行sql的对象 StatementStatement statement = connection.createStatement(); 执行SQL 12// 6、执行SQL语句：执行成功，返回 1，即有一条数据受到了影响int returnResult = statement.executeUpdate(sql); 处理结果 12// 7、查看是否执行成功，有多少条数据收到影响System.out.println(returnResult); 释放资源 123// 8、释放资源statement.close();connection.close(); 现在查看一下表中的数据 发现表中id=1的，balance字段值增加了500。 控制台输出：1，表示有一条数据受到了影响。 程序代码： 12345678910111213141516171819202122232425262728293031323334353637import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JdbcDemo01 { public static void main(String[] args) throws ClassNotFoundException, SQLException { // 1、导入jar包：mysql-connector-java-5.1.48.jar // Add as Library ... // 2、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 3、获取数据库连接对象 Connection connection = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/Study\", \"用户名\", \"密码\"); // 4、定义SQL语句 // 将account表中的id=1的balance字段值加上500 String sql = \"UPDATE account Set balance = balance + 500 WHERE id = 1;\"; // 5、获取执行sql的对象 Statement Statement statement = connection.createStatement(); // 6、执行SQL语句 int returnResult = statement.executeUpdate(sql); // 7、查看是否执行成功 System.out.println(returnResult); // 8、释放资源 statement.close(); connection.close(); }} 运行程序虽然执行成功，不过会抛出警告。要想去除警告，只需要在获取数据库连接对象的时候，更改一下URL即可： 12345// 更改前：jdbc:mysql://localhost:3306/Study// 更改后jdbc:mysql://localhost:3306/Study?useSSL=false","link":"/p/011506202005/"},{"title":"JQuery 学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China jQuery 简介 jQuery是一个JavaScript函数库。 jQuery是一个轻量级的”写的少，做的多”的JavaScript库。 jQuery库包含以下功能：HTML 元素选取、HTML 元素操作、CSS 操作、HTML 事件函数、JavaScript 特效和动画、HTML DOM 遍历和修改、AJAX、Utilities （除此之外，Jquery还提供了大量的插件。） jQuery 的引用jQuery 库是一个 JavaScript 文件，您可以使用 HTML 的 &lt;script&gt; 标签引用它 12345&lt;!-- 通过下载好的jquery文件进行引用 --&gt;&lt;script src=\"jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;!-- 或者通过Staticfile CDN、又拍云、新浪、谷歌或微软等引用 jQuery --&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"&gt; 使用 Staticfile CDN、百度、又拍云、新浪、谷歌或微软的 jQuery，有一个很大的优势： 许多用户在访问其他站点时，已经从百度、又拍云、新浪、谷歌或微软加载过 jQuery。所以结果是，当他们访问您的站点时，会从缓存中加载 jQuery，这样可以减少加载时间。同时，大多数 CDN 都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度。 jQuery 语法jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(selector).action() $ 符号定义 jQuery 选择符(selector)“查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 示例： 1234$(this).hide() &lt;!-- 隐藏当前元素 --&gt;$(\"p\").hide() &lt;!-- 隐藏所有 &lt;p&gt; 元素 --&gt;$(\"p.test\").hide() &lt;!-- 隐藏所有 class=\"test\" 的 &lt;p&gt; 元素 --&gt;$(\"#test\").hide() &lt;!-- 隐藏 id=\"test\" 的元素 --&gt; 快速入门12&lt;div id=\"div1\"&gt;My name is div1.&lt;/div&gt;&lt;div id=\"div2\"&gt;My name is div2.&lt;/div&gt; 获取名称叫div的所有html元素 12345678&lt;script&gt; var jsGetDiv = document.getElementsByTagName(\"div\"); // [object HTMLCollection] var jqGetDiv = $(\"div\"); // [object Object] alert(jsGetDiv); alert(jqGetDiv); alert(jsGetDiv.length); // 集合长度 alert(jqGetDiv.length); // 集合长度&lt;/script&gt; 对 jsGetDiv 中的所有 div 标签体内容修改为 XXX 123for (var i = 0; i &lt; jsGetDiv.length; i ++) { jsGetDiv[i] = \"div\"+ (i + 1) + \" was replaced!\";} 对 jqGetDiv 中的所有 div 标签体内容修改为 XXX 1jqGetDiv.html(\"The Div element has been replaced!\"); 从上面的内容可以看出，jQuery 对象在操作时更加方便，jQuery 对象和 JavaScript 对象的方法是不通用的。下面进行 jQuery 对象和 JavaScript 对象之间的转换： JavaScript 对象转换为 jQuery 对象：$(js对象) 123for (var i = 0; i &lt; jsGetDiv.length; i ++) { $(jsGetDiv[i]).html(\"The Div element has been replaced!\");} jQuery 对象转换为 JavaScript 对象 12jqGetDiv[0].innerHTML = \"div0 was replaced!\";jqGetDiv.get(1).innerHTML = \"div1 was replaced!\"; 代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JavaScript 对象与 JQuery 对象直接的转换&lt;/title&gt; &lt;script src=\"../js/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;My name is div1.&lt;/div&gt; &lt;div id=\"div2\"&gt;My name is div2.&lt;/div&gt; &lt;script&gt; var jsGetDiv = document.getElementsByTagName(\"div\"); // [object HTMLCollection] var jqGetDiv = $(\"div\"); // [object Object] alert(jsGetDiv); alert(jqGetDiv); alert(jsGetDiv.length); alert(jqGetDiv.length); // 对 jsGetDiv 中的所有 div 标签体内容修改为 XXX for (var i = 0; i &lt; jsGetDiv.length; i ++) { jsGetDiv[i] = \"div\"+ (i + 1) + \" was replaced!\"; } // 对 jqGetDiv 中的所有 div 标签体内容修改为 XXX jqGetDiv.html(\"The Div element has been replaced!\"); // JavaScript 对象转换为 jQuery 对象：$(js对象) for (var i = 0; i &lt; jsGetDiv.length; i ++) { $(jsGetDiv[i]).html(\"The Div element has been replaced!\"); } // jQuery 对象转换为 JavaScript 对象： jqGetDiv[0].innerHTML = \"div0 was replaced!\"; jqGetDiv.get(1).innerHTML = \"div1 was replaced!\"; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery 选择器jQuery 选择器允许我们对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。jQuery 中所有选择器都以美元符号开头：$()。 常用的选择器基本选择器 名称 语法 描述 标签选择器（元素选择器） $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 id选择器 $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 类选择器 $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 并集选择器 $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 层级选择器 名称 语法 描述 后代选择器 $(&quot;A B &quot;) 选择A元素内部的所有B元素 子选择器 $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 &lt;br/ &gt; 属性选择器 名称 语法 描述 属性名称选择器 $(&quot;A[属性名]&quot;) 包含指定属性的选择器 属性选择器 $(&quot;A[属性名='值']&quot;) 包含指定属性等于指定值的选择器 复合属性选择器 $(&quot;A[属性名='值'][]...&quot;) 包含多个属性条件的选择器 过滤选择器 名称 语法 描述 首元素选择器 :first 获得选择的元素中的第一个元素 尾元素选择器 :last 获得选择的元素中的最后一个元素 非元素选择器 :not(selector) 不包括指定内容的元素 偶数选择器 :even 偶数，从 0 开始计数 奇数选择器 :odd 奇数，从 0 开始计数 等于索引选择器 :eq(index) 指定索引元素 大于索引选择器 :gt(index) 大于指定索引元素 小于索引选择器 :gt(index) 小于指定索引元素 标题选择器 :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 名称 语法 描述 可用元素选择器 :enabled 获得可用元素 不可用元素选择器 :disabled 获得不可用元素 选中选择器 :checked 获得单选/复选框选中的元素 选中选择器 :selected 获得下拉框选中的元素 事件绑定 使用 jQuery 对象中的click方法，给 button1 绑定单击事件（需要在按钮之后进行事件绑定） 1234567&lt;input type=\"button\" value=\"测试按钮\" id=\"button1\"&gt;&lt;script&gt; $(\"button1\").click(function() { alert(\"欢迎点击！\"); });&lt;/script&gt; 自定义JavaScript单击事件方法，给 button1 绑定单击事件（需要在按钮之后进行事件绑定） 12345678&lt;input type=\"button\" value=\"测试按钮\" id=\"button1\"&gt;&lt;script&gt; var button1 = document.getElementById(\"button1\"); button1.onclick = function(){ alert(\"欢迎点击！\"); };&lt;/script&gt; 也可以在input按钮之前编写绑定单击事件代码，但是需要在按钮加载完成之后。 12345678910111213&lt;head&gt; &lt;!-- ......... --&gt; &lt;script&gt; window.onload = function() { $(\"button1\").click(function () { alert(\"欢迎点击！\"); }); }; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"测试按钮\" id=\"button1\"&gt;&lt;/body&gt; 1234567891011121314&lt;head&gt; &lt;!-- ......... --&gt; &lt;script&gt; // dom 文档加载完成之后才会执行 jQuery 入口函数中的代码 $(function () { $(\"button1\").click(function () { alert(\"欢迎点击！\"); }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"测试按钮\" id=\"button1\"&gt;&lt;/body&gt; 说明：window.onload 只能定义一次，如果定义多次，后面定义的，会把前面定义的覆盖掉。$(function () 能定义多次。 样式控制 设置 &lt;p&gt; 元素的颜色 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Jquery 样式控制&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"/jquery/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() { $(\"button\").click(function() { $(\"p\").css(\"color\",\"red\"); }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;button type=\"button\"&gt;改变段落的颜色&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 点击按钮前后变化： 参考文献 jQuery 教程 | 菜鸟教程 jQuery CSS 操作 - css() 方法","link":"/p/381711202007/"},{"title":"JDBC 常用类/接口详解（MySQL为例）","text":"@Author: YiHua Lee @Address: Guangdong province, China DriverManager类java.sql.DriverManager 是用于管理一组JDBC驱动程序的基本服务。 1注意： JDBC 2.0 API中新增的DataSource接口提供了另一种连接到数据源的方法。 使用DataSource对象是连接到数据源的首选方法。 DriverManager类功能注册驱动告诉程序该使用什么数据库驱动jar 可以直接使用DriverManager类的静态方法注册驱动： 12static void registerDriver(Driver driver)// 注册与给定的驱动程序 DriverManager 。 也可以间接使用该方法，如下介绍直接和间接调用DriverManager类的静态方法注册驱动。 如我们要连接操作的是MySQL，那么我们就要注册驱动，告诉程序要使用MySQL驱动架包。如下就是注册MySQL数据库驱动： 注册驱动第一种方法： 12Class&lt;?&gt; aClass = Class.forName(\"com.mysql.jdbc.Driver\");// 将字节码文件Driver.java加载进内存，返回Driver.class对象。 注册驱动第二种方法： 12com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();DriverManager.registerDriver(driver); com.mysql.jdbc.Driver类中存在静态代码块，如下： 1234567static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\"); }} 这里可以看出来，两种驱动方法其实都是一样的，都要用到静态方法registerDriver() 1备注：MySQL 5 之后的驱动jar包可以省略注册驱动的步骤。 获取数据库连接方法 1static Connection getConnection(String url, String user, String password) 方法说明 123456789101112这是java.sql.DriverManager类的静态方法，用来获取数据库连接。该方法的返回值是Connection对象。参数说明：url：指定连接的路径user：用户名password：密码 连接的是MySQL数据库时，参数url格式举例说明语法：jdbc:mysql://ip地址(域名):端口号/数据库名称例子：jdbc:mysql://localhost:3306/Study细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 Connection接口java.sql.Connection接口是一个数据库连接对象。它与特定数据库的连接（会话）。 执行SQL语句并在连接的上下文中返回结果。 Connection接口功能获取执行SQL的对象方法： 1234Statement createStatement()// 创建一个 Statement对象，用于将SQL语句发送到数据库。PreparedStatement prepareStatement(String sql)// 创建一个 PreparedStatement对象，用于将参数化的SQL语句发送到数据库。 管理事务方法： 开启事务 12void setAutoCommit(boolean autoCommit)// 将此连接的自动提交模式设置为给定状态。参数为false，即开启事务 提交事务 12void commit()// 使自上次提交/回滚以来所做的所有更改都将永久性，并释放此 Connection对象当前持有的任何数据库锁。 回滚事务 12void rollback()// 撤消在当前事务中所做的所有更改，并释放此 Connection对象当前持有的任何数据库锁。 Statement接口java.sql.Statement接口，用于执行静态SQL语句并返回其生成的结果的对象。 默认情况下，每个Statement对象只能有一个ResultSet对象同时打开。 因此，如果一个ResultSet对象的读取与另一个对象的读取交错，则ResultSet对象必须由不同的Statement对象生成。 在所有执行方法Statement接口隐式关闭当前ResultSet声明的对象，如果一个开放的存在。 Statement接口功能执行静态SQL语句方法： 1234567boolean execute(String sql)// 执行给定的SQL语句，这可能会返回多个结果。该方法可以执行任意的SQL语句。int executeUpdate(String sql)// 执行给定的SQL语句。执行的是DML（insert、update、delete）语句、DDL(create，alter、drop)语句// 返回值是一个int类型的数 ———— 执行的SQL语句影响的行数ResultSet executeQuery(String sql)// 执行给定的SQL语句，该语句返回单个ResultSet对象。执行DQL（select)语句 举例 连接Study数据库，向account表中的id=1的balance字段值加上500。表数据如下： Java代码实现： 12345678910111213141516171819202122232425262728293031323334353637import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JdbcDemo01 { public static void main(String[] args) throws ClassNotFoundException, SQLException { // 1、导入jar包：mysql-connector-java-5.1.48.jar // Add as Library ... // 2、注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 3、获取数据库连接对象 Connection connection = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/Study?useSSL=false\", \"用户名\", \"密码\"); // 4、定义SQL语句 // 将account表中的id=1的balance字段值加上500 String sql = \"UPDATE account Set balance = balance + 500 WHERE id = 1;\"; // 5、获取执行sql的对象 Statement Statement statement = connection.createStatement(); // 6、执行SQL语句：执行成功，返回 1 int returnResult = statement.executeUpdate(sql); // 7、查看是否执行成功 System.out.println(returnResult); // 8、释放资源 statement.close(); connection.close(); }} 执行成功，控制台输出：1，说明影响的行数是一行。 查看表中现在的数据： ResultSet接口表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。即该接口是结果集对象，用来封装查询结果。 ResultSet对象保持一个光标指向其当前的数据行。 最初，光标位于第一行之前。 next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false ，因此可以在while循环中使用循环来遍历结果集。 下面介绍几个具代表性的方法 ResultSet接口功能游标向下移动一行12boolean next()// 将光标从当前位置向前移动一行。 获取数据getXxx(参数列表) 方法 12345678910String getString(int columnIndex)// 这个检索的当前行中指定列的值 ResultSet对象为 String的Java编程语言。// int columnIndex：列的索引，索引从1开始，1对应第一列String getString(String columnLabel)// 这个检索的当前行中指定列的值 ResultSet对象为 String的Java编程语言。// String columnLabel：指定的列名称int getInt(int columnIndex)// 这个检索的当前行中指定列的值 ResultSet作为对象 int在Java编程语言。// int columnIndex：列的索引 举例题目：查看account表中的记录，account表位于本地mysql的Study数据库下，端口号为3306 account表 1234567account表如下：CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(10), -- 名字 balance DOUBLE -- 余额);INSERT INTO account (NAME, balance) VALUES ('LeeHua', 1500), ('Tom', 1000); Java程序实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.ResultSet;public class JdbcDemo03 { public static void main(String[] args) { Statement statement = null; Connection connection = null; ResultSet resultSet = null; try { // 1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 2. 定义SQL语句 String sql = \"SELECT * FROM account;\"; // 3.获取Connection对象 connection = DriverManager.getConnection( \"jdbc:mysql:///Study?useSSL=false\", \"LeeHua\", \"qq562246926\" ); // 4.获取执行sql的对象 Statement statement = connection.createStatement(); // 5.执行sql，返回查询结果（一个表），用ResultSet对象来封装。 resultSet = statement.executeQuery(sql); // 6.处理结果 // 6.1 循环判断游标是否是最后一行末尾。 while(resultSet.next()){ // 获取数据 // 6.2 获取数据 // 获取 ID 字段的值 int id = resultSet.getInt(1); // 获取name字段的值 String name = resultSet.getString(\"name\"); // 获取balance字段的值 double balance = resultSet.getDouble(3); // 输出 System.out.println(id + \" --- \" + name + \" --- \" + balance); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { // 7. 释放资源 releaseResources(resultSet); releaseResources(statement); releaseResources(connection); } } public static &lt;T&gt; void releaseResources (T t){ if(t != null){ try { // 利用反射，获取class对象 Class&lt;?&gt; aClass = t.getClass(); // 获取class对象中的方法对象 Method close = aClass.getMethod(\"close\"); // 执行方法 close.invoke(t); } catch (Exception e) { e.printStackTrace(); } } }} PreparedStatement接口PreparedStatement接口 extends Statement接口，表示预编译的SQL语句的对象。SQL语句已预编译并存储在PreparedStatement对象中。 然后可以使用该对象多次有效地执行此语句。 预编译的SQL：参数使用?作为占位符 如： 123new Statement.executeQuery(sql1);new PreparedStatement.executeQuery(sql2); 两个对象都执行SQL语句，Statement接口是执行静态SQL的，即已经拼接好的SQL，而PreparedStatement接口是执行预编译的SQL语句的。 如： 123sql1 = \"SELECT * FROM account WHERE id = ID AND balance = 账户余额;\"sql2 = \"SELECT * FROM account WHERE id = ? AND balance = ?;\" sql1是静态的SQL语句，sql2是预编译SQL语句。 PreparedStatement接口的用法和其父接口Statement的用法差不多，只是父接口是执行静态SQL语句的，而PreparedStatement接口是传入并执行预编译的SQL语句的。 给?赋值方法： setXxx(参数1,参数2) 参数说明： 12参数1：？的位置编号 从1 开始参数2：？的值 如： 1234void setInt(int parameterIndex, int x)// 将指定的参数设置为给定的Java int值。void setString(int parameterIndex, String x)// 将指定的参数设置为给定的Java String值。 举例需求：获取数据库中字段的记录，对比用户输入，模拟登陆。 实现自定义一个注解，用于获取部分值： 1234567891011121314151617181920212223package my.view.util;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE) // 注解能作用于类上@Retention(RetentionPolicy.RUNTIME) // 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到public @interface PropertiesAnnotation { /* URL */ public abstract String url(); /* 用户 */ public abstract String user(); /* 密码 */ public abstract String password(); /* 驱动包 */ public abstract String driver();} 创建一个MySQL表格： 12345CREATE TABLE login ( id INT PRIMARY KEY AUTO_INCREMENT, -- id user VARCHAR(30), -- 用户名 password VARCHAR(30) -- 密码); 向表格中传入数据： 1INSERT INTO login (user, password) VALUES ('LeeHua', '123456'), ('Tom', 'abcdef'); 创建一个Jdbc工具类，用来注册驱动和获取连接对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;@PropertiesAnnotation( url = \"jdbc:mysql:///Study\", user = \"mysql账号\", password = \"mysql密码\", driver = \"com.mysql.jdbc.Driver\")public class JdbcUtils02 { private static String url; private static String user; private static String password; private static String driver; /* 文件的读取，只需要读取一次即可拿到这些值。利用反射和注解、使用静态代码块 */ static{ // 读取资源文件，获取值。 try { // 1. 解析注解 // 1.1 获取JdbcUtils02类的字节码文件对象 Class&lt;JdbcUtils02&gt; jdbcUtils02Class = JdbcUtils02.class; // 2. 获取上边的注解对象 PropertiesAnnotation annotation = jdbcUtils02Class.getAnnotation(PropertiesAnnotation.class); // 3. 调用注解中定义的抽象方法，获取返回值，赋值给静态成员变量 url = annotation.url(); user = annotation.user(); password = annotation.password(); driver = annotation.driver(); // 4. 注册驱动 Class.forName(driver); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); }} View Code 使用Statement接口，创建一个登录类： 1234567891011121314151617181920212223public boolean login(String user, String password) { if (user == null || password == null) { return false; } Connection connection =null; Statement statement = null; ResultSet resultSet = null; try { // 获取数据库连接 connection = JdbcUtils02.getConnection(); // 定义SQL String sql = \"SELECT * FROM login WHERE user = '\" + user + \"' AND password = '\" + password + \"';\"; // 获取执行SQL对象 statement = connection.createStatement(); // 执行查询 resultSet = statement.executeQuery(sql); // 判断是否存在下一行数据 return resultSet.next(); } catch (SQLException e) { e.printStackTrace(); } return false;} 使用PreparedStatement接口，创建一个登录类： 1234567891011121314151617181920212223242526public boolean login(String user, String password) { if (user == null || password == null) { return false; } Connection connection =null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try { // 获取数据库连接 connection = JdbcUtils02.getConnection(); // 定义SQL String sql = \"SELECT * FROM login WHERE user = ? AND password = ?;\"; // 获取执行SQL语句对象 preparedStatement = connection.prepareStatement(sql); // 给?赋值 preparedStatement.setString(1, user); preparedStatement.setString(2, password); // 执行SQL语句 resultSet = preparedStatement.executeQuery(); // 判断是否存在下一行数据 return resultSet.next(); } catch (SQLException e) { e.printStackTrace(); } return false;} 模拟测试：登录方法在Demo类中。 12345678910111213141516171819202122public class Demo { public static void main(String[] args) { // 键盘录入，接收用户名和密码 Scanner scn = new Scanner(System.in); System.out.print(\"请输入用户名：\"); String userName = scn.nextLine(); System.out.print(\"请输入密码：\"); String password = scn.nextLine(); // 调用登录确认方法 Demo demo08 = new Demo(); if (demo.login(userName, password)) { System.out.println(\"登录成功！\"); } else { System.out.println(\"登录失败！用户名或密码额错误。\"); } }} 调用使用Statement接口创建的登录方法测试： 如果正常情况下输入，那么该方法判断用户账号密码是否正确是有效的。如果输入恒等式，那么该方法就失效了，无论输入什么恒等式，都可以登录，举例如： 12请输入用户名：LeeHua请输入密码：abc' OR 'abc' = 'abc 那么这个时候，被拼接好的SQL语句就如下： 1SELECT * FROM login WHERE user = 'LeeHua' AND password = 'abc' OR 'abc' = 'abc'; 这是一条恒等式，不论 password是否正确，都可以登录成功，这是相当危险的，就像别人能够随随便便登录个人微信一样，安全隐患很大，所以我们使用预编译的SQL语句，不使用静态SQL语句。 1运行，控制台输出：登录成功! 调用使用PreparedStatement接口创建的登录方法测试： 这个时候无论输入什么，都会判断正确，因为这里传入的是一条预编译的SQL语句，并不是拼接的SQL语句。 举例如： 12请输入用户名：LeeHua请输入密码：abc' OR 'abc' = 'abc 那么这个时候实质传入的SQL语句是： 12SELECT * FROM login WHERE user = 'LeeHua' AND password = 'abc' OR 'abc' = 'abc';运行，控制台输出：登录失败！用户名或密码额错误。 所以，判断用户名和密码是准确的。","link":"/p/061506202005/"},{"title":"JDBC 控制事务（MySQL为例）","text":"@Author: YiHua Lee @Address: Guangdong province, China 事务一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 对事务的操作 开启事务 提交事务 回滚事务 使用Connection对象来管理事务java.sql.Connection接口是一个数据库连接对象。它与特定数据库的连接（会话）。 执行SQL语句并在连接的上下文中返回结果。 开启事务 12setAutoCommit(boolean autoCommit)// 调用该方法设置参数为false，即开启事务 提交事务 12commit()// 当所有sql都执行完提交事务 回滚事务 12rollback()// 在catch中回滚事务 Java代码举例有如下一个MySQL数据表，利用Java程序：把id = 1对应的余额减少500，id = 2对应的余额增加500 1234567CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(10), -- 名字 balance DOUBLE -- 余额);INSERT INTO account (NAME, balance) VALUES ('LeeHua', 1000), ('Tom', 1000); 自定义一个注解，获取连接数据库的信息： 1234567891011121314151617181920212223package my.view.util;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE) // 注解能作用于类上@Retention(RetentionPolicy.RUNTIME) // 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到public @interface PropertiesAnnotation { /* URL */ public abstract String url(); /* 用户 */ public abstract String user(); /* 密码 */ public abstract String password(); /* 驱动包 */ public abstract String driver();} 定义一个工具类，用来注册驱动和获取数据库连接对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;@PropertiesAnnotation( url = \"jdbc:mysql:///Study\", user = \"账号\", password = \"密码\", driver = \"com.mysql.jdbc.Driver\")public class JdbcUtils02 { private static String url; private static String user; private static String password; private static String driver; /* 文件的读取，只需要读取一次即可拿到这些值。利用反射和注解、使用静态代码块 */ static{ // 读取资源文件，获取值。 try { // 1. 解析注解 // 1.1 获取JdbcUtils02类的字节码文件对象 Class&lt;JdbcUtils02&gt; jdbcUtils02Class = JdbcUtils02.class; // 2. 获取上边的注解对象 PropertiesAnnotation annotation = jdbcUtils02Class.getAnnotation(PropertiesAnnotation.class); // 3. 调用注解中定义的抽象方法，获取返回值，赋值给静态成员变量 url = annotation.url(); user = annotation.user(); password = annotation.password(); driver = annotation.driver(); // 4. 注册驱动 Class.forName(driver); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); }} 有了以上条件，对数据表进行操作： 获取数据库连接 1Connection connection = JdbcUtils02.getConnection(); 获取到数据库连接对象后，开启事务 1connection.setAutoCommit(false); 开启事务实际上是创建一个日志文件，将定义的SQL语句的执行结果暂时放到日记中，如果没有错，提交事务，如果出错，那么就回滚事务。接下来定义动态SQL语句 123String sql1 = \"update account set balance = balance - ? where id = ?\";String sql2 = \"update account set balance = balance + ? where id = ?\"; 定义好了SQL语句，接下来就要获取执行动态SQL语句的对象 123PreparedStatement preparedStatement1 = connection.prepareStatement(sql1);PreparedStatement preparedStatement2 = connection.prepareStatement(sql2); 给动态SQL语句传入参数 1234567// LeeHua 的账户余额减少500元preparedStatement1.setDouble(1,500);preparedStatement1.setInt(2,1);// Tom 的账户余额增加500元preparedStatement2.setDouble(1,500);preparedStatement2.setInt(2,2); 一切准备就绪，这时候就可以执行SQL语句了 123preparedStatement1.executeUpdate();preparedStatement2.executeUpdate(); 执行SQL语句后，如果没有错误，那么就提交事务，这时候的表记录就会更改 1connection.commit(); 执行SQL语句后，如果有错误，那么就回滚事务，这个时候，会把日记中的记录删除，不会提交到表中，表的记录不会更改 1connection.rollback(); 无论执行SQL语句，是否存在错误，最后都需要释放资源，调用自定义releaseResources()方法，释放资源 123releaseResources(preparedStatement2);releaseResources(preparedStatement1);releaseResources(connection); releaseResources()方法的定义如下： 12345678910111213141516171819/** * 释放资源 * @param t 要被释放的资源 * @param &lt;T&gt; 要被释放的资源对象的类型 */public static &lt;T&gt; void releaseResources (T t){ if(t != null){ try { // 利用反射，获取class对象 Class&lt;?&gt; aClass = t.getClass(); // 获取class对象中的方法对象 Method close = aClass.getMethod(\"close\"); // 执行方法 close.invoke(t); } catch (Exception e) { e.printStackTrace(); } }} 对数据表进行操作的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package my.view.jdbc;import my.view.util.JdbcUtils02;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class JdbcDemo09 { public static void main(String[] args) { Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try { // 1. 获取连接 connection = JdbcUtils02.getConnection(); // 开启事务 connection.setAutoCommit(false); // 2. 定义sql // 2.1 定义减少账户余额的SQL语句 String sql1 = \"update account set balance = balance - ? where id = ?\"; // 2.2 定义增加账户余额的SQL语句 String sql2 = \"update account set balance = balance + ? where id = ?\"; // 3.获取执行SQL语句的对象 preparedStatement1 = connection.prepareStatement(sql1); preparedStatement2 = connection.prepareStatement(sql2); // 4. 设置参数 // 4.1 LeeHua 的账户余额减少500元 preparedStatement1.setDouble(1,500); preparedStatement1.setInt(2,1); // 4.2 Tom 的账户余额增加500元 preparedStatement2.setDouble(1,500); preparedStatement2.setInt(2,2); // 5. 执行SQL语句 preparedStatement1.executeUpdate(); preparedStatement2.executeUpdate(); // 6. 提交事务 connection.commit(); } catch (Exception e) { // 7. 事务回滚 try { if(connection != null) { connection.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } } finally { // 8. 释放资源 releaseResources(preparedStatement2); releaseResources(preparedStatement1); releaseResources(connection); } } /** * 释放资源 * @param t 要被释放的资源 * @param &lt;T&gt; 要被释放的资源对象的类型 */ public static &lt;T&gt; void releaseResources (T t){ if(t != null){ try { // 利用反射，获取class对象 Class&lt;?&gt; aClass = t.getClass(); // 获取class对象中的方法对象 Method close = aClass.getMethod(\"close\"); // 执行方法 close.invoke(t); } catch (Exception e) { e.printStackTrace(); } } }} 运行程序，查看表中的记录，发现LeeHua的账号余额减少了500，Tom的账户余额增加了500。","link":"/p/131506202005/"},{"title":"ES6 学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China ES6 语法指南什么是 ES6ES6：就是ECMAScript第6版标准。 前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 ES5和6的一些新特性var 命令之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如有这样一段代码： 12345678&lt;body&gt; &lt;script&gt; for (var i = 0; i &lt; 5; i++) { console.log(\"for循环《内》部：\" + i) } console.log(\"for循环（外）部：\" + i); &lt;/script&gt;&lt;/body&gt; 其打印结果是： 为什么会出现这样的情况呢？变量 i 不是在for循环的内部吗？其实 var 定义的变量有时会莫名奇妙的成为全局变量。 let 命令let所声明的变量，只在let命令所在的代码块内有效。 把上例中的 var 改为 let，查看一下效果： 12345678&lt;body&gt; &lt;script&gt; for (let i = 0; i &lt; 5; i++) { console.log(\"for循环《内》部：\" + i) } console.log(\"for循环（外）部：\" + i); &lt;/script&gt;&lt;/body&gt; 结果： const 命令const声明的变量是常量，不能被修改 常量指的是无法在程序正常运行过程中进行修改的值。一方面无法通过重新赋值进行修改，另外一方面也无法进行重新声明。在 JavaScript 中，常量通过关键字 const 来声明。 举例： 12345678&lt;body&gt; &lt;script&gt; const number = 99; console.log(number) number++; console.log(number) &lt;/script&gt;&lt;/body&gt; 结果： 解构表达式 数组解构 例子1： 1234567891011&lt;body&gt; &lt;script&gt; let array1 = [111, 222, 333] let [x1] = array1; let [x2, y2] = array1; let [x3, y3, z3] = array1; console.log(\"x1=\" + x1) console.log(\"x2=\" + x2 + \" y2=\" + y2) console.log(\"x3=\" + x3 + \" y3=\" + y3 + \" z3=\" + z3) &lt;/script&gt;&lt;/body&gt; 输出结果1：x，y，z将与array中的每个位置对应来取值 例子2: 1234567891011&lt;body&gt; &lt;script&gt; let array2 = [100, 200, 300] let [a1, ,] = array2 let [, b2,] = array2 let [, , c3] = array2 console.log(\"a1=\" + a1) console.log(\"b2=\" + b2) console.log(\"c3=\" + c3) &lt;/script&gt;&lt;/body&gt; 输出结果：a，b，c将与arr中的每个位置对应来取值 对象解构 例子： 1234567891011&lt;body&gt; &lt;script&gt; const person = { name:\"Java\", age:21, language: ['Map','Reduce','Spark'] } // 解构表达式获取值 const {name,age,language} = person; &lt;/script&gt;&lt;/body&gt; 结果： 我们还可以从 language 数组中获取每一个值： 1let [a, b, c] = language; 结果： 如过想要用其它变量接收，需要额外指定别名： {name: targetName}：name是person中的属性名，冒号后面的 targetName 是解构后要赋值给的变量。 字符串扩展ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本。 函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) { // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;}// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) { return a + b;}// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数： 12345var print = function (obj) { console.log(obj);}// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) { return a + b;}// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; { return a + b;} 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = { name: \"jack\", // 以前： eat: function (food) { console.log(this.name + \"在吃\" + food); }, // 箭头函数版： eat2: food =&gt; console.log(person.name + \"在吃\" + food),// 这里拿不到this // 简写版： eat3(food){ console.log(this.name + \"在吃\" + food); }} 箭头函数结合解构表达式 比如有一个函数： 123456789const person = { name:\"jack\", age:21, language: ['java','js','css']}function hello(person) { console.log(\"hello,\" + person.name)} 使用箭头函数： 123function hello(person) =&gt; console.log(\"hello,\" + person.name)// 调用 hellohello(person); 使用解构表达式： 12345function hello({name}) { console.log(\"hello,\" + name)}// 调用 hellohello(person); 如果用箭头函数和解构表达式 123var hello = ({name}) =&gt; console.log(\"hello,\" + name);// 调用 hellohello(person); map和reduce数组中新增了map和reduce方法。 map方法 map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 12345let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) 实践结果： reduce方法 reduce()：接收一个函数（函数必须添加）和一个初始值（初始值可添加，也可以不添加），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 12const arr = [1,20,-5,3];sum = (a, b) =&gt; a+b; 没添加初始值： 1arr.reduce(sum); 指定初始值： 1arr.reduce(sum, 100); promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) { // ... 执行异步操作 if (/* 异步操作成功 */){ resolve(value);// 调用resolve，代表Promise将返回成功的结果 } else { reject(error);// 调用reject，代表Promise会返回失败结果 }}); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value){ // 异步执行成功后的回调}); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value){ // 异步执行成功后的回调}).catch(function(error){ // 异步执行失败后的回调}) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) { // 这里我们用定时任务模拟异步 setTimeout(() =&gt; { const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) { resolve(\"成功！num:\" + num) } else { reject(\"出错了！num:\" + num) } }, 300)})// 调用promisep.then(function (msg) { console.log(msg);}).catch(function (msg) { console.log(msg);}) 结果： set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 模块化什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = { sum(a,b){ return a + b; }} 我可以使用export将这个对象导出： 123456const util = { sum(a,b){ return a + b; }}export util; 当然，也可以简写为： 12345export const util = { sum(a,b){ return a + b; }} export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = \"jack\"var age = 21export {name,age} 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default { sum(a,b){ return a + b; }} 这样，当使用者导入时，可以任意起名字 import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import {name, age} from 'user.js'console.log(name + \" , 今年\"+ age +\"岁了\") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。 参考文献 黑马 Java","link":"/p/262322202008/"},{"title":"JQuery 版本说明","text":"@Author: YiHua Lee @Address: Guangdong province, China 目前jQuery有三个大版本： 1.x 版本 兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日) 2.x 版本 不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日) 3.x 版本 不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.5.1（2020年06月29日）","link":"/p/491129202006/"},{"title":"JSP 表达式语言1","text":"@Author: YiHua Lee @Address: Guangdong province, China JSP表达式语言（EL –&gt; Expression Language）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。 实例引入 典型的，当您需要在JSP标签中指定一个属性值时，只需要简单地使用字符串即可： 1&lt;jsp:setProperty name=\"box\" property=\"perimeter\" value=\"100\"/&gt; JSP EL允许您指定一个表达式来表示属性值。一个简单的表达式语法如下： 1${expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。 举例来说，上面的&lt;jsp:setProperty&gt;标签可以使用表达式语言改写成如下形式： 12&lt;jsp:setProperty name=\"box\" property=\"perimeter\" value=\"${2*box.width+2*box.height}\"/&gt; 当JSP编译器在属性中见到”${}”格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。 也可以在标签的模板文本中使用表达式语言。比如&lt;jsp:text&gt;标签简单地将其主体中的文本插入到JSP输出中： 123&lt;jsp:text&gt;&lt;h1&gt;Hello JSP!&lt;/h1&gt;&lt;/jsp:text&gt; 现在，在&lt;jsp:text&gt;标签主体中使用表达式，就像这样： 123&lt;jsp:text&gt;Box Perimeter is: ${2*box.width + 2*box.height}&lt;/jsp:text&gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true： 1&lt;%@ page isELIgnored =\"false\" %&gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。也可以忽略当前EL表达式： 1\\${表达式} EL中的基础操作符EL表达式支持大部分Java所提供的算术和逻辑操作符： 操作符 描述 . 访问一个Bean属性或者一个映射条目 [] 访问一个数组或者链表的元素 ( ) 组织一个子表达式以改变优先级 + 加 - 减或负 * 乘 / or div 除 % or mod 取模 == or eq 测试是否相等 != or ne 测试是否不等 &lt; or lt 测试是否小于 &gt; or gt 测试是否大于 &lt;= or le 测试是否小于等于 &gt;= or ge 测试是否大于等于 &amp;&amp; or and 测试逻辑与 || or or 测试逻辑或 ! or not 测试取反 empty 测试是否空值 JSP EL中的函数 JSP EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下： 1${ns:func(param1, param2, ...)} ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。 比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度： 1${fn:length(\"Get my length\")} 如果要使用任何标签库中的函数，需要将这些库安装在服务器中，然后使用&lt;taglib&gt;标签在JSP文件中包含这些库。 JSP EL隐含对象JSP EL支持下表列出的隐含对象： 隐含对象 描述 pageScope page 作用域 requestScope request 作用域 sessionScope session 作用域 applicationScope application 作用域 param Request 对象的参数，字符串 paramValues Request对象的参数，字符串集合 header HTTP 信息头，字符串 headerValues HTTP 信息头，字符串集合 initParam 上下文初始化参数 cookie Cookie值 pageContext 当前页面的pageContext 参考文献 JSP 表达式语言| 菜鸟教程","link":"/p/192206202006/"},{"title":"Java Calendar类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China Calendar类概述 java.util.Calendar类:是一个日历类 Calendar类是一个抽象类,里边提供了很多操作日历字段的方法。 如：YEAR、 MONTH、 DAY OF MONTH、HOUR Calendar类无法直接创建对象使用,里边有一个静态方法叫 getInstance()，getInstance()方法返回了 Calendar类的子类对象。static Calendar getInstance()使用默认时区和语言环境获得一个日历。 Calender获取对象的方式使用静态方法：Calendar.getInstance() 12345678import java.util.Calendar;public class Demo01Calendar { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); System.out.println(calendar); }} Calender类的常用成员方法1234567891011public int get(int field)// 返回给定日历字段的值public void set(int field, int value)// 将给定的日历字段设置为给定值。public abstract void add(int field, int amount)// 根据日历的规则,为给定的日历字段添加或减去指定的时间量。public Date getTime()// 返回一个表示此 Calendar时间值(从历元到现在的亳秒偏移量)的Date对象。 123456789成员方法的参数: int field:日历类的字段,可以使用 Calendar类的静态成员变量获取 public static final int YEAR = 1 年 public static final int MONTH = 2 月 public static final int DATE=5 一个月中的某一天 public static final int DAY_OF_ MONTH=5 一个月中的某一天 public static final int HOUR =10 时 public static final int MINUTE =12 分 public static final int SECOND =13 秒 Calendar 类的简单使用get() 方法返回给定日历字段的值 12345678910111213141516171819import java.util.Calendar;public class DemoCalendarGet { public static void main(String[] args) { // 首先使用getInstance()方法获取calendar对象 Calendar calendar = Calendar.getInstance(); // 调用get方法获取给定日历字段的值 System.out.println( \"年：\" + calendar.get(Calendar.YEAR) + \"\\n\" + \"月：\" + calendar.get(Calendar.MONTH) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DATE) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DAY_OF_MONTH) + \"\\n\" + \"时：\" + calendar.get(Calendar.HOUR) + \"\\n\" + \"分：\" + calendar.get(Calendar.MINUTE) + \"\\n\" + \"秒：\" + calendar.get(Calendar.SECOND) ); }} 12345678输出：年：2020月：0一个月中的某一天：11一个月中的某一天年：11时：8分：37秒：31 1234说明：当时日期、时间：2020年1月11日8时37分31秒西方的月份：0-11东方的月份：1-12 set() 方法：将给定的日历字段设置为给定值 123456789101112131415161718192021222324252627282930313233343536import java.util.Calendar;public class DemoCalendarSet { public static void main(String[] args) { // 首先使用getInstance()方法获取calendar对象 Calendar calendar = Calendar.getInstance(); System.out.println(\"\\n设置前\"); System.out.println( \"年：\" + calendar.get(Calendar.YEAR) + \"\\n\" + \"月：\" + calendar.get(Calendar.MONTH) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DAY_OF_MONTH) ); // 将年设置为 2008 calendar.set(Calendar.YEAR, 2008); // 将月设置为 10 calendar.set(Calendar.MONTH, 10); // 将日期设置为 3 calendar.set(Calendar.DAY_OF_MONTH, 3); System.out.println(\"\\n分别设置后\"); System.out.println( \"年：\" + calendar.get(Calendar.YEAR) + \"\\n\" + \"月：\" + calendar.get(Calendar.MONTH) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DAY_OF_MONTH) ); // 同时设置年月日 calendar.set(1998, Calendar.SEPTEMBER, 25); System.out.println(\"\\n同时设置后\"); System.out.println( \"年：\" + calendar.get(Calendar.YEAR) + \"\\n\" + \"月：\" + calendar.get(Calendar.MONTH) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DAY_OF_MONTH) ); }} 12345678910111213141516输出结果：设置前年：2020月：0一个月中的某一天：11分别设置后年：2008月：10一个月中的某一天：3同时设置后年：1998月：8一个月中的某一天：25 add() 方法根据日历的规则,为给定的日历字段添加或减去指定的时间量。 123456789101112131415161718192021222324252627import java.util.Calendar;public class DemoCalendarAdd { public static void main(String[] args) { // 首先使用getInstance()方法获取calendar对象 Calendar calendar = Calendar.getInstance(); System.out.println(\"\\n变化前\"); System.out.println( \"年：\" + calendar.get(Calendar.YEAR) + \"\\n\" + \"月：\" + calendar.get(Calendar.MONTH) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DAY_OF_MONTH) ); // 把年减少两年 calendar.add(Calendar.YEAR, -2); // 把月份增加三个月 calendar.add(Calendar.MONTH, 3); // 把日期增加10天 calendar.add(Calendar.DAY_OF_MONTH, 10); System.out.println(\"\\n变化后\"); System.out.println( \"年：\" + calendar.get(Calendar.YEAR) + \"\\n\" + \"月：\" + calendar.get(Calendar.MONTH) + \"\\n\" + \"一个月中的某一天：\" + calendar.get(Calendar.DAY_OF_MONTH) ); }} 1234567891011输出结果：变化前年：2020月：0一个月中的某一天：11变化后年：2018月：3一个月中的某一天：21 getTime() 方法返回一个表示此 Calendar时间值(从历元到现在的亳秒偏移量)的Date对象。 12345678910111213import java.util.Calendar;public class DemoCalendarGetTime { public static void main(String[] args) { // 首先使用getInstance()方法获取calendar对象 Calendar calendar = Calendar.getInstance(); // 返回一个表示calendar时间值(从历元到现在的亳秒偏移量)的Date对象。 System.out.println( calendar.getTime() ); }} 12输出结果：Sat Jan 11 21:16:52 CST 2020","link":"/p/411601202005/"},{"title":"JSON 学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China JSON 简介 JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON 具有自我描述性，更易理解 JSON 文件的文件类型是 “.json”。 JSON 文本的 MIME 类型是 “application/json”。 JSON - 转换为 JavaScript 对象 JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。 由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。 示例引入1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JavaScript 创建 JSON 对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;JavaScript 创建 JSON 对象&lt;/h2&gt; &lt;p&gt; 网站名称：&lt;span id=\"name\"&gt;&lt;/span&gt;&lt;br /&gt; 网站地址：&lt;span id=\"site\"&gt;&lt;/span&gt;&lt;br /&gt; 网站 slogan: &lt;span id=\"slogan\"&gt;&lt;/span&gt;&lt;br /&gt; &lt;/p&gt; &lt;script&gt; var JSONObject = { \"name\": \"LeeHua\", \"url\": \"www.stringbug.com\", \"slogan\": \"世间美好，与你环环相扣！\" }; document.getElementById(\"name\").innerHTML = JSONObject.name document.getElementById(\"site\").innerHTML = JSONObject.url document.getElementById(\"slogan\").innerHTML = JSONObject.slogan &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSON 与 XML 区别JSON 实例1234567{ \"sites\": [ { \"name\": \"菜鸟教程\" , \"url\": \"www.runoob.com\" }, { \"name\": \"google\" , \"url\": \"www.google.com\" }, { \"name\": \"微博\" , \"url\": \"www.weibo.com\" } ]} XML 实例1234567891011&lt;sites&gt; &lt;site&gt; &lt;name&gt;菜鸟教程&lt;/name&gt; &lt;url&gt;www.runoob.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;google&lt;/name&gt; &lt;url&gt;www.google.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;微博&lt;/name&gt; &lt;url&gt;www.weibo.com&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; JSON与 XML 相同之处 JSON 和 XML 数据都是 “自我描述” ，都易于理解。 JSON 和 XML 数据都是有层次的结构 JSON 具有层级结构（值中存在值） JSON 和 XML 数据可以被大多数编程语言使用 JSON与 XML 不同之处 JSON 不需要结束标签 JSON 更加简短 能够使用内建的 JavaScript eval() 方法进行解析 JSON 可以使用数组 最大的不同是：XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。 JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。 JSON.stringify(): 于将 JavaScript 值转换为 JSON 字符串。 JSON 语法JSON 语法规则 JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 JSON 名称/值对 JSON 数据的书写格式是：名称/值对。 名称/值对包括字段名称（在双引号中） JSON 值可以是数字（整数或浮点数）、字符串（在双引号中）、逻辑值（true 或 false）、数组（在中括号中）、对象（在大括号中）、null JSON 使用 JavaScript 语法因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，如： 12345var sites = [ { \"name\":\"youtube\" , \"url\":\"www.youtube.com\" }, { \"name\":\"google\" , \"url\":\"www.google.com\" }, { \"name\":\"微博\" , \"url\":\"www.weibo.com\" }]; 访问 JavaScript 对象数组中的第一项（索引从 0 开始） 1sites[0].name; 修改数据 1sites[0].name=\"StringBug\"; JSON 对象实例：{ &quot;name&quot;: &quot;runoob&quot;, &quot;alexa&quot;: 10000, &quot;site&quot;: null } JSON 对象使用在大括号 {} 中书写。 对象可以包含多个 key/value（键/值）对。 key 必须是字符串，value 可以是合法的 JSON 数据类型。 key 和 value 中使用冒号 : 分割。 每个 key/value 对使用逗号 , 分割。 访问对象值 方式1：对象.key 访问对象值 123var myObj, x;myObj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };x = myObj.name; 方式2：对象[key] 访问对象值 123var myObj, x;myObj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };x = myObj[\"name\"]; 循环对象 可以使用 for-in 来循环对象的属性 1234var myObj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };for (x in myObj) { document.getElementById(\"demo\").innerHTML += x + \"&lt;br&gt;\";} 在 for-in 循环对象的属性时，使用中括号 [] 来访问属性的值 1234var myObj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":null };for (x in myObj) { document.getElementById(\"demo\").innerHTML += myObj[x] + \"&lt;br&gt;\";} 嵌套 JSON 对象JSON 对象中可以包含另外一个 JSON 对象： 123456789myObj = { \"name\":\"runoob\", \"alexa\":10000, \"sites\": { \"site1\":\"www.runoob.com\", \"site2\":\"m.runoob.com\", \"site3\":\"c.runoob.com\" }} 可以使用点号 . 或者中括号 [] 来访问嵌套的 JSON 对象。如： 12x = myObj.sites.site1;x = myObj.sites[\"site1\"]; 修改值 可以使用点号 . 来修改 JSON 对象的值 1myObj.sites.site1 = \"www.google.com\"; 使用中括号 [] 来修改 JSON 对象的值 1myObj.sites[\"site1\"] = \"www.google.com\"; 删除对象属性 使用 delete 关键字来删除 JSON 对象的属性 1delete myObj.sites.site1; 使用中括号 [] 来删除 JSON 对象的属性 1delete myObj.sites[\"site1\"] JSON 数组JSON 对象中的数组 对象属性的值可以是一个数组 12345{\"name\": \"网站\",\"num\": 3,\"sites\": [ \"Google\", \"Runoob\", \"Taobao\" ]} 可以使用索引值来访问数组：x = myObj.sites[0]; 嵌套 JSON 对象中的数组 JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象 实例： 123456789myObj = { \"name\":\"网站\", \"num\":3, \"sites\": [ { \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] }, { \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] }, { \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] } ]} 使用 for-in 来循环访问每个数组： 123456for (i in myObj.sites) { x += \"&lt;h1&gt;\" + myObj.sites[i].name + \"&lt;/h1&gt;\"; for (j in myObj.sites[i].info) { x += myObj.sites[i].info[j] + \"&lt;br&gt;\"; }} 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;嵌套 JSON 对象中的数组&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;循环内嵌数组：&lt;/p&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script&gt; var myObj, i, j, x = \"\"; myObj = { \"name\":\"网站\", \"num\":3, \"sites\": [ { \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] }, { \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] }, { \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] } ] } // myObj.sites for (i in myObj.sites) { // myObj.sites --- name x += \"&lt;h1&gt;\" + myObj.sites[i].name + \"&lt;/h1&gt;\"; // myObj.sites --- info for (j in myObj.sites[i].info) { x += myObj.sites[i].info[j] + \"&lt;br&gt;\"; } } document.getElementById(\"demo\").innerHTML = x; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 修改数组值可以使用索引值来修改数组值：myObj.sites[1] = &quot;Github&quot;; 删除数组元素可以使用 delete 关键字来删除数组元素：delete myObj.sites[1]; JSON.parse() JSON 通常用于与服务端交换数据。在接收服务器数据时一般是字符串。我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。 语法： 1JSON.parse(text[, reviver]) text:必需， 一个有效的 JSON 字符串。 reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。 JSON 解析实例 例如我们从服务器接收了以下数据： 1{ \"name\":\"LeeHua\", \"site\":\"www.stringbug.com\" } 使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象： 1var obj = JSON.parse('{ \"name\":\"LeeHua\", \"site\":\"www.stringbug.com\" }'); 解析前要确保数据是标准的 JSON 格式，否则会解析出错。 解析完成后，我们就可以在网页上使用 JSON 数据了： 12345678&lt;body&gt; &lt;h2&gt;从 JSON 对象中创建 JavaScript 对象&lt;/h2&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script&gt; var obj = JSON.parse('{ \"name\":\"LeeHua\", \"site\":\"www.stringbug.com\" }'); document.getElementById(\"demo\").innerHTML = obj.name + \"：\" + obj.site; &lt;/script&gt;&lt;/body&gt; 结果如下： 从服务端接收 JSON 数据 可以使用 Ajax 从服务器请求 JSON 数据，并解析为 JavaScript 对象。 服务器端游如下一个文件：json_demo.txt 123456789{ \"name\": \"网站\", \"num\": 3, \"sites\": [ { \"name\": \"Google\", \"info\": [ \"Android\", \"Google 搜索\", \"Google 翻译\" ] }, { \"name\": \"Runoob\", \"info\": [ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] }, { \"name\": \"Taobao\", \"info\": [ \"淘宝\", \"网购\" ] } ]} 使用 XMLHttpRequest 来获取文件内容 123456789101112131415161718192021222324&lt;body&gt; &lt;h2&gt;使用 XMLHttpRequest 来获取文件内容&lt;/h2&gt; &lt;p&gt;文件内容是标准的 JSON 格式，可以使用 JSON.parse 方法将其转换为 JavaScript 对象。&lt;/p&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script&gt; // 创建 XMLHttpRequest 对象 var xmlhttp = new XMLHttpRequest(); // 执行一些基于响应的任务 xmlhttp.onreadystatechange = function() { // readyState 等于 4 且状态为 200 ，响应已就绪 if (this.readyState == 4 &amp;&amp; this.status == 200) { // 将服务器发送来的响应文本（JSON）解析为 JavaScript 对象 myObj = JSON.parse(this.responseText); // 文本插入到 id=\"demo\" 的标签体内 document.getElementById(\"demo\").innerHTML = myObj.name; } }; // 规定请求的类型、URL 以及是否异步处理请求 xmlhttp.open(\"GET\", \"json_demo.txt\", true); // 将请求从浏览器发送到服务器 xmlhttp.send(); &lt;/script&gt; &lt;p&gt;查看 JSON 文件数据 &lt;a href=\"json_demo.txt\" target=\"_blank\"&gt;json_demo.txt&lt;/a&gt;&lt;/p&gt;&lt;/body&gt; 结果如下： 点击 json_demo.txt，跳转 这里出现了乱码的情况，是没有规定解析格式导致的。 从服务端接收数组的 JSON 数据如果从服务端接收的是数组的 JSON 数据，则 JSON.parse 会将其转换为 JavaScript 数组： 123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { myArr = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myArr[1]; }};xmlhttp.open(\"GET\", \"json_demo_array.txt\", true);xmlhttp.send(); 异常 JSON 不能存储 Date 对象。如果需要存储 Date 对象，需要将其转换为字符串，之后再将字符串转换为 Date 对象。 1234var text = '{ \"name\": \"LeeHua\", \"initDate\": \"2013-12-14\", \"site\": \"www.stringbug.com\"}';var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate);document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期: \" + obj.initDate; 可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数 12345678var text = '{ \"name\": \"LeeHua\", \"initDate\": \"2013-12-14\", \"site\": \"www.stringbug.com\"}';var obj = JSON.parse(text, function (key, value) { if (key == \"initDate\") { return new Date(value); } else { return value;}});document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期：\" + obj.initDate; 解析函数 JSON 不允许包含函数，但可以将函数作为字符串存储，之后再将字符串转换为函数。 1234var text = '{ \"name\": \"LeeHua\", \"site\": \"function () { return \"www.stringbug.com\"; }\" }';var obj = JSON.parse(text);obj.site = eval(\"(\" + obj.site + \")\");document.getElementById(\"demo\").innerHTML = obj.name + \" 的网站：\" + obj.site(); 不建议在 JSON 中使用函数。 JSON.stringify() JSON 通常用于与服务端交换数据。在向服务器发送数据时一般是字符串。我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。 1JSON.stringify(value[, replacer[, space]]) 参数说明1JSON.stringify(value[, replacer[, space]]) value: 必需， 要转换的 JavaScript 值（通常为对象或数组）。 replacer: 可选。用于转换结果的函数或数组。 如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。 如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 space: 可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 JavaScript 对象转换例如我们向服务器发送以下数据： 1var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\"}; 我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串： 1var myJSON = JSON.stringify(obj); myJSON 为字符串。我们可以将 myJSON 发送到服务器： 123var obj = { \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON; JavaScript 数组转换我们也可以将 JavaScript 数组转换为 JSON 字符串： 12var arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr); 异常JSON 不能存储 Date 对象。JSON.stringify() 会将所有日期转换为字符串。 123var obj = { \"name\":\"Runoob\", \"initDate\":new Date(), \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON; 之后可以再将字符串转换为 Date 对象。 解析函数JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。 123var obj = { \"name\":\"Runoob\", \"alexa\":function () {return 10000;}, \"site\":\"www.runoob.com\"};var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON; 我们可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生： 1234var obj = { \"name\":\"Runoob\", \"alexa\":function () {return 10000;}, \"site\":\"www.runoob.com\"};obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON; JSON 使用把 JSON 文本转换为 JavaScript 对象 JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。 JSON 实例 - 来自字符串的对象 创建包含 JSON 语法的 JavaScript 字符串： 1234var txt = '{ \"sites\" : [' +'{ \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" },' +'{ \"name\":\"google\" , \"url\":\"www.google.com\" },' +'{ \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]}'; 由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。 eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误： var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); 在网页中使用 JavaScript 对象： 123456789101112131415161718&lt;body&gt; &lt;h2&gt;从 JSON 字符串中创建对象&lt;/h2&gt; &lt;p&gt; 网站名: &lt;span id=\"name\"&gt;&lt;/span&gt;&lt;br /&gt; 网站地址: &lt;span id=\"url\"&gt;&lt;/span&gt;&lt;br&gt; &lt;/p&gt; &lt;script&gt; var txt = '{ \"sites\" : [' + '{ \"name\":\"百度\" , \"url\":\"www.baidu.com\" },' + '{ \"name\":\"google\" , \"url\":\"www.google.com\" },' + '{ \"name\":\"微博\" , \"url\":\"www.weibo.com\" } ]}'; var obj = eval (\"(\" + txt + \")\"); document.getElementById(\"name\").innerHTML = obj.sites[0].name document.getElementById(\"url\").innerHTML = obj.sites[0].url &lt;/script&gt;&lt;/body&gt; 参考文献 JSON 教程| 菜鸟教程","link":"/p/591112202007/"},{"title":"JSP 表达式语言2","text":"@Author: YiHua Lee @Address: Guangdong province, China Expression Language 获取域中存储的值 el表达式只能从域对象中获取值 语法1： ${域名称.键名}：从指定域中获取指定键的值 1234pageScope --&gt; pageContextrequestScope --&gt; requestsessionScope --&gt; sessionapplicationScope --&gt; application（ServletContext） 举例： 123456789101112&lt;body&gt; &lt;% // 在域中存储数据 request.setAttribute(\"name1\", \"LeeHua\"); session.setAttribute(\"name2\", \"Rainbow\"); %&gt; &lt;h3&gt;获取域中的数据&lt;/h3&gt; ${requestScope.name1} &lt;br&gt; ${sessionScope.name2} &lt;/body&gt; 浏览器中访问：http://localhost:8080/JspStudy_war_exploded/ExpressionLanguageDemo01.jsp ![image-20200607000424239](/Users/liyihua/Library/Application Support/typora-user-images/image-20200607000424239.png) 语法2： ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 举例： 12345678910&lt;body&gt; &lt;% // 在域中存储数据 request.setAttribute(\"name\", \"request_LeeHua\"); session.setAttribute(\"name\", \"session_Rainbow\"); %&gt; &lt;h3&gt;获取域中的数据&lt;/h3&gt; ${name}&lt;/body&gt; 依次从page –&gt; request –&gt; session –&gt; application 中查找，找到name，就返回其值，没找到就返回null 浏览器中访问：http://localhost:8080/JspStudy_war_exploded/ExpressionLanguageDemo02.jsp ![image-20200607001050435](/Users/liyihua/Library/Application Support/typora-user-images/image-20200607001050435.png) Expression Language 获取域中存储的对象值获取对象、List集合、Map集合的值。 获取对象：${域名称.键名.属性名} 创建一个Users对象 123456789101112131415161718192021222324252627282930public class Users { private String name; private String password; private Date date; public Users() { } public Users(String name, String password, Date date) { this.name = name; this.password = password; this.date = date; } /** 逻辑视图 @return 对date进行格式化，如果date为null，返回\"\"，如果不为null，返回自定义格式的日期 */ public String getDateSimple() { return date == null ? \"\" : new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(date); } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; }} ExpressionLanguageDemo03.jsp 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;% Users me = new Users(); me.setName(\"LeeHua\"); me.setPassword(\"love\"); me.setDate(new Date()); request.setAttribute(\"me\", me); Users she = new Users(); she.setName(\"Rainbow\"); she.setPassword(\"1314\"); she.setDate(new Date()); request.setAttribute(\"she\", she); %&gt; &lt;h3&gt;在request域中，获取对象中的值&lt;/h3&gt; ${requestScope.me.name}&lt;%=\" \"%&gt; ${requestScope.me.password} ${requestScope.she.name}&lt;%=\" \"%&gt; ${requestScope.she.password} &lt;h3&gt;在request域中，获取对象中的值&lt;/h3&gt; ${me.name}&lt;%=\" \"%&gt; ${me.password} ${she.name}&lt;%=\" \"%&gt; ${she.password} &lt;h3&gt;在request域中，获取对象中的值&lt;/h3&gt; ${me.date}&lt;br&gt; ${she.dateSimple}&lt;/body&gt; 浏览器中访问：http://localhost:8080/JspStudy_war_exploded/ExpressionLanguageDemo03.jsp 获取List集合：${域名称.键名[索引]} 这里也是用上面的Users对象 ExpressionLanguageDemo04.jsp 1234567891011121314151617181920212223242526&lt;body&gt; &lt;% Users me = new Users(); me.setName(\"LeeHua\"); me.setPassword(\"love\"); me.setDate(new Date()); Users she = new Users(); she.setName(\"Rainbow\"); she.setPassword(\"1314\"); she.setDate(new Date()); %&gt; &lt;% List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(me); list.add(she); request.setAttribute(\"list\", list); %&gt; &lt;h3&gt;在request域中，获取List中的值&lt;/h3&gt; ${requestScope.list[0].name}&lt;%=\" \"%&gt; ${requestScope.list[0].password}&lt;%=\" \"%&gt; ${requestScope.list[1].name}&lt;%=\" \"%&gt; ${requestScope.list[1].password}&lt;/body&gt; 浏览器中访问：http://localhost:8080/JspStudy_war_exploded/ExpressionLanguageDemo04.jsp &lt;br&gt; 获取Map集合：${域名称.键名.key名称}、${域名称.键名[&quot;key名称&quot;]} 这里也是使用上面的Users对象 ExpressionLanguageDemo05.jsp 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;% Users me = new Users(); me.setName(\"LeeHua\"); me.setPassword(\"love\"); me.setDate(new Date()); Users she = new Users(); she.setName(\"Rainbow\"); she.setPassword(\"1314\"); she.setDate(new Date()); %&gt; &lt;% Map&lt;String, Users&gt; map = new HashMap&lt;&gt;(); map.put(\"Hua\", me); map.put(\"Cai\", she); request.setAttribute(\"map\", map); %&gt; &lt;h3&gt;在request域中，获取Map中的值&lt;/h3&gt; ${requestScope.map.Hua.name}&lt;%=\" \"%&gt; ${requestScope.map.Hua.password}&lt;%=\" \"%&gt; ${requestScope.map.Cai.name}&lt;%=\" \"%&gt; ${requestScope.map.Cai.password} &lt;h3&gt;在request域中，获取Map中的值&lt;/h3&gt; ${requestScope.map[\"Hua\"].name}&lt;%=\" \"%&gt; ${requestScope.map[\"Hua\"].password}&lt;%=\" \"%&gt; ${requestScope.map[\"Cai\"].name}&lt;%=\" \"%&gt; ${requestScope.map[\"Cai\"].password}&lt;/body&gt; 浏览器中访问：http://localhost:8080/JspStudy_war_exploded/ExpressionLanguageDemo05.jsp empty 运算符 空运算符 empty ，用于判断字符串、集合、数组对象是否为null或者长度为0 格式： 判断字符串、集合、数组对象是否为null或者长度为0 1${empty XXX} 判断字符串、集合、数组对象是否不为null或者长度不为0 1${not empty XXX} 举例： ExpressionLanguageDemo06.jsp 123456789101112131415161718&lt;body&gt; &lt;% String me = \"LeeHua\"; String she = \"Rainbow\"; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"love\"); list.add(\"1314\"); request.setAttribute(\"name1\", me); request.setAttribute(\"name2\", she); request.setAttribute(\"list\", list); %&gt; &lt;h3&gt;为空判断！！！&lt;/h3&gt; ${empty name1}&lt;br/&gt; ${not empty name2}&lt;br/&gt; ${empty list}&lt;br/&gt; ${not empty list}&lt;/body&gt; 浏览器中访问：http://localhost:8080/JspStudy_war_exploded/ExpressionLanguageDemo06.jsp 隐式对象参考：隐含对象 pageContext对象pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样： 1${pageContext.request.queryString} 动态获取虚拟目录 1234&lt;body&gt; &lt;h3&gt;动态获取虚拟目录:&lt;/h3&gt; ${pageContext.request.contextPath}&lt;/body&gt; Scope对象 pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。 举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。 param和paramValues对象 param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。 举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[&quot;order&quot;]}。 接下来的例子表明了如何访问request中的username参数： 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;% String title = \"Accessing Request Param\"; request.setAttribute(\"title\", title); %&gt; &lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt;&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;&lt;/center&gt; &lt;div align=\"center\"&gt; &lt;p&gt;${param[\"username\"]}&lt;/p&gt; &lt;p&gt;${paramValues}&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; param返回一个参数，paramValues返回一个Map&lt;String, String&gt; 集合。 header和headerValues对象 header和headerValues对象用来访问信息头，通过使用 request.getHeader方法和request.getHeaders方法。 举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[&quot;user-agent&quot;]}。 接下来的例子表明了如何访问user-agent信息头： 1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;% String title = \"User Agent Example\"; %&gt; &lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/center&gt; &lt;div align=\"center\"&gt; &lt;p&gt;${header[\"user-agant\"]}&lt;/p&gt; &lt;p&gt;${headerValues}&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; header对象返回单一值，而headerValues则返回一个字符串数组。 参考文献 JSP 表达式语言| 菜鸟教程","link":"/p/560708202006/"},{"title":"Java ArrayList类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China ArrayList类的说明ArrayList类是List接口的实现类，java.util.ArrayList集合数据存储的结构是数组结构。 特点元素增删慢，查找快。（由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。） 为什么说元素增删慢，查找快 首先，ArrayList集合数据存储的结构是数组结构 而数组是元素增删慢，查找快的： 数组查询快：数组的地址是连续的我们通过数组的首地址可以找到数组，通过数组的素引可以快速查找某一个元素 元素增删慢：数组的长度是固定的我们想要增加/删除一个元素，必须创建一个新数组把源数组的数据复制过来 增删元素，会在堆内存中频繁的创建新数组、复制数组中的元素、销毁数组，导致效率低下","link":"/p/212101202005/"},{"title":"Java HashSet集合的子类LinkedHashSet集合的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 说明 HashSet保证元素的唯一性，可是元素存放进去是没有顺序的。 在HashSet下面有一个子类java.util.LinkedHashSet，它是 链表 + 哈希表(数组+链表 或者 数组+红黑树)组合的一个数据结构。 链表 + 哈希表 = （链表 + 数组 + 链表） 或者 （链表 + 数组 + 红黑树） 即相对HashSet而言，多了一个链表结构。多了的那条链表，用来记录元素的存储顺序，保证元素有序。实例引入 HashSet集合例子112345678910111213import java.util.HashSet;public class DemoLinkedHashSet { public static void main(String[] args) { HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(\"https\"); hashSet.add(\"www\"); hashSet.add(\"cnblogs\"); hashSet.add(\"com\"); System.out.println(hashSet); }} 12输出结果：[com, cnblogs, www, https] HashSet集合例子2将例子1中添加元素的顺序调换一下 12345678910111213import java.util.HashSet;public class DemoLinkedHashSet { public static void main(String[] args) { HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(\"cnblogs\"); hashSet.add(\"com\"); hashSet.add(\"https\"); hashSet.add(\"www\"); System.out.println(hashSet); }} 12输出结果：[com, cnblogs, www, https] 可以看出，HashSet集合存储的元素是无序的。 LinkedHashSet集合例子112345678910111213import java.util.LinkedHashSet;public class DemoLinkedHashSet { public static void main(String[] args) { LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); linkedHashSet.add(\"https\"); linkedHashSet.add(\"www\"); linkedHashSet.add(\"cnblogs\"); linkedHashSet.add(\"com\"); System.out.println(linkedHashSet); }} 12输出结果：[https, www, cnblogs, com] LinkedHashSet集合例子2将例子1中添加元素的顺序调换一下 12345678910111213import java.util.LinkedHashSet;public class DemoLinkedHashSet02 { public static void main(String[] args) { LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); linkedHashSet.add(\"cnblogs\"); linkedHashSet.add(\"com\"); linkedHashSet.add(\"https\"); linkedHashSet.add(\"www\"); System.out.println(linkedHashSet); }} 12输出结果：[cnblogs, com, https, www] 可以看出，LinkedHashSet集合存储的元素是有序的。","link":"/p/542201202005/"},{"title":"Java Collection集合概述及其常用方法","text":"@Author: YiHua Lee @Address: Guangdong province, China Collection集合概述 Java数组的长度是固定的，为了使程序能够方便地存储和操作数目不固定的一组数据，JDK类库提供了Java集合 与数组不同的是，集合中不能存放基本类型数据，而只能存放对象的引用。 数组只能存储同种数据类型的元素 ,集合可以存储不同类型的元素 集合框架的介绍 Collection集合的常用功能java.utiL.Collection接口 所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法 任意的单列集合都可以使用Collection接口中的方法 Collection接口的共性方法1234567public boolean add(E e) 把给定的对象添加到当前集合中。public void clear() 清空集合中所有的元素。public boolean remove(E e) 把给定的对象在当前集合中册除。public boolean contains(E e) 判断当前集合中是否包合给定的对象。public boolean isEmpty() 判断当前集合是否为空。public int size() 返回集合中元素的个数。public Object[] toArray() 把集合中的元素,存储到数组中。 add()方法作用：把给定的对象添加到当前集合中。 1234567891011121314151617import java.util.Collection;import java.util.ArrayList;public class DemoCollectionAdd { public static void main(String[] args) { // 使用多态，创建一个ArrayList对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 输出该集合的内容是为空的（其中它重写了toString方法） System.out.println(\"没有进行任何操作的ArrayList集合对象：\" + collection); // 往ArrayList集合中添加元素，返回值只一个boolean值，一般不用接收这个返回值 boolean addReturn = collection.add(\"LeeHua\"); System.out.println(\"往集合中添加一个元素后的返回值：\" + addReturn); System.out.println(\"使用add方法往集合里面添加了元素后：\" + collection); }} 1234输出结果：没有进行任何操作的ArrayList集合对象：[]往集合中添加一个元素后的返回值：true使用add方法往集合里面添加了元素后：[LeeHua] remove方法作用：把给定的对象在当前集合中册除。 12345678910111213141516171819202122232425262728import java.util.Collection;import java.util.ArrayList;public class DemoCollectionRemove { public static void main(String[] args) { // 使用多态，创建一个ArrayList对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); System.out.println(\"往集合中添加元素前的集合是：\" + collection); // 往集合中添加元素 collection.add(\"一号\"); collection.add(\"二号\"); collection.add(\"三号\"); collection.add(\"四号\"); System.out.println(\"往集合中添加元素后的集合是：\" + collection); // 使用remove方法，把给定的对象在当前集合中册除 // 如果要删除的元素存在该集合，那么就返回true // 否则返回false boolean removeReturn1 = collection.remove(\"一号\"); System.out.println(\"删除元素\\\"一号\\\"的返回值：\" + removeReturn1); System.out.println(\"删除元素\\\"一号\\\"后的集合是：\" + collection); boolean removeReturn2 = collection.remove(\"十号\"); System.out.println(\"删除元素\\\"十号\\\"的返回值：\" + removeReturn2); System.out.println(\"删除元素\\\"十号\\\"后的集合是：\" + collection); }} 1234567输出结果：往集合中添加元素前的集合是：[]往集合中添加元素后的集合是：[一号, 二号, 三号, 四号]删除元素&quot;一号&quot;的返回值：true删除元素&quot;一号&quot;后的集合是：[二号, 三号, 四号]删除元素&quot;十号&quot;的返回值：false删除元素&quot;十号&quot;后的集合是：[二号, 三号, 四号] contains方法作用：判断当前集合中是否包合给定的对象。 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.Collection;public class DemoCollectionContains { public static void main(String[] args) { Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 往集合中添加元素 collection.add(\"对象1\"); collection.add(\"对象2\"); collection.add(\"对象3\"); collection.add(\"对象4\"); System.out.println(\"集合：\" + collection); // 使用contains方法，判断当前集合中是否包合给定的对象 // 如果包合给定的对象，那么就返回true // 否则返回false boolean containsReturn1 = collection.constains(\"对象100\"); System.out.println(\"是否包含\\\"对象100\\\"：\" + containsReturn1); boolean containsReturn2 = collection.constains(\"对象1\"); System.out.println(\"是否包含\\\"对象1\\\"：\" + containsReturn2); }} 1234输出结果：集合：[对象1, 对象2, 对象3, 对象4]是否包含&quot;对象100&quot;：false是否包含&quot;对象1&quot;：true isEmpty方法作用：判断当前集合是否为空。 12345678910111213141516171819import java.util.ArrayList;import java.util.Collection;public class DemoCollectionIsEmpty { public static void main(String[] args) { // 使用多态，创建一个ArrayList对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 判断集合是否为空 boolean isEmptyReturn1 = collection.isEmpty(); System.out.println(\"集合是否为空：\" + isEmptyReturn1); // 向集合里面添加元素 collection.add(\"一号元素\"); // 判断集合是否为空 boolean isEmptyReturn2 = collection.isEmpty(); System.out.println(\"集合是否为空：\" + isEmptyReturn2); }} 123输出结果：集合是否为空：true集合是否为空：false size方法作用：返回集合中元素的个数。 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.Collection;public class DemoCollectionSize { public static void main(String[] args) { // 使用多态，创建一个ArrayList对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 使用size方法，查看集合中的元素个数 int collectionSize1 = collection.size(); System.out.println(\"collectionSize1 = \" + collectionSize1); // 往集合中添加元素 collection.add(\"一号元素\"); collection.add(\"二号元素\"); collection.add(\"三号元素\"); collection.add(\"四号元素\"); collection.add(\"五号元素\"); // 使用size方法，再次查看集合中的元素个数 int collectionSize2 = collection.size(); System.out.println(\"collectionSize2 = \" + collectionSize2); }} 123输出结果：collectionSize1 = 0collectionSize2 = 5 toArray方法作用：把集合中的元素,存储到数组中。 123456789101112131415161718192021public class DemoCollectionToArray { public static void main(String[] args) { // 使用多态，创建一个ArrayList对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 往集合中添加元素 collection.add(\"一号元素\"); collection.add(\"二号元素\"); collection.add(\"三号元素\"); collection.add(\"四号元素\"); collection.add(\"五号元素\"); // 使用toArray方法，把集合中的元素，存储到数组中。 Object[] collectionToArray = collection.toArray(); // 遍历输出 for (int i = 0; i &lt; collectionToArray.length; i++) { System.out.println(collectionToArray[i]); } }} 123456输出结果：一号元素二号元素三号元素四号元素五号元素 clear方法作用：清空集合中的所用元素 123456789101112131415161718192021import java.util.ArrayList;import java.util.Collection;public class DemoCollectionClear { public static void main(String[] args) { // 使用多态，创建一个ArrayList对象 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 往集合中添加元素 collection.add(\"一号元素\"); collection.add(\"二号元素\"); collection.add(\"三号元素\"); collection.add(\"四号元素\"); collection.add(\"五号元素\"); System.out.println(\"清空集合元素之前：\" + collection); // 使用clear方法，清空集合中的所用元素 collection.clear(); System.out.println(\"清空集合元素之后：\" + collection); }} 123输出结果：清空集合元素之前：[一号元素, 二号元素, 三号元素, 四号元素, 五号元素]清空集合元素之后：[]","link":"/p/401801202005/"},{"title":"Java Junit单元测试","text":"@Author: YiHua Lee @Address: Guangdong province, China Junit单元测试分类 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 Junit使用：白盒测试步骤 定义一个测试类(测试用例) 建议： 测试类名：被测试的类名Test（如CalculatorTest） 包名：xxx.xxx.xx.test （如view.study.demo43.test） 定义测试方法：可以独立运行 建议： 方法名：test测试的方法名 （如testAdd） 返回值：void 参数列表：空参 给方法加@Test 导入junit依赖环境 举例创建一个加减法类，我们来测试这个类： 12345678910111213141516171819package view.study.demo44;public class Calculator { /** * 加法 */ public static int add(int a, int b) { return a + b; } /** * 减法 */ public static int sub(int a, int b) { return a - b; }} 传统的测试方式： 123456789101112package view.study.demo44;public class CalculatorTest { public static void main(String[] args) { int add = Calculator.add(10, 20); int sub = Calculator.sub(10, 20); System.out.println(add); System.out.println(sub); }} Junit使用：白盒测试 12345678910111213141516171819202122import org.junit.Test;import view.study.demo44.Calculator;public class CalculatorTest { /** * 测试add()方法 */ @Test public void testAdd() { int add = Calculator.add(10, 20); System.out.println(add); } /** * 测试sub()方法 */ @Test public void testSub() { int sub = Calculator.sub(10, 20); System.out.println(sub); }} 注意： 12这里需要添加：@Test 进行标示 一般我们会使用断言操作来处理结果： 1Assert.assertEquals(期望的结果, 运算的结果); 还是上面的例子： 123456789101112131415161718192021222324252627package view.study.demo44.test;import org.junit.Assert;import org.junit.Test;import view.study.demo44.Calculator;public class CalculatorTest { /** * 测试add()方法 */ @Test public void testAdd() { int add = Calculator.add(10, 20); Assert.assertEquals(30, add); System.out.println(add); } /** * 测试sub()方法 */ @Test public void testSub() { int sub = Calculator.sub(10, 20); Assert.assertEquals(30, sub); System.out.println(sub); }} 从代码中可以看出，测试add()方法，是正确的。而测试sub()方法，会抛出错误，很明显(10 - 20)的值是 -10 ，不是30，抛出错误如下： @Before 和 @After @Before： 修饰的方法会在测试方法之前被自动执行 @After： 修饰的方法会在测试方法执行之后自动被执行 如上面，测试add()方法： 1234567891011121314151617181920212223242526272829303132333435363738package view.study.demo44.test;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import view.study.demo44.Calculator;public class CalculatorTest { /** * 初始化方法 * 用于资源的申请，所有测试方法在执行之前都会先执行该方法。 */ @Before public void init() { System.out.println(\"初始化方法 __init__ \"); } /** * 释放资源方法 * 在所有测试方法执行之后，都会自动执行该方法。 */ @After public void close() { System.out.println(\"释放资源方法 __close__ \"); } /** * 测试add()方法 */ @Test public void testAdd() { int add = Calculator.add(10, 20); Assert.assertEquals(30, add); System.out.println(add); }} 进行测试，结果如下：","link":"/p/421404202005/"},{"title":"Java Collection集合中的iterator方法","text":"@Author: YiHua Lee @Address: Guangdong province, China Iterator接口的概述 java.util.Iterator接口:选代器(对集合进行遍历) 有两个常用的方法 boolean hasNext()如果仍有元素可以迭代,则返回true。 即判断集合中还有没有下ー个元素,有就返回true,没有就返回 E next() 返回送代的下一个元素。 即取出集合中的下一个元素 iterator迭代器,是一个接口,我们无法直接使用,需要使用Iterator接口的实现类对象。 获取实现类的方式比较特殊Collection接口中有一个方法,叫iterator(),这个方法返回的就是送代器的实现类对象 迭代器的使用步骤 使用集合中的方法 iterator()获取送代器的实现类对象,使用Iterator接口接收(多态) 使用Iterator接口中的方法hasNext来判断还有没有下一个元素 使用Iterator接口中的方法next来取出集合中的下一个元素 迭代器的简单使用12345678910111213141516171819202122232425262728import java.util.ArrayList;import java.util.Iterator;import java.util.Collection;public class Demo01Iterator { public static void main(String[] args) { Collection &lt;String&gt; collection = new ArrayList&lt;&gt;(); collection.add(\"1号\"); collection.add(\"2号\"); collection.add(\"3号\"); collection.add(\"4号\"); collection.add(\"5号\"); // 第一步：使用集合中的方法 iterator() 获取送代器的实现类对象 // 第二步：使用Iterator接口接收(多态) Iterator&lt;String&gt; stringIterator = collection.iterator(); // 第三步：使用Iterator接口中的方法hasNext来判断还有没有下一个元素 while (stringIterator.hasNext()) { // 第四步：使用Iterator接口中的方法next来取出集合中的下一个元素 System.out.println( stringIterator.next() ); } }} 123456输出结果：1号2号3号4号5号 迭代器的使用原理 new一个集合出来collection = new ArrayList&lt;&gt;() 假设集合中添加有元素collection = [一号元素, 二号元素, 三号元素, 四号元素, 五号元素] 集合中的元素对应的索引Index = [0, 1, 2, 3, 4] 调用iterator方法collection.iterator()作用：获取迭代器的实现类对象井且会把指针(索引)指向集合的-1素引 代码说明： 123while (stringIterator.hasNext()) { stringIterator.next()} 通过Iterator接口的hasNext()方法，判断集合是否还有没有下一个元素。 如果有下一个元素，那么就调用Iterator接口的next()方法，取出下一个元素，并且会把指针向后移一位。 就这样，从索引的 -1 位置的下一位索引，开始获取元素，直到获取完全。","link":"/p/531801202005/"},{"title":"Java Data类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China Date类的概述 java.util,Date 表示日期和时间的类 类 Date 表示特定的瞬间，精确到千分之一秒（毫秒） 实例引入：获取时间原点到当前系统时间经历了多少秒 1234567// 时间原点：1970 年 01 月 01 日 00:00:00public class DemoDate { public static void main(String[] args) { System.out.println(System.currentTimeMillis()); }} Date类常用的构造方法和成员方法成员方法getTime()方法。返回：时间原点以来，此Date对象表示的毫秒数 123456789101112import java.util.Date;public class DemoGetTime { public static void main(String[] args) { Date date = new Date(); long time = date.getTime(); // 输出：1578728202850 // 该方法类似于 System.currentTimeMillis() System.out.println(time); }} 构造方法Date类的无参构造方法。返回：当前系统的日期和时间 12345678910import java.util.Date;public class DemoDate1 { public static void main(String[] args) { Date date = new Date(); // 输出：Sat Jan 11 15:40:50 CST 2020 System.out.println(date); }} Date类的带参构造方法Date(long date) 参数为一个毫秒值，把传入的毫秒值转换为Date日期 返回：传入参数（毫秒值）对应的的日期和时间 1234567891011import java.util.Date;public class DemoDate2 { public static void main(String[] args) { Date date = new Date(0L); // 这里输出的是0毫秒时的日期和时间，即时间原点的日期和时间 // 输出：Thu Jan 01 08:00:00 CST 1970 System.out.println(date); }} DateFormat抽象类和SimpleDateFormat实现类说明 java.text.DateFormat类，是日期/时间格式化子类的抽象类 作用：格式化(也就是日期-&gt;文本)、解析(文本-&gt;日期) 成员方法 string format( Datedate)按照指定的模式,把Date日期,格式化为符合模式的字符串 Date parse( string source)把符合模式的字符串,解析为Dote日期 DateFormat类是一个抽象类,无法直接创建对象使用，可以使用 DateFormat类的子类java.text.SimpleDateFormat extends DateFormat 构造方法：SimpleDateFormat(String pattern)用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat 参数：string pattern：传递指定的模式 模式: 区分大小写的 y 年 M 月 d 日 H 时 m 分 s 秒 1234567891011121314151617181920212223242526272829 3. 注意事项：写对应的模式，会把模式替换为对应的时间和日期。 如：&quot;yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒&quot;### 测试1. 测试DateFormat类的format方法，输出指定格式的日期、时间 ```java import java.text.SimpleDateFormat; import java.util.Date; public class Demo01FormatMethod { public static void main(String[] args) { // 创建SimpleDateFormat对象，在SimpleDateFormat(String pattern)构造方法中传入指定的模式 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒&quot;); // 调用DateFormat的实现类SimpleDateFormat中的format方法， // 按照构造方法中指定的模式，把Date解析为符合模式的字符串（文本） Date date = new Date(); String dateFormat = simpleDateFormat.format(date); // Sat Jan 11 16:24:43 CST 2020 System.out.println(date); // 2020 年 01 月 11 日 16 时 24 分 43 秒 System.out.println(dateFormat); } } 测试DateFormat类的parse方法，把符合构造方法中模式的字符串，解析为Date日期 1234567891011121314151617181920212223242526272829/** * DateFormat类中的parse方法，把文本解析为日期 * 使用步骤: * 1,创建 SimpleDateFormat对象，构造方法中传递指定的模式 * 2.调用 SimpleDateFormat对象中的 parse方法，把符合SimpleDateFormat(String pattern)构造方法中模式的字符串，解析为Date日期 * 注意: * public Date parse(String source) throws ParseException * parse方法声明了ー个异常叫 ParseException * 如果字符串和构造方法的模式不ー样，那么程序就会抛出此异常 * 调用一个出了异常的方法，就必须的处理这个异常， * 要么 throws 继续批出这个昇常,要么 try catch自己处理 */import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo01ParseMethod { public static void main(String[] args) throws ParseException { // 创建SimpleDateFormat对象，在SimpleDateFormat(String pattern)构造方法中传入指定的模式 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒\"); // 调用 SimpleDateFormat对象中的 parse方法，把符合构SimpleDateFormat(String pattern)造方法中模式的字符串，解析为Date日期 Date dateParse = simpleDateFormat.parse(\"2020 年 01 月 11 日 16 时 24 分 43 秒\"); // Sat Jan 11 16:24:43 CST 2020 System.out.println(dateParse); }}","link":"/p/281601202005/"},{"title":"Java Linked集合的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China LinkedList的简单介绍 java.util.LinkedList 集合数据存储的结构是链表结构。LinkedList是一个双向链表 在实际开发中，对一个集合元素的添加和删除，经常涉及到首尾操作，而LinkedList就提供了大量的首尾操作的方法 LinkedList集合的特点 方便元素的添加、删除 元素的查询慢 里面包括了大量首尾首尾操作的方法 注意：LinkedList集合的方法不能使用多态 为什么说LinkedList集合添加、删除元素方便，查询元素慢 首先，LinkedList集合数据存储的结构是链表结构 而链表是添加、删除元素方便，查询元素慢的： 查询慢：链表中地址不是连续的每次查询元素都必须从头开始查询 增删快：链表结构增加/删除一个元素对链表的整体结构没有影响，所以增删快 操作集合首尾的方法、是否为空判断方法12345678910111213public void addFirst(E e):将指定元素插入此列表的开头。public void addLast(E e):将指定元素添加到此列表的结尾。public E getFirst():返回此列表的第一个元素。public E getLast():返回此列表的最后一个元素。public E removeFirst():移除并返回此列表的第一个元素。public E removeLast():移除并返回此列表的最后一个元素。public void push(E e):将元素推入此列表所表示的堆栈。public E pop():从此列表所表示的堆处弹出一个元素。public boolean isEmpty():如果列表不包含元素,则返回true addFirst()和addLast()方法123456789101112131415161718192021public class DemoLinkedListAddFirstLast { public static void main(String[] args) { // 创建LinkedList链表集合对象 LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); // 向linkedList添加元素 linkedList.add(0, \"链表元素0\"); linkedList.add(1, \"链表元素1\"); linkedList.add(2, \"链表元素2\"); linkedList.add(3, \"链表元素3\"); linkedList.add(4, \"链表元素4\"); linkedList.add(5, \"链表元素5\"); System.out.println(linkedList); // 用addFirst方法向链表集合开头添加一个元素 linkedList.addFirst(\"开头\"); // 用addLast方法向链表集合开头添加一个元素 linkedList.addLast(\"结尾\"); System.out.println(linkedList); }} 123输出结果：[链表元素0, 链表元素1, 链表元素2, 链表元素3, 链表元素4, 链表元素5][开头, 链表元素0, 链表元素1, 链表元素2, 链表元素3, 链表元素4, 链表元素5, 结尾] getFirst()和getLact()方法123456789101112131415161718192021222324import java.util.LinkedList;public class DemoLinkedListGetFirstLast { public static void main(String[] args) { // 创建LinkedList链表集合对象 LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); // 向linkedList添加元素 linkedList.add(0, \"链表元素0\"); linkedList.add(1, \"链表元素1\"); linkedList.add(2, \"链表元素2\"); linkedList.add(3, \"链表元素3\"); linkedList.add(4, \"链表元素4\"); linkedList.add(5, \"链表元素5\"); System.out.println(linkedList); // 获取此列表的第一个元素。 String first = linkedList.getFirst(); // 获取此列表的最后一个元素。 String last = linkedList.getLast(); System.out.println(\"第一个元素：\" + first); System.out.println(\"最后一个元素：\" + last); }} 1234输出结果：[链表元素0, 链表元素1, 链表元素2, 链表元素3, 链表元素4, 链表元素5]第一个元素：链表元素0最后一个元素：链表元素5 removeFirst()和removeLast()方法12345678910111213141516171819202122232425import java.util.LinkedList;public class DemoLinkedListRemoveFirstLast { public static void main(String[] args) { // 创建LinkedList链表集合对象 LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); // 向linkedList添加元素 linkedList.add(0, \"链表元素0\"); linkedList.add(1, \"链表元素1\"); linkedList.add(2, \"链表元素2\"); linkedList.add(3, \"链表元素3\"); linkedList.add(4, \"链表元素4\"); linkedList.add(5, \"链表元素5\"); System.out.println(linkedList); // 移除并返回此列表的第一个元素 String first = linkedList.removeFirst(); // 移除并返回此列表的最后一个元素 String last = linkedList.removeLast(); System.out.println(\"移除的第一个元素：\" + first); System.out.println(\"移除的最后一个元素：\" + last); System.out.println(\"此时的集合：\" + linkedList); }} 12345输出结果：[链表元素0, 链表元素1, 链表元素2, 链表元素3, 链表元素4, 链表元素5]移除的第一个元素：链表元素0移除的最后一个元素：链表元素5此时的集合：[链表元素1, 链表元素2, 链表元素3, 链表元素4] push()和pop()方法说明： push()方法和addFirst()方法功能一样 pop()方法和removeFirst()方法功能一样 12345678910111213141516171819202122import java.util.LinkedList;public class DemoLinkedListPushPop { public static void main(String[] args) { // 创建LinkedList链表集合对象 LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); // 向linkedList添加元素 linkedList.add(0, \"链表元素0\"); linkedList.add(1, \"链表元素1\"); linkedList.add(2, \"链表元素2\"); System.out.println(\"原集合：\" + linkedList); // 将元素推入此列表所表示的堆栈 linkedList.push(\"push元素\"); System.out.println(\"push()操作后的集合：\" + linkedList); // 从此列表所表示的堆处弹出一个元素 linkedList.pop(); System.out.println(\"push()操作后的集合：\" + linkedList); }} 1234输出结果：原集合：[链表元素0, 链表元素1, 链表元素2]push()操作后的集合：[push元素, 链表元素0, 链表元素1, 链表元素2]push()操作后的集合：[链表元素0, 链表元素1, 链表元素2] isEmpty()方法12345678910111213141516171819import java.util.LinkedList;public class DemoLinkedListIsEmpty { public static void main(String[] args) { // 创建LinkedList链表集合对象 LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); boolean b1 = linkedList.isEmpty(); System.out.println(\"集合是否为空：\" + b1); // 向linkedList添加元素 linkedList.add(0, \"链表元素0\"); linkedList.add(1, \"链表元素1\"); linkedList.add(2, \"链表元素2\"); boolean b2 = linkedList.isEmpty(); System.out.println(\"集合是否为空：\" + b2); }} 123输出结果：集合是否为空：true集合是否为空：false","link":"/p/302101202005/"},{"title":"Java Object类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China Object的toString方法 toString 方法返回的是字符串，直接打印对象的名字，就是调用对象的toString，也就是打印对象堆内存中的地址值 重写toString方法 123456789101112131415161718192021222324252627282930313233343536/** * @Version: 1.8.0_201 Java SE 8 * @Description: toString 方法返回的是字符串，直接打印对象的名字，就是调用对象的toString * 也就是打印对象堆内存中的地址值 */public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public void methodStudentMassage() { System.out.println( \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}' ); } /** * 重写toString方法 * @return 学生的信息 */ @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 测试重写的toString方法 12345678910111213141516/** * @Version: 1.8.0_201 Java SE 8 */public class DemoStudentToString { public static void main(String[] args) { Student student = new Student(\"Lee Hua\", 21); // 不重写toString方法 student.methodStudentMassage(); // 重写了toString方法 System.out.println( student.toString() ); }} 输出结果 12Student{name='Lee Hua', age=21}Student{name='Lee Hua', age=21} Object类的equals方法 quals方法：其他某个对象是否与此对象相等 调用成员方quals并指定参数为另一个对象，则可判断这两个对象是否相同 123public boolean equals(Object obj) { return (this == obj);} this 表示：哪个对象调用了equals方法，那么this就是那个对象 实例理解 创建一个Person类，用于测试 public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } &lt;!--￼4--&gt; 输出结果 123Person@61bbe9baPerson@610455d6false 实例补充 1234567891011/** * Person类如果重写类Object的toString方法，则返回字符串，而不是地址值 * 举例： */@Overridepublic String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}';} 在Person类里边覆盖重写equals方法 123456789101112131415161718192021222324252627public class Person { /** * 多态，无法使用子类特有内容，所以可进行覆盖重写 * 覆盖重写equals方法，提高程序的效率 */ @Override public boolean equals(Object obj) { // 如果传递的参数obj是this本身，直接返回true if (obj == this) { return true; } // 如果传递参数是null，直接返回false if (obj == null) { return false; } // 防止类型转换报：ClassCastException if (obj instanceof Person) { // 向下转型，将 obj 转换为 Person 类型 Person person = (Person)obj; return this.name.equals(person.name) &amp;&amp; this.age == person.age; } // 不是Person类，也不是null，也直接返回false else { return false; } }} 使用IDEA编译工具，可以用 Generate 直接生成与上等功能代码 1234567891011121314public class Person { @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } Person person = (Person) o; return age == person.age &amp;&amp; name.equals(person.name); }} 注意事项使用equals方法时，防止空指针异常实例理解 1234567891011121314151617181920212223import java.util.Objects;public class DemoObjectEquals { public static void main(String[] args) { String s1 = \"abc\"; String s2 = null; // 不会出现空指针异常 // 输出 false System.out.println( s1.equals(s2) ); // 会出现空指针异常NullPointerException // 报错 Exception in thread \"main\" java.lang.NullPointerException System.out.println( s2.equals(s1) ); // 空指针异常，可以使用java.util.Objects的equals方法，防止空指针异常 // 输出 false System.out.println( Objects.equals(s1, s2) ); }}","link":"/p/061601202005/"},{"title":"Java List集合简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China List接口的介绍 java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。 在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访可集合中的指定元素。 另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口的特点 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理)。 集合中可以有重复的元素,通过元素的 equals方法，来比较是否为重复的元素。 List接口中带索引的（特有）方法1234567891011// 1、将指定的元素,添加到该集合中的指定位置上。public void add(int index, E element)// 2、返回集合中指定位置的元素。public E get(int index)// 3、移除列表中指定位置的元素,返回的是被移除的元素。public E remove(int index)// 4、用指定元素替换集合中指定位置的元素,返回值的更新前的元素。public E set(int index, E element) add()方法123说明：hasNext()方法，获取迭代器是否含有下一个元素（含有就返回true）next()方法，获取迭代器下一个元素 12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class DemoListAdd { public static void main(String[] args) { // 创建集合对象 List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); // 往集合的指定位置上添加给定的元素 arrayList.add(0, \"Index 0 元素\"); arrayList.add(1, \"Index 1 元素\"); arrayList.add(2, \"Index 2 元素\"); // 遍历集合，查看结果 // 获取迭代器对象 Iterator&lt;String&gt; ite = arrayList.iterator(); // 输出 while (ite.hasNext()) { System.out.println( ite.next() ); } }} 1234输出结果：Index 0 元素Index 1 元素Index 2 元素 get()方法123456789101112131415161718192021222324import java.util.ArrayList;import java.util.List;public class DemoListGet { public static void main(String[] args) { // 创建集合对象 List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); // 往集合的指定位置上添加给定的元素 arrayList.add(0, \"Index 0 元素\"); arrayList.add(1, \"Index 1 元素\"); arrayList.add(2, \"Index 2 元素\"); // 获取指定位置中集合的元素 String index0 = arrayList.get(0); String index1 = arrayList.get(1); String index2 = arrayList.get(2); // 输出 System.out.println(\"索引0处的元素：\" + index0); System.out.println(\"索引1处的元素：\" + index1); System.out.println(\"索引2处的元素：\" + index2); }} 1234输出结果：索引0处的元素：Index 0 元素索引1处的元素：Index 1 元素索引2处的元素：Index 2 元素 remove()方法1234567891011121314151617public class DemoListRemove { public static void main(String[] args) { // 创建集合对象 List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); // 往集合的指定位置上添加给定的元素 arrayList.add(0, \"元素0\"); arrayList.add(1, \"元素1\"); arrayList.add(2, \"元素2\"); // 查看集合 System.out.println(\"移除元素前：\" + arrayList); // 删除集合中的部分元素 arrayList.remove(1); System.out.println(\"移除元素1后：\" + arrayList); }} 123输出结果：移除元素前：[元素0, 元素1, 元素2]移除元素1后：[元素0, 元素2] 注意：移除一个元素以后，在被移除元素的后面的每个元素索引减1 set()方法1234567891011121314151617181920import java.util.ArrayList;import java.util.List;public class DemoListSet { public static void main(String[] args) { // 创建集合对象 List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); // 往集合的指定位置上添加给定的元素 arrayList.add(0, \"原始元素0\"); arrayList.add(1, \"原始元素1\"); arrayList.add(2, \"原始元素2\"); // 查看集合 System.out.println(\"集合被替换元素前：\" + arrayList); // set方法替换指定位置的元素 arrayList.set(0, \"替换元素0\"); System.out.println(\"集合被替换元素后：\" + arrayList); }} 123输出结果：集合被替换元素前：[原始元素0, 原始元素1, 原始元素2]集合被替换元素后：[替换元素0, 原始元素1, 原始元素2]","link":"/p/122101202005/"},{"title":"Java final关键词的简单理解","text":"@Author: YiHua Lee @Address: Guangdong province, China final关键词的四种用法123456789101112131415161718192021222324252627282930313233343536373839404142434445* * final 关键字：最终的、不可改变的 * 1、可以用来修饰一个类 * 2、可以用来修饰一个方法 * 3、可以用来修饰一个局部变量 * 4、可以用来修饰一个成员变量 * * * 1、final 修饰一个类： * 格式： * public class final 类名称 { * // 方法区 * } * 含义：当前的类不能更改，不能有子类（太监类） * 不能使用一个 final 修饰的类来当父类，这个类里面的所有方法也就不能进行覆盖重写了。 * * * 2、final 修饰一个方法： * 格式： * 修饰符 final 返回值类型 方法名称(参数列表) { * // 方法体 * } * 含义：该方法所在的类可以被继承（即可以是其他类的父类）， * 但是这个方法不能给覆盖重写，用final修饰后就不可以更改了 * 注意事项：对于类、方法来说，关键词abstract和final不能同时使用，因为会矛盾。 * abstract 修饰的类、方法是一定要给覆盖重写的，而 final 修饰的类是不能更改的（即不能给覆盖重写的） * 所以关键词abstract和final不能同时使用 * * * 3、final 修饰一个局部变量 * 一旦使用 final 修饰的局部变量，那么这个变量将不能进行更改， * &quot;一次赋值，终生不变&quot; * 注意事项： * 对于基本数据类型来说，不可变的是变量当中的数据值 * 对于引用苏剧类型来说，不可变的是变量当中的地址值 * * * 4、final 修饰一个成员变量 * 对于成员变量来说，使用了 final 来修饰，那么这个变量同样也是不可以进行更改的，且需要马上赋值，否则无意义 * 假如你用final修饰来一个成员变量，没有赋值，那么该成员变量的值是默认值，且不可以更改，那么定义这个成员变量就是无意义的 * 注意事项： * （1）成员变量具有默认值，所以用了final修饰后，必须手动赋值，不会再给默认值了。 * （2）对于final的成员变量，要么直接赋值，要么通过构造方法赋值（二者选其一）。 * （3）必须保证类当中所有的构造方法，最终都对final成员变量进行赋值。 * final修饰成员变量","link":"/p/311930202004/"},{"title":"Java Stream流式思想","text":"@Author: YiHua Lee @Address: Guangdong province, China 说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢?在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 引言传统集合的多步遍历代码几乎所有的集合(如 Collection 接口或 Map 接口等)都支持直接或间接的遍历操作。而当我们需要对集合中的元 素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如： 123456789101112131415import java.util.List;import java.util.ArrayList;import java.util.Collections;public class DemoForEach { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, \"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); for (String s : list) { System.out.println(s); } }} 运行程序，控制台输出： 12345JavaCPythonHadoopSpark 这是一段非常简单的集合遍历操作:对集合中的每一个字符串都进行打印输出操作。 循环遍历的弊端Java 8的Lambda让我们可以更加专注于做什么(What)，而不是怎么做(How)。 现在，我们仔细体会一下上例代码，可以发现： for循环的语法就是“怎么做” for循环的循环体才是“做什么” 为什么使用循环?因为要进行遍历。但循环是遍历的唯一方式吗?遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 试想一下，如果希望对集合中的元素进行筛选过滤： 将集合A根据条件一过滤为子集B; 然后再根据条件二过滤为子集C。 那怎么办?在Java 8之前的做法可能为： 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Collections;import java.util.List;public class DemoNormalFilter { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, \"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); System.out.print(\"筛选前的集合：\"); for (String s : list) { System.out.print(s + \"，\"); } System.out.println(); System.out.print(\"经过条件1筛选后的集合：\"); for (String s : list) { if (s.length() &gt;= 4) { System.out.print(s + \"，\"); } } System.out.println(); System.out.print(\"经过条件2筛选后的集合：\"); for (String s : list) { if (s.length() &gt;= 5) { System.out.print(s + \"，\"); } } System.out.println(); }} 运行程序，控制台输出： 123筛选前的集合：Java，C，Python，Hadoop，Spark，经过条件1筛选后的集合：Java，Python，Hadoop，Spark，经过条件2筛选后的集合：Python，Hadoop，Spark， 这段代码中含有三个循环，每一个作用不同： 1、首先从头到尾，遍历输出集合。 2、然后筛选字符串长度大于等于4的元素，并输出。 3、最后筛选字符串长度大于等于5的元素，并输出。 每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么?不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。 那么，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？下面我们来看一下Stream的更优写法。 Stream的更优写法下面来看一下借助Java 8的Stream API，什么才叫优雅： 123456789101112131415import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Demo01Stream { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, \"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); list.stream() .filter((s) -&gt; s.length() &gt;= 4) .filter((s) -&gt; s.length() &gt;= 5) .forEach((s) -&gt; System.out.println(s)); }} 运行程序，控制台输出： 123PythonHadoopSpark 筛选的结果与上面的例子一致。 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤长度小于4的、过滤长度小于5的、逐一打印。代码 中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 上面程序用到的方法： stream()方法利用stream()方法，来获取流。该方法是java.util.Collection接口中的一个默认方法，方法源码如下： 1234// 返回以该集合为源的序列流。default Stream&lt;E&gt; stream() { return StreamSupport.stream(spliterator(), false);} filter()方法该方法是java.util.stream包中的Stream接口里的一个抽象方法，方法源码如下： 12// 返回由与给定 {predicate} 匹配的此流元素组成的流。Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该方法的返回值是一个流，传入的参数是一个函数式接口：java.util.function.Predicate，该接口可以对某种类型的数据进行判断，然后返回一个布尔值。 forEach()方法该方法是java.util.stream包中Stream接口里的一个抽象方法，方法源码如下： 12// 对该流的每个元素执行操作。void forEach(Consumer&lt;? super T&gt; action); 该方法没有返回值，传入的参数是一个函数式接口：java.util.function.Consumer。它的作用是：消费一个数据， 其数据类型由泛型决定。 上面例子的代码可以进行改善： 123456789101112131415import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Demo02Stream { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, \"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); list.stream() .filter((s) -&gt; s.length() &gt;= 4) .filter((s) -&gt; s.length() &gt;= 5) .forEach(System.out::println); }} 其实就是修改了forEach()方法中传入的参数， 12System.out::println(s) -&gt; System.out.println(s) 这两者是等价的。 流式思想概述注意：请暂时忘记对传统IO流的固有印象! 整体来看，流式思想类似于工厂车间的“生产流水线”。 当需要对多个元素进行操作(特别是多步操作)的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤 方案，然后再按照方案去执行它。 这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字 3是最终结果。 这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count 执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 1备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据构，其本身并不存储任何元素(或其地址值)。 Stream(流)是一个来自数据源的元素队列 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源：流的来源。 可以是集合，数组等。 和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining：中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格(fluent style)。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代：以前对集合遍历都是通过Iterator或者增强for的方式，显式的在集合外部进行迭代，这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 当使用一个流的时候，通常包括三个基本步骤:获取一个数据源(source)→ 数据转换→执行操作获取想要的结果，每次转换原有Stream 对象不改变，返回一个新的 Stream 对象(可以有多次转换)，这就允许对其操作可以 像链条一样排列，变成一个管道。","link":"/p/281404202005/"},{"title":"Java System类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China System类的概述 java.lang.System 类中提供了大量的静态方法,可以获取与系统相关的信息或系统级操作 在System类的API文档中,常用的方法有： 12345public static Long currentTimeMillis()// 返回以毫秒为单位的当前时间public static void arraycopy(Object src, int srcpos, Object dest, int destpos, int Length)// 将数组中指定的数据拷贝到另一个数组中 System类常用的静态方法currentTimeMillis()方法作用：返回以毫秒为单位的当前时间 12345678910111213public class DemoSystemCurrentTimeMillis { public static void main(String[] args) { // 程序执行前 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 9999; i++) { System.out.println(\"测试这个for循环用时\"); } // 程序执行后 long end = System.currentTimeMillis(); // 输出： 这个for循环耗时：146毫秒 System.out.println(\"这个for循环耗时：\" + (end - start) + \"毫秒\"); }} arraycopy()方法参数说明：arraycopy(Object src, int srcpos, Object dest, int destpos, int Length) src：源数组 srcpos：源数组复制的起始索引 dest：目标数组 destpos：目标数组的起始索引 Length：复制的元素个数 作用：将数组中指定的数据拷贝到另一个数组中 例子：将数组1中的前三个元素，复制到数组2的前三个位置上 123456789101112131415import java.util.Arrays;public class DemoSystemCopyArray { public static void main(String[] args) { // 定义源数组 int[] array1 = {0, 1, 2, 3, 4}; // 定义目标数组 int[] array2 = {5, 6, 7, 8 ,9}; System.out.println(\"复制前：\" + Arrays.toString(array2)); // 开始复制 System.arraycopy(array1, 0, array2, 0, 3); System.out.println(\"复制后：\" + Arrays.toString(array2)); }} 123输出结果：复制前：[5, 6, 7, 8, 9]复制后：[0, 1, 2, 8, 9]","link":"/p/001701202005/"},{"title":"Java 三目运算符","text":"@Author: YiHua Lee @Address: Guangdong province, China 直接实例理解 1234567891011121314public class Test { public static void main(String args[]){ int a , b; a = 10; b = (a == 1) ? 20 : 30; // 如果a等于1那么b就等于20，否则等于30 System.out.println( \"Value of b is : \" + b ); b = (a == 10) ? 20 : 30; System.out.println( \"Value of b is : \" + b ); }} 123输出：Value of b is : 30Value of b is : 20","link":"/p/101830202004/"},{"title":"Java StringBuilder类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China StringBuilder的原理String类 String类 字符串是常量，它们的值在创建之后不能更改 字符串的底层是一个被final修饰的数组，不能改变 1private final byte[] value; 进行字符串的相加，内存中就会多字符串，占用空间多，效率低下 如：”a” + “b” + “c” = “abc” 123相加之前：&quot;a&quot; &quot;b&quot; &quot;c&quot; 有三个字符串了(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)两个相加后：&quot;ab&quot; &quot;c&quot; 这里有一个新的字符串生成（&quot;ab&quot;）三个相加后：&quot;abc&quot; 这里又有一个新的字符串生成（&quot;abc&quot;） 结论：三个字符串相加，就有5个字符串占用空间，导致效率低下 StringBuilder类 StringBuilder类 字符串缓冲区，可以提高字符串的操作效率（可以看成是一个长度可以变化的字符串） 它的底层也是一个数组，但是没有个final修饰， 可以改变长度 1byte[] value = new byte[16]; 与String不同的是，StringBuilder能够对其中的字符串进行各种操作 StringBuilder的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。 如： “a” + “b” + “c” = “abc” 这里可以直接在字符串的缓冲区操作字符串，数组长度默认是16，可随实质进行增长 结论：StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。 StringBuilder的构造方法说明 Java.Lang.StringBuilder类 字符串緩冲区,可以提高字符串的效率 构造方法： StringBuilder() 构造一个不带任何字符的字符串生成器,其初始容量为16个字符。 StringBuilder(string str) 构造一个字符串生成器,并初始化为指定的字符串内容。 代码理解123456789101112public class Demo01StringBuilder { public static void main(String[] args) { // 无参构造方法 StringBuilder stringBuilder1 = new StringBuilder(); // 加参构造方法 StringBuilder stringBuilder2 = new StringBuilder(\"我是有参数的构造方法\"); System.out.println(\"stringBuilder1：\" + stringBuilder1); System.out.println(\"stringBuilder2：\" + stringBuilder2); }} 123输出结果：stringBuilder1：stringBuilder2：我是有参数的构造方法 StringBuilder常用的方法append()方法作用：添加任意类型数据的字符串形式，并返回当前对象自身 123456789public class DemoStringBuilderAppend { public static void main(String[] args) { StringBuilder stringBuilder = new StringBuilder(); System.out.println(\"添加之前stringBuilder：\" + stringBuilder); stringBuilder.append(\"Cross Fire\"); System.out.println(\"添加之后stringBuilder：\" + stringBuilder); }} 123输出结果：添加之前stringBuilder：添加之后stringBuilder：Cross Fire toString()方法说明 StringBuilder和String可以相互转换 string 转换为 StringBuilder： 可以使用 StringBuilder的构造方法StringBuilder( string str)构造一个字符串生成器,并初始化为指定的字符串内容。 StringBuilder 转换为 string： 可以使用 StringBuilder中的 toString方法public String toString():将当前 StringBuilder对象转换为 string对象。 代码理解1234567891011121314public class DemoStringBuilderToString { public static void main(String[] args) { String string1 = \"Hello\"; System.out.println(\"string1：\" + string1); // string 转换为 StringBuilder StringBuilder stringBuilder = new StringBuilder(string1); System.out.println(\"string 转换为 StringBuilder：\" + stringBuilder); // StringBuilder 转换为 string String string2 = stringBuilder.toString(); System.out.println(\"StringBuilder 转换为 string：\" + string2); }} 1234输出结果：string1：Hellostring 转换为 StringBuilder：HelloStringBuilder 转换为 string：Hello","link":"/p/151801202005/"},{"title":"Java IO流之缓冲流（深入浅出学习）","text":"@Author: YiHua Lee @Address: Guangdong province, China 缓冲流概述缓冲流，也叫高效流。能够高效读写缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化对象等等。它是四个基本File流的增强，所以也是4个流，按照数据类型分类。 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO读取次数，从而提高读写的效率。 字节缓冲流构造方法1234567891011BufferedInputStream(InputStream in)BufferedInputStream(InputStream in, int size)// 创建一个新的字节缓冲输入流BufferedOutputStream(OutputStream out) // 将数据写入指定的底层输出流BufferedOutputStream(OutputStream out, int size) // 将具有指定缓冲区大小的数据写入指定的底层输出流// 创建一个新的字节缓冲输出流参数：InputStream in：字节输入流OutputStream out：字节输出流int size：缓冲区大小，不写的话，默认 BufferedOutputStream —— 字节缓冲输出流举例：把数据写入到文件中 使用步骤： 123456789101112131415161718192021222324252627282930313233341.创建FileOutputStream对象，构造方法中绑定要输出的目的地。2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率。3.使用BufferedOutputStream对象中的方法write，把数据写入到内部冲区中。4.使用BufferedOutputStream对象中的方法flush，把内部冲区中的数据，刷新到文件中。5.释放资源（会先调用flush方法刷新数据，第4步可以省略）。import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;public class DemoBufferedOutputStream { public static void main(String[] args) throws IOException { method(); } public static void method() throws IOException { // 创建FileOutputStream对象，构造方法中绑定要输出的目的地。 FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/BufferedOutputStream.txt\", true); // 创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率。 BufferedOutputStream bos = new BufferedOutputStream(fos); // 使用BufferedOutputStream对象中的方法write，把数据写入到内部冲区中。 byte[] bytes = \"abc\".getBytes(); bos.write(bytes); // 使用BufferedOutputStream对象中的方法flush，把内部冲区中的数据，刷新到文件中。 bos.flush(); // 释放资源（会先调用flush方法刷新数据，第4步可以省略）。 bos.close(); fos.close(); }} 运行生成文件BufferedOutputStream.txt文件，文件的内容如下： BufferedInputStream —— 字节缓冲输入流举例：读取文件上例中生成的BufferedOutputStream.txt文件。 使用步骤： 12345678910111213141516171819202122232425262728293031323334353637383940411.创建FileInputStream对象，构造方法中绑定要读取的效据源。2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputsStream对象的读取效率3.使用BufferedInputStream对象中的方法read，读取文件。4.释放资源。import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.IOException;public class DemoBufferedInputStream { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建FileInputStream对象，构造方法中绑定要读取的效据源。 FileInputStream fis = new FileInputStream( \"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/BufferedOutputStream.txt\" ); // 创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputsStream对象的读取效率 BufferedInputStream bis = new BufferedInputStream(fis); // 使用BufferedInputStream对象中的方法read，读取文件。 int len1 = bis.read(); System.out.println(len1); int len2 = bis.read(); System.out.println(len2); int len3 = bis.read(); System.out.println(len3); // 第四次读取的时候，所以的字节都已经给读取过了，返回-1 int len4 = bis.read(); System.out.println(len4); // 释放资源 bis.close(); fis.close(); }} 控制台输出： 1234979899-1 效率测试1234567891011121314151617/** * 举例：不同方法，拷贝图片的速度，来测试效率 * * 文件复制的步骤(不使用缓冲)： * 1.创建一个字节输入流对象，构造方法中绑定要读取的数据源。 * 2.创建一个字节输出流对象，构造方法中绑定要写入的目的地。 * 3.使用字节输入流对象中的方法read，读取文件。 * 4.使用字节输出流中的方法write，把读取到的字节写入到目的地的文件中。 * 5.释放资源。 * * 文件复制的步骤(使用缓冲)： * 1.创建字节缓冲输入流对象，构造方法中传递字节输入流。 * 2.创建字节缓冲输出流对象，构造方法中传递字节输岀流。 * 3.使用字节缓冲输入流对象中的方法read，读取文件。 * 4.使用字节缓冲输出流中的方法wite，把读取的数据写入到内部缓冲区中。 * 5.释放资源（会先把缓冲区中的数据，刷新到文件中）。 */ 定义三个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 不使用缓冲字节输入输出流， * 一个一个字节的方式。 */public static void method1() throws IOException { FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/test.jpg\"); FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/copy1.jpg\"); int len = 0; while ((len = fis.read()) != -1) { fos.write(len); } fis.close(); fos.close();}/** * 不使用缓冲字节输入输出流， * 一次读取多个字节的方式。 */public static void method2() throws IOException { FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/test.jpg\"); FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/copy2.jpg\"); byte[] bytes = new byte[1024]; int len = 0; while ((len = fis.read(bytes)) != -1) { fos.write(bytes, 0, len); } fis.close(); fos.close();}/** * 使用缓冲字节输入输出流 */public static void method3() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/test.jpg\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo33/copy3.jpg\")); byte[] bytes = new byte[1024]; int len = 0; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } bos.close(); bis.close();} 测试这三个方法的效率： 123456789101112131415161718192021public class DemoEfficiency { public static void main(String[] args) throws IOException { // 方法1效率测试 long method1StartTime = System.currentTimeMillis(); method1(); long method1EndTime = System.currentTimeMillis(); System.out.println(\"使用方法1，文件复制耗时（毫秒）：\" + (method1EndTime - method1StartTime)); // 方法2效率测试 long method2StartTime = System.currentTimeMillis(); method2(); long method2EndTime = System.currentTimeMillis(); System.out.println(\"使用方法2，文件复制耗时（毫秒）：\" + (method2EndTime - method2StartTime)); // 方法3效率测试 long method3StartTime = System.currentTimeMillis(); method3(); long method3EndTime = System.currentTimeMillis(); System.out.println(\"使用方法3，文件复制耗时（毫秒）：\" + (method3EndTime - method3StartTime)); }} 控制台输出： 123使用方法1，文件复制耗时（毫秒）：30268使用方法2，文件复制耗时（毫秒）：53使用方法3，文件复制耗时（毫秒）：21 文件大小：8,392,028 字节（磁盘上的 8.4 MB） 运行程序，生成：copy1.jpg、copy2.jpg、copy3.jpg三个文件 可以看出，使用缓冲字节输入输出流效率极高。 字符缓冲流构造方法1234567891011BufferedReader(Reader in)BufferedReader(Reader in, int sz)// 创建一个新的缓冲字符输入流BufferedWriter(Writer out)BufferedWriter(Writer out, int sz)// 创建一个新的缓冲字符输出流参数：Writer out：字符输出流Reader in：字符输入流int sz：缓冲区大小 BufferedWriter —— 字符缓冲输出流举例：把字符文件写入到文件中 使用步骤： 1234567891011121314151617181920212223242526271.创建字符缓冲输岀流对象，构造方法中传递字符输岀流。2.调用字符缓冲输出流中的方法write，把数据写入到內存缓冲区中。3.调用字符缓冲输出流中的方法flush，把内存缓冲区中的数据，刷新到文件中。4.释放资源。import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class DemoBufferedWrite { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建字符缓冲输岀流对象，构造方法中传递字符输岀流。 BufferedWriter bw = new BufferedWriter(new FileWriter(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo34/BufferedWriter.txt\")); // 调用字符缓冲输出流中的方法write，把数据写入到內存缓冲区中。 bw.write(\"你好吖！字符缓冲输出流\"); // 调用字符缓冲输出流中的方法flush，把内存缓冲区中的数据，刷新到文件中。 bw.flush(); // 释放资源。 bw.close(); }} 运行结果，生成BufferedWriter.txt文件，文件内容如下： 如果需要换行，可以使用该类里的newLine()方法。该方法如同println()方法。 BufferedReader —— 字符缓冲输入流这个类有一个特有的成员方法： 1234String readLine()// 读取一个文本行（读取一行数据）。返回值：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回null。 行的终止符：换行（’\\n’）、回车（’\\r’）、回车后直接跟着换行（’\\r\\n’） 举例：读取一个文件中的每行字符。 使用步骤： 1234567891011121314151617181920212223241.创建字符缓冲输入流对象，构造方法中传递字符输入流。2.使用字符缓冲输入流对象中的方法read/readLine，读取文本。3.释放资源。import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class DemoReader { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建字符缓冲输入流对象，构造方法中传递字符输入流。 BufferedReader br = new BufferedReader(new FileReader(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo34/test\")); // 使用字符缓冲输入流对象中的方法read/readLine，读取文本。 String line; while ((line = br.readLine()) != null) { // 当每行数据都读取了后，如果再读取，则会返回null System.out.println(line); } }} 文件test.txt内容如下： 控制台输出： 123第1行数据第2行数据第3行数据","link":"/p/161803202005/"},{"title":"Java set接口之HashSet集合的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China Set接口的简单概述java.util.set接口继承自Collection接口，它与Collection接口中的方法基本一致，并没有对 Collection接口进行功能上的扩充，只是比collection接口更加严格了。set接口中元素是无序的,并且都会以某种规则保证存入的元素不出现重复。 简述其特点： 不允许存储重复的元素 没有索引，也没有带索引的方法，不能使用普通的for循环遍历 Set接口有多个实现类，java.util.HashSet是其常用的子类 HashSet集合的介绍 java.util.HashSet是set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。 java.util.HashSet底层的实现其实是一个java.util.HashMap支持 HashSet是根据对象的哈希值来确定元素在集合中的存储位置的，因此具有良好的存取和查找性能。 保证元素唯一性的方式依赖于：hashCode与 equals方法。 代码简单理解1234567891011121314151617181920212223242526272829import java.util.HashSet;import java.util.Iterator;public class DemoHashSet { public static void main(String[] args) { // 创建set集合(HashSet) HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); // 使用add方法想HashSet集合中添加元素 hashSet.add(\"A\"); hashSet.add(\"B\"); hashSet.add(\"C\"); hashSet.add(\"D\"); hashSet.add(\"A\"); System.out.println(\"集合中的元素：\" + hashSet); System.out.println(\"==============================\"); // 使用迭代器遍历集合 Iterator&lt;String&gt; ite = hashSet.iterator(); while (ite.hasNext()) { System.out.println(ite.next()); } System.out.println(\"==============================\"); // 使用增强for循环遍历集合（不能使用普通的for循环，对HashSet集合进行遍历） for (String s: hashSet) { System.out.println(s); } }} 123456789101112输出结果：集合中的元素：[A, B, C, D]==============================ABCD==============================ABCD 注意：普通for循环不能遍历HashSet集合，HashSet集合中没有重复的元素，元素的存储顺序不一致。 HashSet集合存储数据的结构（哈希表）什么是哈希表 哈希表（又称散列表），它是根据关键码值(Key - Value)而直接进行访问的数据结构。 也就是说，哈希表是通过把关键码值（Key）映射到表中一个位置来访问记录（Value），以加快查找的速度。这个映射函数叫做哈希函数（散列函数），存放记录的数组叫做哈希表。 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同hash值的链表都存储在一个链表里。 但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。 而JDK1.8中，哈希表存储采用数组+链表+或数组+红黑树实现，当链表长度超过阈值(8)时，将链表转换为红黑树，这样大大减少了查找时间。 什么是链表链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 什么是红黑树红黑树（又称对称二叉B树），是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。 什么是关联数组是一种具有特殊索引方式的数组。不仅可以通过整数来索引它，还可以使用字符串或者其他类型的值（除了NULL）来索引它。 哈希值 哈希值是通过一定的哈希算法，将一段较长的数据映射为较短小的二进制数据，这段小数据就是大数据的哈希值。 特点：它是唯一的，一旦大数据发生了变化，哪怕是一个微小的变化，他的哈希值也会发生变化。 作用：主要用途是用于文件校验或签名。 在Java程序中的哈希值123456789101112131415161718192021222324252627282930313233343536373839/** * 在Java中哈希值：是一个十进制的整数，由系统随机给出的二进制数经过换算得到的 * 其实它就是对象的地址值，是一个逻辑地址，是模拟出来得到地址，并不是数据实际存储的物理地址 * * 在Object类有一个方法,可以获取对象的哈希值： * int hashCode() 返回对象的哈希码值 * hashCode()方法源码： * public native int hashCode(); * native：代表该方法是调用本地操作系统的方法 */// 随便创建一个类public class Person extends Object{ private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 1234567891011121314151617181920// 用这个类创建对象，查看对象的哈希值public class DemoHashCode { public static void main(String[] args) { // 创建一个p1对象，查看其哈希值 Person p1 = new Person(\"LeeHua\", 21); // 调用Object的hashCode方法，获取哈希值，p1的哈希值是不变的 int h1 = p1.hashCode(); System.out.println(h1); // 创建一个p2对象，查看其哈希值 Person p2 = new Person(\"WanTao\", 20); // 调用Object的hashCode方法，获取哈希值，p2的哈希值也是不变的 int h2 = p2.hashCode(); System.out.println(h2); // 查看p1、p2的地址值 System.out.println(p1); System.out.println(p2); }} 12345输出结果：16397050181627674070view.study.demo18.Person@61bbe9baview.study.demo18.Person@610455d6 假如覆盖重写hashCode方法，所创建的对象的哈希值就会被影响如： 1234567891011public class Person1 extends Object{ /** * 重写hashCode方法 * @return 哈希值 */ @Override public int hashCode() { return 666; }} 123456789101112public class DemoHashCode1 { public static void main(String[] args) { // 创建一个p1对象，查看其哈希值 Person1 p1 = new Person1(); // 调用Object的hashCode方法，获取哈希值，p1的哈希值是不变的 int h1 = p1.hashCode(); System.out.println(h1); // 查看p1、p2的地址值 System.out.println(p1); }} 123输出结果：666view.study.demo18.Person1@29a 如：我们常用的String类，它也覆盖重写了hashCode方法 123456789101112public class DemoStringHashCode { public static void main(String[] args) { /* String类的哈希值 （String类重写了Object类的hashCode方法） */ String s1 = new String(\"LeeHua\"); String s2 = new String(\"WanTao\"); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); }} 123输出结果：-2022794392-1711288770 图形理解 可以看到，数组的每个位置放到一定的值，每部分值都对应一个哈希值。 当值的个数超过8个的时候，采用数组+红黑树；当值的个数不到8个的时候，采用数组+链表 如： 值1、2、3、4的哈希值都是11 值13、14、15的哈希值都是15 值a、b、c、d、e、f、g的哈希值都是89 Set集合存储元素不重复原理set集合在调用add()方法的时候，add()方法会调用元素的hashCode()方法和 equals()方法判断元素是否重复 代码举例12345678910111213141516171819202122import java.util.HashSet;public class DemoStringHashCode1 { public static void main(String[] args) { HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); hashSet.add(s1); hashSet.add(s2); hashSet.add(\"一号\"); hashSet.add(\"二号\"); System.out.println(\"s1的哈希值：\" + s1.hashCode()); System.out.println(\"s2的哈希值：\" + s2.hashCode()); System.out.println(\"一号的哈希值：\" + \"一号\".hashCode()); System.out.println(\"二号的哈希值：\" + \"二号\".hashCode()); System.out.println(\"HashSet集合：\" + hashSet); }} 123456输出结果：s1的哈希值：96354s2的哈希值：96354一号的哈希值：640503二号的哈希值：644843HashSet集合：[二号, abc, 一号] 代码讲解最初，hashSet集合是空的 hashSet.add(s1)的时候 第一步：add()方法首先会调用s1的hashCode()方法，计算字符串”abc”的哈希值，其哈希值是96354， 第二步：查找集合中哈希值是96354中的元素，没有发现哈希值是96354的key 第三步：将s1存储到集合hashSet中（于是集合hashSet中存在哈希值96354，且对应这数据s1） hashSet.add(s2)的时候 第一步：add()方法首先会调用s2的hashCode()方法，计算字符串”abc”的哈希值，其哈希值是96354， 第二步：查找集合hashSet中是否存在哈希值是96354，即哈希值96354冲突， 第三步：s2调用equals()方法，和集合中哈希值是96354对应的元素进行比较 第四步：s2.equals(s1)返回true，即哈希值是96354对应的元素已经存在，所以就不添加s2进集合了(其中：s1 = “abc”，s2 = “abc”) hashSet.add(“一号”)的时候 第一步：调用 “一号” 的hashCode()方法，计算字符串 “一号” 的哈希值，其哈希值是640503， 第二步：查找集合中哈希值是640503中的元素，没有发现哈希值是640503的key， 第三步：将 “一号” 存储到集合hashSet中（于是集合hashSet中存在哈希值640503，且对应这数据 “一号”） hashSet.add(“二号”)的时候 第一步：调用 “二号” 的hashCode()方法，计算字符串 “二号” 的哈希值，其哈希值是644843， 第二步：查找集合中哈希值是644843中的元素，没有发现哈希值是644843的key， 第三步：将 “二号” 存储到集合hashSet中（于是集合hashSet中存在哈希值644843，且对应这数据 “二号”） 添加完成，集合hashSet = [abc, 一号, 二号] HashSet存储自定义类型元素hashSet存储自定义类型元素，那么自定义的类必须重写hashCode()方法和equals()方法，否则添加的元素可以出现重复，我们平时使用的类型，它们都重写类hashCode()方法和equals()方法。 假如不重写hashCode()方法和equals()方法例子： 12345678910111213141516171819202122232425262728293031323334353637// 随便创建一个类，作为HashSet存入数据的类型public class Person{ private String name; private int age; @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} IDEA 编译，阿里巴巴Java Code规范会抛出警告 测试一下会出现什么情况 12345678910111213141516import java.util.HashSet;public class Demo01PersonHashSet { public static void main(String[] args) { HashSet&lt;Person&gt; hashSet = new HashSet&lt;&gt;(); Person p1 = new Person(\"小明\", 20); Person p2 = new Person(\"小明\", 20); Person p3 = new Person(\"小红\", 20); hashSet.add(p1); hashSet.add(p2); hashSet.add(p3); System.out.println(hashSet); }} 12输出结果：[Person{name='小明', age=20}, Person{name='小明', age=20}, Person{name='小红', age=20}] 可以看到，hashSet集合里面可以存在重复的元素。 重写hashCode()方法和equals()方法还是上面这个例子： 在Person类里面添加要重写hashCode()、equals()方法的代码即可，要添加的代码如下 1234567891011121314151617181920212223public class Person{ @Override public boolean equals(Object o) { // 参数 == 对象 if (this == o) { return true; } // 传入参数为空，或者对象与参数的hashCode不相等 if (o == null || getClass() != o.getClass()) { return false; } // 向下转型，把Object类型转型为Person类型 Person person = (Person) o; // 返回 age，name return age == person.age &amp;&amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); }} 再次用上面的代码测试一下Person类型的数据添加是否会出现重复： 12输出结果：[Person{name='小明', age=20}, Person{name='小红', age=20}] 可以看到，输出结果中，hashSet集合的元素并没有重复，因此，如果我们想要用HashSet集合存储自定义类型的数据，一定要记得覆盖重写hashCode()方法和equals()方法。","link":"/p/332201202005/"},{"title":"Java 中的四种权限修饰符","text":"@Author: YiHua Lee @Address: Guangdong province, China private Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。 被其修饰的属性以及方法只能被该类的对象 访问，其子类不能访问，更不能允许跨包访问。 default 即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。 该模式下，只允许在同一个包中进行访问。 protected 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。 被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public Java语言中访问限制最宽的修饰符，一般称之为“公共的”。 被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。","link":"/p/381930202004/"},{"title":"Java 中与IO流有关的集合（Properties集合）","text":"@Author: YiHua Lee @Address: Guangdong province, China 属性集java.util.Properties继承于Hashtable，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时, System.getProperties方法就是返回一个Properties对象。 Properties类Properties集合是Hashtable集合的子类，Hashtable类是Map接口的其中一个实现类。Properties集合 是唯一一个和IO流相结合的集合。Properties类表示了一个持久的属性集。 Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 12java.util.Properties extends Hashtable&lt;k, v&gt;java.util.Hashtable implements Map&lt;k, v&gt; 构造方法12345public Properties() { this(null); }// 创建一个空属性列表public Properties(Properties defaults) { this.defaults = defaults; }// 创建一个预设属性列表 基本的存储方法123456public synchronized Object setProperty(String key, String value) { return put(key, value); }// 保存一对属性public String getProperty(String key) { ... }// 使用此属性列表中指定的键搜索属性值public Set&lt;String&gt; stringPropertyNames() { ... }// 所有键的名称的集合 这几个方法的使用：举例 123456789101112131415161718192021222324252627282930import java.util.Iterator;import java.util.Properties;import java.util.Set;public class Demo01Properties { public static void main(String[] args) { method(); } public static void method() { // 创建Properties集合对象，Properties集合可key和value都是String类型 Properties p = new Properties(); // 使用setProperty()方法，往集合中添加数据。该方法相当于Map集合中的put方法 p.setProperty(&quot;程序猿&quot;, &quot;22&quot;); p.setProperty(&quot;攻城狮&quot;, &quot;25&quot;); p.setProperty(&quot;骇客&quot;, &quot;19&quot;); // 使用stringPropertyNames()方法，把Properties集合中所有的键存储到一个Set&lt;String&gt;集合中。 Set&lt;String&gt; s = p.stringPropertyNames(); // 遍历Set集合，取出Properties集合中的每一个值。 Iterator&lt;String&gt; ite = s.iterator(); while ((ite.hasNext())) { String key = ite.next(); String value = p.getProperty(key); System.out.println(key + &quot;=&quot; + value); } }} Properties集合中的store方法和loadstore方法12345678910public void store(Writer writer, String comments)// 把集合中的临时数据，持久化的存储到硬盘中。public void store(OutputStream out, String comments)// 把集合中的临时数据，持久化的存储到硬盘中。参数：Writer writer：字符输出流，可以写中文。OutputStream out：字节输出流，不可以写中文。String comments：注释，用来解释说明保存的文件是做什么用的。不可以使用中文，否则会出现乱码，默认是Unicode编码。一班使用&quot;空字符串&quot;。 举例：把集合中的数据，持久化的存储到硬盘中。 使用步骤： 创建Properties集合对象，添加数据。 创建字节输岀流/字符输岀流对象，构造方法中绑定要输岀的目的地。 使用Properties集合中的方法 store，把集合中的临时数据，持久化写入到硬盘中存。 释放资源。 1234567891011121314151617181920212223242526import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class DemoPropertiesStore { public static void main(String[] args) throws IOException { method(); } public static void method() throws IOException { // 创建Properties集合对象，添加数据。 Properties p = new Properties(); p.setProperty(&quot;程序猿&quot;, &quot;22&quot;); p.setProperty(&quot;攻城狮&quot;, &quot;25&quot;); p.setProperty(&quot;骇客&quot;, &quot;19&quot;); // 创建字符输岀流对象，构造方法中绑定要输岀的目的地。 FileWriter fw = new FileWriter(&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo32/p.txt&quot;); // 使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存。 p.store(fw, &quot;save data&quot;); // 释放资源。 fw.close(); }} 运行结果，生成一个p.txt文件，文件内容如下： load方法123456789public synchronized void load(Reader reader) throws IOException { ... }// 把硬盘中保存到的文件（键值对），读取到集合中使用。public synchronized void load(InputStream inStream) throws IOException { ... }// 把硬盘中保存到的文件（键值对），读取到集合中使用。参数：Reader reader：字符输入流，能读取含有中文的键值对。InputStream inStream：字节输入流，不能读取含有中文的键值对。 举例：把硬盘中保存到的文件（键值对），读取到集合中使用。读取上例中的p.txt文件。 使用步骤： 创建Properties集合对象。 使用Properties集合对象中的方法load，读取保存键值对的文件。 遍历Properties集合，输出。 1234567891011121314151617181920212223242526272829import java.io.FileReader;import java.io.IOException;import java.util.Iterator;import java.util.Properties;import java.util.Set;public class DemoPropertiesLoad { public static void main(String[] args) throws IOException { method(); } public static void method() throws IOException { // 创建Properties集合对象。 Properties p = new Properties(); // 使用Properties集合对象中的方法load，读取保存键值对的文件。 FileReader reader = new FileReader(&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo32/p.txt&quot;); p.load(reader); // 遍历Properties集合，输出。 Set&lt;String&gt; s = p.stringPropertyNames(); Iterator&lt;String&gt; ite = s.iterator(); while (ite.hasNext()) { String key = ite.next(); String value = p.getProperty(key); System.out.println(key + &quot;=&quot; + value); } }} 控制台输出： 123程序猿=22攻城狮=25骇客=19","link":"/p/131803202005/"},{"title":"Java 中序列化流的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 序列化和反序列化的概述Java提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了ー个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存的数据信息，都可以用来在内存中创建对象。 ObjectOutputStream类java.io.ObjectOutputStream类，将Java对象的原始数据类型写出到文件，实现对象的持久存储。 构造方法1234ObjectOutputStream(OutputStream out)// 创建写入指定OutputStream的ObjectOutputStream。参数：OutputStream out：字节输出流 特有的成员方法12public final void writeObject(Object obj)// 将指定的对象写入ObjectOutputStream。 举例：使用ObjectOutputStream类，将Java对象的原始数据类型写出到文件。 使用步骤： 1231.创建ObjectOutputStream对象，构造方法中传递字节输出流。2.使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中。3.释放资源。 定义一个类，存储这个类对象： 在定义之前，需要知道： 类通过实现java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段,仅用于标识可序列化的语义。没有实现这个接口，进行序列化或反序列化，会抛出NotSerializableException异常。 因此，我们需要将Java对象的原始数据写出到文件，那么该对象类必须实现Serializable接口。 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.Serializable;public class Person implements Serializable { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 代码实现： 123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class Demo01ObjectOutputStream { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建ObjectOutputStream对象，构造方法中传递字节输出流。 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo36/person.txt\")); // 使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中。 oos.writeObject(new Person(\"程序猿\", 22)); oos.writeObject(new Person(\"攻城狮\", 25)); // 释放资源。 oos.close(); }} 运行后，生成一个person.txt文件，文件内容如下： 里面存储了Person对象的数据信息。 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法1234ObjectInputStream(InputStream in)// 创建从指定的InputStream读取的ObjectInputStream。参数：InputStream in：字节输入流 特有成员方法12Object readObject()// 从ObjectInputStream读取对象。 举例：使用ObjectInputStream，将上例中的person.txt文件里，被序列化的Person对象数据信息，反序列化为Person对象。 反序列化的前提： 类必须实现Serializable接口。 必须存在对应类的class文件（如本例子中的Person类），如果不存在对应的class文件会抛出ClassNotFoundException异常。 使用步骤： 123456789101112131415161718192021222324252627282930311.创建ObjectInputStream对象，构造方法中传递字节输入流。2.使用ObjectInputStream对象中的方法readObject，读取保存对象的文件。3.释放资源。4.使用读取出来的对象（打印）。import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class Demo01ObjectInputStream { public static void main(String[] args) throws IOException, ClassNotFoundException { method(); } private static void method() throws IOException, ClassNotFoundException { // 创建ObjectInputStream对象，构造方法中传递字节输入流。 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo36/person.txt\")); // 使用ObjectInputStream对象中的方法readObject，读取保存对象的文件。 Object object1 = ois.readObject(); Object object2 = ois.readObject(); // 释放资源。 ois.close(); // 使用读取出来的对象（打印）。 Person person1 = (Person) object1; Person person2 = (Person) object2; System.out.println(person1); System.out.println(person2); }} 控制台输出： 12Person{name='程序猿', age=22}Person{name='攻城狮', age=25} transient关键字序列化操作一个对象要想序列化，必须满足两个条件： 该类必须实现java.io.Serializable接口，Serializable是一个标记接口，不实现此接口的类将不会使任可状态序列化或反序列化，会抛出NotSerializableException。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰。 说到transient关键字，首先说一下static关键字（静态关键字）。静态优先与非静态加载到内存中，即会静态优先于对象加载到内存中，被修饰的静态成员变量是不能被序列化的，序列化的都是对象。 transient关键字：瞬态关键字，被transient关键字修饰的成员变量，不能被序列化。 举例还是上面的两个例子： 不使用static关键字或transient关键字修饰成员变量，结果如上两个例子一样。 假如使用transient关键字修饰age成员变量，其余不更改： 1234567891011121314151617181920212223242526272829303132333435363738public class Person implements Serializable { private String name; private transient int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 那么第一个例子中的person.txt文件内容是这样的： 第二个例子，控制台的输出： 12Person{name='程序猿', age=0}Person{name='攻城狮', age=0} 把transient关键字换成static关键字，效果也是一样的。 InvalidClassException异常及原理假如序列化后，要进行反序列化之前，修改了对应Java对象的类，进行反序列化会抛出java.io.InvalidClassException异常。并且告诉我们，有序列号发生冲突。 如上例中，进行序列化后，把Person类的age修饰符从public修改为private，这个时候进行反序列化，会抛出java.io.InvalidClassException异常，并且还会告诉我们：流类序列号和本地类序列号冲突，即ObjectInputStream类序列号和Person类序列号冲突。 原理如上面的例子： 编译器会把Person.java文件编译生成Person.class文件。又Person类又实现了Serializable接口，这时就会根据Person类的定义，给Person.class文件添加一个序列号（serialVersionUID）。每次修改类的定义，序列号都会发生改变。 进行了序列化后，再进行反序列化的时候，会使用Person.class文件的序列号和Person.txt文件的序列号对比。如果序列号一样，那么反序列化成功，否则反序列化失败，失败后，抛出java.io.InvalidClassException异常。 每次修改类的定义，都会生成新的序列号。这时候，我们可以自行给类添加一个序列号，之后，无论是否对类的定义进行修改，都不会重新生成新的序列号。 如在上例中的Person类中添加： 1private static final long serialVersionUID = 1L; 这时候，无论是否对Person类的定义进行修改，序列号都是1L。 自行添加序列号格式： 1[修饰符] static final long serialVersionUID = 自定义序列号值; 练习：序列化集合当我们想要在文件中保存多个对象的时候，可以把对象存储到一个集合中，然后对集合进行序列化和反序列化。 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt，遍历集合，打印对象信息。 创建一个Person类 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.Serializable;public class Person implements Serializable { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中： 12345678910111213141516171819202122232425262728293031323334import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.ArrayList;public class DemoArrayPersonSerializable { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建ObjectOutputStream对象，构造方法中传递字节输出流。 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo36/list.txt\")); // 创建ArrayList集合对象 ArrayList&lt;Person&gt; personArrayList = new ArrayList&lt;&gt;(); /vate static void method() throws IOException, ClassNotFoundException { // 创建ObjectInputStream对象，构造方法中传递字节输入流。 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo36/list.txt\")); // 使用ObjectInputStream对象中的方法readObject，读取保存对象的文件。 Object object = ois.readObject(); // 释放资源。 ois.close(); // 使用读取出来的对象（打印）。 ArrayList&lt;Person&gt; personArrayList = (ArrayList) object; for (Person person : personArrayList) { System.out.println(person); } }} 控制台输出： 123Person{name='程序猿', age=22}Person{name='攻城狮', age=25}Person{name='骇客', age=19} /","link":"/p/231803202005/"},{"title":"Java 中的注解","text":"@Author: YiHua Lee @Address: Guangdong province, China 注解概述注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 简单来说，就是说明程序的。给计算机看的。这里要说一下注释：用文字描述程序的。给程序员看的。 作用分类 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 JDK中预定义的一些注解@Override检测被该注解标注的方法是否是继承自父类(接口)的 上例中，该类继承了父类Object类，重写了toString()方法，用@Override注解进行标示。而toString1()方法不是重写其继承的父类、超类或接口中的方法，用@Override注解进行标示，会出现编译错误（Method does not override method from its superclass）。 @Deprecated该注解标注的内容，表示已过时 创建了method1方法，不过后来发现有更好的方式，可以实现method1方法的功能，便创建了method2方法。可是为了method1方法还能使用，便用@Deprecated注解进行标示，标示该方法已经过时了，如果我们继续调用method1方法，如上图所示，方法中出现一条横线。 @SuppressWarnings压制警告 表示在注释元素（以及注释元素中包含的所有程序元素）中应该抑制命名的编译器警告。 请注意，给定元素中抑制的一组警告是所有包含元素中抑制的警告的超集。 例如，如果您注释一个类来抑制一个警告并注释方法来抑制另一个警告，则两个警告将在该方法中被抑制。一般传递参数all —— @SuppressWarnings(“all”) 自定义注解：格式和本质格式1234元注解public @interface 注解名称{ 属性列表;} 本质定义一个注解： 1234567public @interface MyAnnotation { /* 属性：接口中的抽象方法 */ public abstract String method();} 注解本质上就是一个接口，MyAnnotation接口默认继承Annotation接口。接口中可以定义的成员方法是接口的属性。 1public interface MyAnnotation extends java.lang.annotation.Annotation {} public interface Annotation 接口，是所有注释类型扩展的公共接口。 自定义注解：属性定义属性接口中的抽象方法。 要求 属性的返回值类型有下列取值 基本数据类型 String 枚举 123public enum Person { P1, P2} 注解 12public @interface MyAnnotation2 {} 以上数据类型的数组使用的时候： 定义了属性，在使用时需要给属性赋值如：定义一个注解在使用的时候： 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。如：定义一个注解在使用的时候：1、使用默认值：”LeeHua”2、不使用默认值： 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。如：定义一个注解使用的时候：可以省略value，也可以不省略value，如下 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略如：定义一个注解使用的时候，{}可以省略，也可以不省略： 元注解简单来说，元注解就是描述注解的注解。如@Override 这里的@Target和@Retention就是元注解。 四个元注解1234567891011@Target// 描述注解能够作用的位置@Retention// 描述注解被保留的阶段@Documented// 描述注解是否被抽取到api文档中@Inherited// 描述注解是否被子类继承 @Target123456public @interface Target { /** * 返回注释类型可应用于的元素种类的数组。 */ ElementType[] value();} ElementType[] 是一个枚举数组： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 这个枚举类型的常量提供了在Java程序中可能出现注释的句法位置的简单分类。 * 在java.lang.annotation.Target元注释中使用这些常量来指定写入给定类型的 * 注释的合法位置。 */public enum ElementType { /** 类，接口（包括注释类型）或枚举声明 */ TYPE, /** 字段声明（包括枚举常数） */ FIELD, /** 方法声明 */ METHOD, /** 形式参数声明 */ PARAMETER, /** 构造函数声明 */ CONSTRUCTOR, /** 局部变量声明 */ LOCAL_VARIABLE, /** 注释类型声明 */ ANNOTATION_TYPE, /** 包声明 */ PACKAGE, /** * 类型参数声明 * * @since 1.8 */ TYPE_PARAMETER, /** * 使用类型 * * @since 1.8 */ TYPE_USE} 举例自定义一个注解： 1234567import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(ElementType.TYPE) // 表示MyAnnotation7注解只能作用于类上public @interface MyAnnotation7 {} 该注解的使用： 在这里，MyAnnotation7注解作用在类上是可以的。不过，作用在方法上，或成员变量上、方法上、… … ，是不可以的。 假如想要作用于成员变量上、方法上、… … ，可以根据public enum ElementType { … … } 在调用元注解的注解上进行添参，从而实现更多的作用域，如： 1234567import java.lang.annotation.ElementType;@Target(ElementType.TYPE, , ElementType.METHOD, ElementType.FIELD) // 表示MyAnnotation7注解能作用于类、方法、成员变量上public @interface MyAnnotation7 {} @Retention123456789@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention { /** * @return 保留策略。 */ RetentionPolicy value();} RetentionPolicy[] 是一个枚举数组： 1234567891011121314151617/** * 注释保留策略。 此枚举类型的常量描述了用于保留注释的各种策略。 它们 * 与@Retention元注释类型一起使用，以指定将保留注释多长时间。 */public enum RetentionPolicy { /** 注释将被编译器丢弃。 */ SOURCE, /** 注释将由编译器记录在类文件中，但JVM不需要在运行时保留。 */ CLASS, /** * 注释将由编译器记录在类文件中，并由JVM在运行时保留，因此可以反射读取。 * @see java.lang.reflect.AnnotatedElement */ RUNTIME} 举例1234567import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME) // 当前被描述的注解（MyAnnotation8），会保留到class字节码文件中，并被JVM读取到public @interface MyAnnotation8 {} @Documented123456789/** * 表示具有类型的注释默认情况下由javadoc和类似工具记录。 * 即：描述注解是否被抽取到api文档中 */ @Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented {} 举例自定义一个注解： 1234567891011121314151617import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.annotation.ElementType;import java.lang.annotation.Documented;@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})// 表示MyAnnotation7注解能作用于类、方法、成员变量上@Retention(RetentionPolicy.RUNTIME)// 当前被描述的注解（MyAnnotation8），会保留到class字节码文件中，并被JVM读取到@Documented// 描述注解会被抽取到api文档中public @interface MyAnnotation9 {} 使用该注解： 12345678910@MyAnnotation9public class Demo09Annotation { private String name = \"LeeHua\"; @MyAnnotation9 public void method() { }} 在终端，进行编译： 12cd /Users/liyihua/IdeaProjects/Study/src/view/study/demo47/javadoc Demo09Annotation.java javadoc编译完成后，生成一大堆文件： Google浏览器打开index-all.html文件，可以查看被抽取到API文档中的描述： @Inherited123456/** 描述注解是否被子类继承 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {} 举例自定义一个注解： 1234567891011121314151617181920import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.annotation.ElementType;import java.lang.annotation.Documented;import java.lang.annotation.Inherited;@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})// 表示MyAnnotation7注解能作用于类、方法、成员变量上@Retention(RetentionPolicy.RUNTIME)// 当前被描述的注解（MyAnnotation8），会保留到class字节码文件中，并被JVM读取到@Documented// 描述注解会被抽取到api文档中@Inherited// 描述注解是否被子类继承public @interface MyAnnotation10 {} 父类使用这个注解： 1234@MyAnnotation10public class Demo09Annotation {} 子类继承父类： 123public class Demo10Annotation extends Demo09Annotation {} 在@Inherited注解描述的情况下，父类使用了@MyAnnotation10注解，子类继承父类，也会使用@MyAnnotation10注解。 案例一需求写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 实现之前，定义Person.java、Student.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package view.study.demo48;public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public void personMethod() { System.out.println(\"我是Person中的方法！！！\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}package view.study.demo48;public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public void studentMethod() { System.out.println(\"我是Student中的方法！！！\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 实现定义一个注解： 12345678910111213141516package view.study.demo48;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE) // 注解能作用于类上@Retention(RetentionPolicy.RUNTIME) // 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到public @interface pro { public abstract String className(); public abstract String methodName();} 定义实现类： 1234567891011121314151617181920212223242526272829303132333435363738394041package view.study.demo48;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * 写一个\"框架\"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 利用：反射、注解实现 */@pro(className = \"view.study.demo48.Person\", methodName = \"personMethod\")public class Demo01Reflection { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { // 1. 解析注解 // 1.1 获取Demo01Reflection类的字节码文件对象 Class&lt;Demo01Reflection&gt; drClass = Demo01Reflection.class; // 2. 获取上边的注解对象：@pro(className = \"view.study.demo48.Person\", methodName = \"personMethod\") pro annotation = drClass.getAnnotation(pro.class); // 3. 调用注解中定义的抽象方法，获取返回值 // 3.1 获取className String className = annotation.className(); // 3.2 获取methodName String methodName = annotation.methodName(); // 4. 加载该类（获取到的类）进内存 Class&lt;?&gt; aClass = Class.forName(className); // 5. 创建对象 Object object = aClass.newInstance(); // 6. 获取方法对象 Method method = aClass.getMethod(methodName); // 7. 执行方法 method.invoke(object); }} 第二步： 12345678910111213// 第二步其实就是在内存中生成了一个该注解接口的子类实现对象public class proImpl implements pro { // 实现pro接口中的className()方法和methodName()方法 public String className() { return className; } public String methodName() { return methodName; }} 运行程序，控制台输出： 1我是Person中的方法！！！ 修改注解中的className、methodName： 1@pro(className = \"view.study.demo48.Student\", methodName = \"studentMethod\") 再次运行程序，控制台输出： 1我是Student中的方法！！！ 案例二需求利用反射、注解，写一个简单的测试框架，当主方法执行后，会自动加载被检测的所有方法，判断是否有异常，并记录到文件中。注解名称是@Check 被测试的方法如下： 123456789101112131415161718192021222324252627282930313233package view.study.demo48;public class Calculator { /** 加法 */ @Check public int add(int a, int b) { return a + b; } /** 减法 */ @Check public int sub(int a, int b) { return a - b; } /** 乘法 */ @Check public int mul(int a, int b) { return a * b; } /** 除法 */ @Check public int div(int a, int b) { return a / b; } public void method() { System.out.println(\"永无bug！！！\"); }} 实现自定义一个注解： 1234567891011package view.study.demo48;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME) // 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到@Target(ElementType.METHOD) // 注解能作用于方法public @interface Check {} 主方法实现类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package view.study.demo48;import java.io.IOException;import java.io.FileWriter;import java.io.BufferedWriter;import java.lang.reflect.Method;public class Demo01Calculator { public static void main(String[] args) throws IOException { // 1. 创建计算器对象 Calculator calculator = new Calculator(); // 2. 通过计算器对象，获取字节码文件 Class&lt;? extends Calculator&gt; aClass = calculator.getClass(); // 3. 通过字节码文件，获取calculator中所有的方法 Method[] methods = aClass.getDeclaredMethods(); // 4. 定义异常出现的次数、创建字符缓冲输入流 int count = 0; BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(\"bug.txt\", true)); // 5. 判断方法上是否有\"@Check\"注解 for (Method method : methods) { if (method.isAnnotationPresent(Check.class)) { try { // 6. 如果方法上有\"@Check\"注解，那么执行该方法 method.invoke(calculator, 1, 0); } catch (Exception e) { // 7. 捕获异常，记录到文件中 count ++; bufferedWriter.newLine(); bufferedWriter.write(\"被测试的方法：\" + method.getName() + \"，该方法出现异常。\"); bufferedWriter.newLine(); bufferedWriter.write(\"异常的名称：\" + e.getCause().getClass().getSimpleName()); bufferedWriter.newLine(); bufferedWriter.write(\"异常的原因：\" + e.getCause().getMessage()); bufferedWriter.newLine(); } } } bufferedWriter.write(\"本次测试一共出现了\" + count + \"次异常。\"); bufferedWriter.newLine(); bufferedWriter.write(\"====================================\"); // 8. 释放BufferedWriter资源 bufferedWriter.flush(); bufferedWriter.close(); }} 运行主方法，bug.txt文件中会写入一定的内容，内容如下： 12345被测试的方法：div，该方法出现异常。异常的名称：ArithmeticException异常的原因：/ by zero本次测试一共出现了1次异常。==================================== 分析： 要被检测的方法有四个，分别是：加法、减法、乘法、除法。 主方法中传入的参数a、b是：1和0 很明显，1除0，是无意义的，所以div方法出现异常，异常名称是：ArithmeticException 其他方法没有出现异常。所以出现的异常次数是：1","link":"/p/191106202005/"},{"title":"Java 中的函数式接口","text":"@Author: YiHua Lee @Address: Guangdong province, China 概念函数式接口在Java中是指：有且仅有一个抽象方法的接口。 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。 备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。 格式只要确保接口中有且仅有一个抽象方法即可： 12345修饰符 interface 接口名称 { public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容 ......} 由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单： 123修饰符 interface 接口名称 { 返回值类型 方法名称(可选参数信息);} @FunctionalInterface注解与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解: @FunctionalInterface 。该注 解可用于一个接口的定义上： 1234@FunctionalInterfacepublic interface MyFunctionalInterface { void method();} 一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。 自定义函数式接口12345678910111213141516171819@FunctionalInterfacepublic interface MyFunctionalInterface { /** * 接口中唯一的抽象方法 */ public abstract void myMethod();}public class DemoFunctionalInterface { public static void main(String[] args) { method( () -&gt; System.out.println(\"Lambda 执行啦！！！\") ); } private static void method(MyFunctionalInterface fi) { // 调用函数式接口中的方法 fi.myMethod(); }} 控制台输出： 1Lambda 执行啦！！！","link":"/p/111404202005/"},{"title":"Java 中的打印流","text":"@Author: YiHua Lee @Address: Guangdong province, China 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输岀方式。 PrintStream类PrintStream类，为其他输出流添加了功能，使他们能够方便的打印各种数据值表示格式。 PrintStream类的特点： 只负责数据的输出，不负责数据的读取。 与其他输出流不同，PrintStream永远不会抛出IOException异常。 特有方法：print()、println() 构造方法12PrintStream(String fileName)// 使用指定的文件名创建一个新的打印流。 继承自父类的方法PrintStream extends OutputStream 12345678910111213141、public abstract void write(int b) throws IOException;// 将指定的字节输出流。2、public void write(byte b[]) throws IOException{...};// 将b.length字节从指定的字节数组写入此输出流。3、public void write(byte b[], int off, int len) throws IOException{...};// 从指定的字节数组写入len字节,从偏移量off开始输出到此输出流。4、public void flush() throws IOException{};// 刷新此输出流并强制任何缓冲的输出字节被写出。5、public void close() throws IOException {};// 关闭此输出流并释放与此流相关联的任何系统资源。 说明： 如果使用继承父类的write方法写数据，那么查询数据的时候，会查询编码表。 如果使用自身特有的print方法、println方法写数据，那么写的数据会原样输出。 举例：往print.txt空文件中写入数据 1234567891011121314151617import java.io.FileNotFoundException;import java.io.PrintStream;public class DemoPrintStream { public static void main(String[] args) throws FileNotFoundException { // 创建PrintStream对象，传入输出的路径，路径需要存在，否则会抛出FileNotFoundException异常 PrintStream ps = new PrintStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo37/print\"); // 使用父类OutputStream的write方法，写入数据 ps.write(97); // 使用自身特有的方法，写入数据 ps.print(97); // 释放资源 ps.close(); }} print.txt文件内容如下： 数据a是使用父类中的write方法写入的。数据97是使用自身特有方法写入的。 练习：改变输出语句的目的地分析：输出语句，默认是在控制台输出，使用System.setOut方法，可以改变输出语句的目的地。 12345static void setOut(PrintStream out)// 将输出语句的目的地，改变为参数中传递的打印流的目的地。参数：PrintStream out：打印流对象 代码实现： 1234567891011121314151617import java.io.FileNotFoundException;import java.io.PrintStream;public class DemoSetOut { public static void main(String[] args) throws FileNotFoundException { // 在控制台输出 System.out.println(\"我是在控制台输出的！！！\"); // 在空的setOut.txt文件中输出 PrintStream ps = new PrintStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo37/setOut\"); System.setOut(ps); System.out.println(\"我是在setOut.txt文件中输出的！！！\"); // 释放资源 ps.close(); }} 控制台输出： 1我是在控制台输出的！！！ setOut.txt文件内容： 1我是在setOut.txt文件中输出的！！！","link":"/p/261803202005/"},{"title":"Java 使用FileFilter过滤器对文件进行搜索","text":"@Author: YiHua Lee @Address: Guangdong province, China FileFilter概述 java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter filter)作为参数，FileFilter接口中只有一个方法。 boolean accept(File pathname):测试pathname是否应该包含在当前File目录中，符合则返回true。FileFilter接口 1234567891011public interface FileFilter { /** * 测试指定的抽象路径名是否应包含在路径名列表中。 * * @param pathname 要测试的抽象路径名 * @return &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;pathname&lt;/code&gt; * should be included */ boolean accept(File pathname);} 举例递归查看某文件夹中以.java为后缀的文件 定义FileFilter接口的实现类，规定筛选规则 1234567891011121314151617181920import java.io.File;import java.io.FileFilter;public class FileFilterImp implements FileFilter { /** * 过滤规则： * accept方法中，判断file对象是否是以.java结尾， * 如果是，返回true，否则返回false * @param pathname file传递过来的路径名称 * @return true or false */ @Override public boolean accept(File pathname) { if (pathname.isDirectory()) { return true; } return pathname.getName().endsWith(\".java\"); }} 定义筛选方法并测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.File;import java.io.FileFilter;public class Demo01FileFilter { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo29\"); ergodic1(file); System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\"); FileFilterImp filter = new FileFilterImp(); ergodic2(file, filter); } /** * 过滤掉不是.java为后缀的文件名 * @param file 文件或目录 */ public static void ergodic1(File file) { // 是否存在该目录或文件 if (file.exists()) { // 存在该目录或文件，获取该目录下的所有目录和文件 File[] files = file.listFiles(); // 遍历该目录下的文件或目录 assert files != null; for (File f : files) { // 该目录下，如果是目录，使用递归。如果是文件，直接输出。 if (f.isDirectory()) { ergodic1(f); } else if (f.getName().endsWith(\".java\")) { System.out.println(f.getName()); } } } else { if (file.isFile()) { System.out.println(\"不存在该文件\"); } else { System.out.println(\"不存在该目录\"); } } } public static void ergodic2(File file, FileFilter filter) { if (file.exists()) { File[] files = file.listFiles(filter); for (File f : files) { if (f.isDirectory()) { ergodic2(f, filter); } else { System.out.println(f.getName()); } } } else { if (file.isFile()) { System.out.println(\"不存在该文件\"); } else { System.out.println(\"不存在该目录\"); } } }} 控制台输出 12345FileFilterImp.javaDemo01FileFilter.java+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++FileFilterImp.javaDemo01FileFilter.java 例子优化1 1234567891011121314151617181920// 使用匿名内部类public class Demo01FileFilter { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo29\"); ergodic2( file, new FileFilter() { @Override public boolean accept(File pathname) { if (pathname.isDirectory()) { return true; } return pathname.getName().endsWith(\".java\"); } } ); }} 控制台输出 12FileFilterImp.javaDemo01FileFilter.java 例子优化2 1234567891011121314151617181920212223242526272829303132import java.io.File;// 由于FileFilter接口中只有一个抽象方法，所以可以使用Lambda表达式简化// 接口实现类，这样也可以不用定义接口实现类，而且比匿名内部类更简洁public class Demo02FileFilter { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo29\"); ergodic(file); } public static void ergodic(File file) { if (file.exists()) { File[] files = file.listFiles( (File pathname) -&gt; {return pathname.getName().endsWith(\".java\") || new File(String.valueOf(pathname)).isDirectory();} ); assert files != null; for (File f : files) { if (f.isDirectory()) { ergodic(f); } else { System.out.println(f.getName()); } } } else { if (file.isFile()) { System.out.println(\"不存在该文件\"); } else { System.out.println(\"不存在该目录\"); } } }} 控制台输出 123FileFilterImp.javaDemo02FileFilter.javaDemo01FileFilter.java 其中优化2中还可以进一步优化（对lambda表达式进行优化） 123456789101112131415161718192021222324252627282930import java.io.File;public class Demo03FileFilter { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo29\"); ergodic(file); } public static void ergodic(File file) { if (file.exists()) { File[] files = file.listFiles( pathname -&gt; pathname.getName().endsWith(\".java\") || new File(String.valueOf(pathname)).isDirectory() ); assert files != null; for (File f : files) { if (f.isDirectory()) { ergodic(f); } else { System.out.println(f.getName()); } } } else { if (file.isFile()) { System.out.println(\"不存在该文件\"); } else { System.out.println(\"不存在该目录\"); } } }} 控制台输出 1234FileFilterImp.javaDemo02FileFilter.javaDemo03FileFilter.javaDemo01FileFilter.java","link":"/p/401703202005/"},{"title":"Java 内部类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 内部类 什么是内部类：一个类里面包含另一个类 内部类分类：成员内部类、局部内部类（包含匿名内部类） 成员内部类的定义和使用 内部类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package view.study.demo5;/** * @Author: YiHua Lee * * 成员内部类的定义格式： * 修饰符 class 外部类名称 { * 修饰符 class 内部类名称 { * // ... * } * // ... * } * * 注意： * 内部类调用外部类，可以随意访问。 * 外部类调用内部类，需要借助内部类对象才可以访问内部类。 * */public class Body { /** * 内部类 */ public static class Heart { /** * 内部类方法 */ public void beat() { System.out.println(\"心脏，蹦蹦跳\"); System.out.println(name); // 内部类调用外部类，可以随意访问。 System.out.println(Body.getName()); Body.setName(\"胃\"); } } /** * 外部类成员变量 */ private static String name; /** * 外部类方法 */ public void methodBody() { System.out.println(\"身体，哈哈哈\"); } public static String getName() { return name; } public static void setName(String name) { Body.name = name; }} 如何使用成员内部类 间接方式：在外部类当中使用内部类，然后main只是调用外部类方法。 直接方式 内部类的同名变量访问 局部内部类的定义12345678910111213141516171819202122232425262728293031/** * @Author: YiHua Lee * * 局部内部类： * 定义格式： * 修饰符 class 类名称 { * 修饰符 返回值类型 方法名称(参数列表) { * class 局部内部类名称 { * // 方法体... * } * } * // ... * } */public class Outer1 { public void method() { // 局部内部类 class Inner { int num = 10; public void method() { System.out.println(num); } } new Inner().method(); // 只能在这个方法里面调用这个类 }}// 如果一个类定义在方法的内部，那么这个类就是一个局部内部类。// 且这个类只能在方法内部使用，出了该方法，就不能用了。 局部内部类的final问题局部内部类注意事项： 局部内部类是在方法内部的嘛，如果希望所在方法的局部变量，那么这个局部变量必须有【final关键词】备注： 从Java 8+ 开始，只要局部变量事实不变，那么可以省略关键词 final原因： （1）new出来的对象是在堆内存中的， （2）局部变量是跟着方法走的，在栈内存中， （3）而方法运行结束之后，就会立刻出栈，局部变量也就会立刻消失， （4）但是new出来的对象会在堆内存中持续存在，知道垃圾回收消失。 匿名内部类的定义及使用实例理解 123public interface anonymousInterface01 { public abstract void method() ;} 12345678public class InterfaceImplements implements anonymousInterface01 { @Override public void method() { System.out.println(\"实现类覆盖重写接口的抽象方法\"); }} 12345678910111213141516171819public class Demo01Anonymous { public static void main(String[] args) { // 多态方式创建对象 anonymousInterface01 obj1 = new InterfaceImplements(); // 调用实现类覆盖重写的接口的方法 obj1.method(); // 假如接口的实现类（或父类的子类）只需要使用唯一一次， // 那么这种情况下就可以省略实现类（或子类）的定义，而改为使用匿名内部类。 anonymousInterface01 obj2 = new anonymousInterface01() { @Override public void method() { System.out.println(\"我就使用一次，就不定义实现类了哈!!!\"); } }; // 调用匿名类覆盖重写的接口的方法 obj2.method(); }} 匿名内部类的注意事项对于匿名内部类 假如接口的实现类（或父类的子类）只需要使用唯一一次，那么这种情况下就可以省略实现类（或子类）的定义，而改为使用【匿名内部类】。 如果希望使用多次，那么就需要创建单独的实现类（或子类）了。 使用格式 1234567接口名称 对象名 = new 接口名称() { // ...}或new 父类名称(参数列表) { // ...} 对 new 接口名称() {…} 的理解 new 代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {…} 是匿名内部类的内容 注意 匿名内部类只能使用唯一一次 要使用多次，请创建实现类（或子类） 类作为成员变量类型实例理解 1234567891011121314151617181920212223public class Weapon { /** * 英雄武器代号 */ private String code; public Weapon() { } public Weapon(String code) { this.code = code; } public String getCode() { return code; } public void setCode(String code) { this.code = code; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Hero { /** * 英雄名字 */ private String name; /** * 英雄的年龄 */ private int age; /** * 英雄的武器 */ private Weapon weapon; public Hero() { } public Hero(String name, int age, Weapon weapon) { this.name = name; this.age = age; this.weapon = weapon; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Weapon getWeapon() { return weapon; } public void setWeapon(Weapon weapon) { this.weapon = weapon; } public void attack() { System.out.println(\"年龄为 \" + age + \" 岁的 \" + name + \" 正在使用 \" + weapon.getCode() + \" 突突突~~ \" + \"敌人\"); }} 12345678910111213141516public class DemoMain { public static void main(String[] args) { // 创建英雄 Hero hero = new Hero(); hero.setName(\"斯沃特\"); hero.setAge(27); // 给英雄配备武器 Weapon weapon = new Weapon(); weapon.setCode(\"AK-47(火麒麟)\"); hero.setWeapon(weapon); hero.attack(); }} 接口作为成员变量类型实例理解 1234567891011121314151617181920212223public class Weapon { /** * 英雄武器代号 */ private String code; public Weapon() { } public Weapon(String code) { this.code = code; } public String getCode() { return code; } public void setCode(String code) { this.code = code; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Hero { /** * 英雄名字 */ private String name; /** * 英雄的年龄 */ private int age; /** * 英雄的武器 */ private Weapon weapon; public Hero() { } public Hero(String name, int age, Weapon weapon) { this.name = name; this.age = age; this.weapon = weapon; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Weapon getWeapon() { return weapon; } public void setWeapon(Weapon weapon) { this.weapon = weapon; } public void attack() { System.out.println(\"年龄为 \" + age + \" 岁的 \" + name + \" 正在使用 \" + weapon.getCode() + \" 突突突~~ \" + \"敌人\"); }} 12345678910111213141516public class DemoMain2 { public static void main(String[] args) { // 创建英雄 Hero hero = new Hero(); hero.setName(\"斯沃特\"); hero.setAge(27); // 给英雄配备武器 Weapon weapon = new Weapon(); weapon.setCode(\"AK-47(火麒麟)\"); hero.setWeapon(weapon); hero.attack(); }} 接口作为方法的参数或返回值实例理解 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.List;/** * @Author: YiHua Lee * @CreateTime: 2019/12/18 21:12 */public class DemoArrayList { public static void main(String[] args) { // ArrayList&lt;E&gt; 类是 List&lt;E&gt; 接口的实现类 // 这里创建对象有使用多态的写法 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加内容进集合 addList(arrayList); addList(list); // 遍历输出 arrayList for (int i = 0; i &lt; arrayList.size(); i++) { System.out.println(arrayList.get(i)); } System.out.println(\"===========================\"); // 遍历输出 list for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } } public static List&lt;String&gt; addList(List&lt;String&gt; list) { list.add(\"大哥\"); list.add(\"二哥\"); list.add(\"三哥\"); list.add(\"四哥\"); return list; }}","link":"/p/531501202005/"},{"title":"Java 函数式编程","text":"@Author: YiHua Lee @Address: Guangdong province, China 在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。 下面我们做一个初探。 Lambda的延迟执行有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 作为解决方案，提升性能。 性能浪费的日志案例1注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出： 123456789101112131415public class Demo01Logger { public static void main(String[] args) { String msgA = \"Hello \"; String msgB = \"World \"; String msgC = \"Java\"; log(1, msgA + msgB + msgC); } private static void log(int level, String mgs) { if (level == 1) { System.out.println(mgs); } }} 这段代码存在问题：无论级别 level 是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 1234备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行 字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如: LOGGER.debug(&quot;变量{}的取值为{}。&quot;, &quot;os&quot;, &quot;macOS&quot;) ，其中的大括号 {} 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置;否则不会进行字 符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。 体验Lambda的更优写法使用Lambda必然需要一个函数式接口： 12345678@FunctionalInterfacepublic interface MessageBuilder { /** * 信息生成器 * @return 生成的信息 */ public abstract String builderMessage();} 然后对 log 方法进行改造： 123456789101112131415public class Demo02Logger { public static void main(String[] args) { String msgA = \"Hello \"; String msgB = \"World \"; String msgC = \"Java\"; log(1, () -&gt; msgA + msgB + msgC); } private static void log(int level, MessageBuilder mb) { if (level == 1) { System.out.println(mb.builderMessage()); } }} 改造前后的对比： 这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接;否则三个字符串将不会进行拼接。 证明Lambda的延迟下面的代码可以通过结果进行验证： 123456789101112131415161718public class Demo03Logger { public static void main(String[] args) { String msgA = \"Hello \"; String msgB = \"World \"; String msgC = \"Java\"; log(2, () -&gt; { System.out.println(\"Lambada 执行！\"); return msgA + msgB + msgC; }); } private static void log(int level, MessageBuilder mb) { if (level == 1) { System.out.println(mb.builderMessage()); } }} 这里只是在调用 log 方法的时候，将传入的Lambda稍作修改， 当传入的 level = 1 的时候，控制台输出： 12Lambada 执行！Hello World Java 当传入的 level != 1 的时候，控制台没有输出。 从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 1234567891011121314151617181920212223扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。public class Demo04Logger { public static void main(String[] args) { String msgA = \"Hello \"; String msgB = \"World \"; String msgC = \"Java\"; log(1, new MessageBuilder() { @Override public String builderMessage() { System.out.println(\"Lambada 执行！\"); return msgA + msgB + msgC; } }); } private static void log(int level, MessageBuilder mb) { if (level == 1) { System.out.println(mb.builderMessage()); } }} 使用Lambda作为参数和返回值如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。 Lambda作为参数例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。 匿名内部类作为参数，创建新的线程并执行： 123456789101112131415161718public class Demo01Runnable { public static void main(String[] args) { startThread(new Runnable() { @Override public void run() { System.out.println(\"线程任务执行!\"); } }); } /** * 创建一个新的线程，赋予任务，然后开启线程 * @param runnable 传入Thread类的接口，实现创建新线程 */ private static void startThread(Runnable runnable) { new Thread(runnable).start(); }} 运行程序，控制台输出： 1线程任务执行! Lambda作为参数，创建新的线程并执行： 123456789101112131415public class Demo02Runnable { public static void main(String[] args) { startThread( () -&gt; System.out.println(\"线程任务执行!\") ); } /** * 创建一个新的线程，赋予任务，然后开启线程 * @param runnable 传入Thread类的接口，实现创建新线程 */ private static void startThread(Runnable runnable) { new Thread(runnable).start(); }} 运行程序，控制台输出： 1线程任务执行! Lambda作为返回值类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。 Lambda作为返回值，字符串的长短比较： 12345678910111213141516171819202122import java.util.Arrays;import java.util.Comparator;public class DemoComparator { public static void main(String[] args) { String[] array = { \"abc\", \"ab\", \"a\" }; System.out.println(\"使用比较器比较之前：\" + Arrays.toString(array)); Arrays.sort(array, newComparator()); System.out.println(\"使用比较器比较之后：\" + Arrays.toString(array)); } /** * 字符串a、b的长短比较，自己定义比较器规则，生序排序，字符串长的排在后面。 * @return 布尔值， * a.length() - b.length() &lt; 0 返回 false， * a.length() - b.length() &gt; 0 返回 true， * a.length() = b.length() 返回 0 */ public static Comparator&lt;String&gt; newComparator() { return (a, b) -&gt; a.length() - b.length(); }} 匿名内部类作为返回值，字符串的长短比较： 1234567891011121314151617181920import java.util.Arrays;import java.util.Comparator;public class DemoComparator { public static void main(String[] args) { String[] array = { \"abc\", \"ab\", \"a\" }; System.out.println(\"使用比较器比较之前：\" + Arrays.toString(array)); Arrays.sort(array, newComparator()); System.out.println(\"使用比较器比较之后：\" + Arrays.toString(array)); } public static Comparator&lt;String&gt; newComparator1() { return new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }; }} 运行程序，控制台输出一样： 12使用比较器比较之前：[abc, ab, a]使用比较器比较之后：[a, ab, abc]","link":"/p/141404202005/"},{"title":"Java 向数组中添加一个元素","text":"@Author: YiHua Lee @Address: Guangdong province, China 一般数组是不能添加元素的，因为他们在初始化时就已定好长度了，不能改变长度。 向数组中添加元素思路第一步把 数组 转化为 集合 1list = Arrays.asList(array); 第二步向 集合 中添加元素 1list.add(index, element); 第三步将 集合 转化为 数组 1list.toArray(newArray); 实例将数组转化为集合11234String[] arr = {\"ID\", \"姓名\", \"年龄\"};// 定义数组List&lt;String&gt; list1 = Arrays.asList(arr);// 将数组转化为集合 1 定义需要添加元素的集合21234List&lt;String&gt; list2 = new ArrayList&lt;&gt;();list2.add(\"性别\");list2.add(\"出生日期\");// 定义集合 2 ，并向其中添加元素: 性别、出生日期 定义一个新集合，将集合1、2中的元素添加到新集合123456List&lt;String&gt; titleList = new ArrayList&lt;String&gt;();// 定义新集合titleList.addAll(list1);// 将集合 1 中的元素添加到新集合中titleList.addAll(list2);// 将集合 2 中的元素添加到新集合中 将新集合转化为新数组，输出12345String[] newArr = titleList.toArray(new String[titleList.size()]);// 将新集合转化回新数组System.out.println(Arrays.toString(newArr));// 将数组转化为字符串，输出 实例代码汇总12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * @author liyihua * 数组初始元素: ID 姓名 年龄 * 需要向数组中添加元素: 性别 出生日期 */public class Test4 { public static void main(String[] args){ String[] arr = {\"ID\", \"姓名\", \"年龄\"}; // 定义数组 List&lt;String&gt; list1 = Arrays.asList(arr); // 将数组转化为集合 1 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list2.add(\"性别\"); list2.add(\"出生日期\"); // 定义集合 2 ，并向其中添加元素: 性别、出生日期 List&lt;String&gt; titleList = new ArrayList&lt;String&gt;(); // 定义新集合 titleList.addAll(list1); // 将集合 1 中的元素添加到新集合中 titleList.addAll(list2); // 将集合 2 中的元素添加到新集合中 String[] newArr = titleList.toArray(new String[titleList.size()]); // 将新集合转化回新数组 System.out.println(Arrays.toString(newArr)); // 将数组转化为字符串，输出 }}","link":"/p/211830202004/"},{"title":"Java 初步了解反射机制","text":"@Author: YiHua Lee @Address: Guangdong province, China 反射：框架设计的灵魂 框架： 半成品软件。可以在框架的基础上进行软件开发，简化编码 反射： 将类的各个组成部分封装为其他对象，这就是反射机制 好处： 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 Java在计算机中经历的三个阶段： 获取字节码Class对象的三种方式定义一个Person.java，用于下面的讲解。 1234567891011121314151617181920212223242526272829303132333435363738package view.study.demo44;public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} Class.forName(“类的全称，包括所在包”)Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。 常用之处：多用于配置文件，将类名定义在配置文件中。读取文件，加载类。 12345678910package view.study.demo44;public class DemoForName { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass = Class.forName(\"view.study.demo44.Person\"); System.out.println(aClass); }} 运行程序，控制台输出： 1class view.study.demo44.Person [类名].class类名.class：通过类名的属性class获取。 常用之处：多用于参数的传递。 123456789101112package view.study.demo44.test;import view.study.demo44.Person;public class DemoClass { public static void main(String[] args) { Class&lt;Person&gt; personClass = Person.class; System.out.println(personClass); }} 运行程序，控制台输出： 1class view.study.demo44.Person [对象].getClass()对象.getClass()：getClass()方法在Object类中定义着。 常用之处：多用于对象的获取字节码的方式。 1234567891011package view.study.demo44;public class DemoGetClass { public static void main(String[] args) { Person person = new Person(); Class&lt;? extends Person&gt; personClass = person.getClass(); System.out.println(personClass); }} 运行程序，控制台输出： 1class view.study.demo44.Person 结论上面的三种方式，在一个程序中输出，其实是一样的。 12345678910111213141516171819package view.study.demo44.test;import view.study.demo44.Person;public class Demo01Class { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; class1 = Class.forName(\"view.study.demo44.Person\"); Class&lt;Person&gt; class2 = Person.class; Person person = new Person(); Class&lt;? extends Person&gt; class3 = person.getClass(); System.out.println(class1 == class2); System.out.println(class1 == class3); }} 运行程序，控制台输出： 12truetrue 同一个字节码文件（如Person.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 Class对象获取功能：获取成员变量1234567891011Field[] getFields()// 获取所有public修饰的成员变量Field getField(String name)// 获取指定名称的 public修饰的成员变量Field[] getDeclaredFields()// 获取所有的成员变量，不考虑修饰符Field getDeclaredField(String name) // 获取指定名称的成员变量，不考虑修饰符 定义一个Person.java，用于下面方法的使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package view.study.demo45;public class Person { private String name; private int age; public int a; public int b; public int c; public Person() { } public Person(String name, int age, int a, int b, int c) { this.name = name; this.age = age; this.a = a; this.b = b; this.c = c; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", a=\" + a + \", b=\" + b + \", c=\" + c + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getA() { return a; } public void setA(int a) { this.a = a; } public int getB() { return b; } public void setB(int b) { this.b = b; } public int getC() { return c; } public void setC(int c) { this.c = c; }} getFields()方法12345678910111213141516public class Demo01Reflection { public static void main(String[] args) throws NoSuchFieldException { // 获取Person的Class对象 Class&lt;?&gt; personClass = Person.class; // 获取所有public修饰的成员变量 Field[] fields = personClass.getFields(); for (Field field : fields) { System.out.println(field); } }} 运行程序，控制台输出： 123public int view.study.demo45.Person.apublic int view.study.demo45.Person.bpublic int view.study.demo45.Person.c 假如想要获取：成员变量的初始值（如上例中） 1Object o = field.get(new Person()); 类似的，也可以使用java.lang.Class中的set()方法，为成员变量设置值。 123456789* Field：成员变量* 操作：1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 getField(String name)方法1234567891011121314public class Demo01Reflection { public static void main(String[] args) throws NoSuchFieldException { // 获取Person的Class对象 Class&lt;?&gt; personClass = Person.class; // 获取指定名称的 public修饰的成员变量 Field a = personClass.getField(\"a\"); System.out.println(a); }} 运行程序，控制台输出： 1public int view.study.demo45.Person.a getDeclaredFields()方法12345678910111213141516public class Demo01Reflection { public static void main(String[] args) throws NoSuchFieldException { // 获取Person的Class对象 Class&lt;?&gt; personClass = Person.class; // 获取所有的成员变量，不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField); } }} 运行程序，控制台输出： 12345private java.lang.String view.study.demo45.Person.nameprivate int view.study.demo45.Person.agepublic int view.study.demo45.Person.apublic int view.study.demo45.Person.bpublic int view.study.demo45.Person.c getDeclaredField(String name)方法12345678910111213141516public class Demo01Reflection { public static void main(String[] args) throws NoSuchFieldException { // 获取Person的Class对象 Class&lt;?&gt; personClass = Person.class; // 获取指定名称的成员变量，不考虑修饰符 Field name = personClass.getDeclaredField(\"name\"); Field b = personClass.getDeclaredField(\"b\"); System.out.println(name); System.out.println(b); }} 运行程序，控制台输出： 12private java.lang.String view.study.demo45.Person.namepublic int view.study.demo45.Person.b Class对象获取功能：获取构造方法1234567891011Constructor&lt;?&gt;[] getConstructors()// 返回一个构造函数对象数组，该构造函数对象数组每个元素，都反映Class对象表示的类所对应公共构造函数。Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)// 返回一个构造函数对象，该构造函数对象反映此Class对象表示的类所指定公共构造函数。Constructor&lt;?&gt;[] getDeclaredConstructors()// 返回一个构造函数对象数组，该构造函数对象数组每个元素，都反映Class对象（或interface对象）表示的类所对应公共构造函数。Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)// 返回一个构造函数对象，该构造函数对象反映此Class对象（或interface对象）表示的类所指定公共构造函数。 下面就介绍：getConstructors()方法和getConstructors()方法。剩下两种方法的使用如介绍中方法一致 getConstructor()方法这里例子中，所使用的Person.java，使用的是“获取成员变量”例子中定义的。 12345678910111213141516import java.lang.reflect.Constructor;public class Demo02Reflection { public static void main(String[] args) throws NoSuchMethodException { // 创建Person.class对象 Person person = new Person(\"LeeHua\", 22, 6, 6, 6); // 获取Person的Class对象 Class&lt;?&gt; personClass = person.getClass(); // 获取一个Person.class构造函数对象 Constructor&lt;?&gt; constructor = personClass.getConstructor(); System.out.println(constructor); }} 运行程序，控制台输出： 1public view.study.demo45.Person() getConstructors()方法这里例子中，所使用的Person.java，使用的是“获取成员变量”例子中定义的。 123456789101112131415161718import java.lang.reflect.Constructor;public class Demo02Reflection { public static void main(String[] args) throws NoSuchMethodException { // 创建Person.class对象 Person person = new Person(\"LeeHua\", 22, 6, 6, 6); // 获取Person的Class对象 Class&lt;?&gt; personClass = person.getClass(); // 获取一个Person.class构造函数数组对象 Constructor&lt;?&gt;[] constructors = personClass.getConstructors(); for (Constructor&lt;?&gt; constructor1 : constructors) { System.out.println(constructor1); } }} 运行程序，控制台输出： 12public view.study.demo45.Person()public view.study.demo45.Person(java.lang.String,int,int,int,int) Class对象获取功能：获取成员方法12345678910111213Method[] getMethods()// 返回一个包含{@code Method}对象的数组，这些对象反映此{@code Class}对象表示的类或接口的所有公共方法，包括由类或接// 口声明的方法以及从超类和超接口继承的方法。Method getMethod(String name, 类&lt;?&gt;... parameterTypes)// 返回一个指定的{@code Method}对象，该对象反映此{@code Class}对象表示的类或接口的指定公共成员方法。Method[] getDeclaredMethods()// 返回一个包含{@code Method}对象的数组，这些对象反映了此{@code Class}对象表示的类或接口的所有已声明方法，包括公共，// 受保护，默认（程序包）访问和私有方法，但不包括继承的方法。Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)// 返回一个指定的{@code Method}对象，该对象反映此{@code Class}对象表示的类或接口的指定声明方法。 getMethods()方法123456789101112131415161718package view.study.demo45;import java.lang.reflect.Method;public class Demo03Reflection { public static void main(String[] args) throws NoSuchMethodException { // 创建Person.class对象 Person person = new Person(\"LeeHua\", 22, 6, 6, 6); // 获取Person的Class对象 Class&lt;?&gt; personClass = person.getClass(); // 获取一个包含{@code Method}对象的数组 Method[] methods = personClass.getMethods(); for (Method method : methods) { System.out.println(method.getName()); } }} 运行程序，控制台输出： 12345678910111213141516171819toStringgetNamesetNamegetAgesetAgegetBsetBgetCsetCgetAsetAwaitwaitwaitequalshashCodegetClassnotifynotifyAll 其中红色部分是其父类或其继承的接口的方法。 getMethod(String name, 类&lt;?&gt;… parameterTypes)方法12345678910111213141516package view.study.demo45;import java.lang.reflect.Method;public class Demo03Reflection { public static void main(String[] args) throws NoSuchMethodException { // 创建Person.class对象 Person person = new Person(\"LeeHua\", 22, 6, 6, 6); // 获取Person的Class对象 Class&lt;?&gt; personClass = person.getClass(); // 返回一个指定的{@code Method}对象 Method getAge = personClass.getMethod(\"getAge\"); System.out.println(getAge); }} 运行程序，控制台输出： 1public int view.study.demo45.Person.getAge() getDeclaredMethods()方法1234567891011121314151617package view.study.demo45;import java.lang.reflect.Method;public class Demo03Reflection { public static void main(String[] args) throws NoSuchMethodException { // 创建Person.class对象 Person person = new Person(\"LeeHua\", 22, 6, 6, 6); // 获取Person的Class对象 Class&lt;?&gt; personClass = person.getClass(); Method[] declaredMethods = personClass.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod); } }} 运行程序，控制台输出： 1234567891011public java.lang.String view.study.demo45.Person.toString()public java.lang.String view.study.demo45.Person.getName()public void view.study.demo45.Person.setName(java.lang.String)public int view.study.demo45.Person.getAge()public void view.study.demo45.Person.setAge(int)public int view.study.demo45.Person.getB()public void view.study.demo45.Person.setB(int)public int view.study.demo45.Person.getC()public void view.study.demo45.Person.setC(int)public int view.study.demo45.Person.getA()public void view.study.demo45.Person.setA(int) getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)方法123456789101112131415package view.study.demo45;import java.lang.reflect.Method;public class Demo03Reflection { public static void main(String[] args) throws NoSuchMethodException { // 创建Person.class对象 Person person = new Person(\"LeeHua\", 22, 6, 6, 6); // 获取Person的Class对象 Class&lt;?&gt; personClass = person.getClass(); Method getName = personClass.getDeclaredMethod(\"getName\"); System.out.println(getName); }} 运行程序，控制台输出： 1public java.lang.String view.study.demo45.Person.getName() 案例需求写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 实现之前，定义Person.java、Student.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package view.study.demo46;public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public void personMethod() { System.out.println(\"我是Person中的方法！！！\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}package view.study.demo46;public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public void studentMethod() { System.out.println(\"我是Student中的方法！！！\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 实现步骤 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 实现第一步：创建配置文件——pro.properties，并将需要创建的对象的全类名和需要执行的方法定义在配置文件中 配置文件内容如下： 12className=view.study.demo46.PersonmethodName=personMethod 第二步：在程序中加载获取配置文件** 1234567891011// 1. 在程序中加载读取配置文件// 1.1 创建Properties对象Properties pro = new Properties();// 1.2 加载配置文件，转换为一个集合// 1.2.1 获取类的类加载器ClassLoader classLoader = DemoReflection.class.getClassLoader();// 1.2.2 读取配置文件// InputStream inputStream = classLoader.getResourceAsStream(\"pro.properties\");InputStream inputStream = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo46/pro.properties\");// 1.2.3 加载配置文件pro.load(inputStream); 第三步：获取配置文件中的定义数据 12345// 2. 获取配置文件中定义的数据// 2.1 获取类名称String className = pro.getProperty(\"className\");// 2.2 获取方法名称String methodName = pro.getProperty(\"methodName\"); 第四步：加载该类进内存 12// 3. 加载该类进内存Class&lt;?&gt; aClass = Class.forName(className); 第五步：创建对象 12// 4. 创建对象Object object = aClass.newInstance(); 第六步：获取方法对象 12// 5. 获取方法对象Method method = aClass.getMethod(methodName); 第七步：执行方法 12// 6. 执行方法method.invoke(object); 代码总和： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;public class DemoReflection { public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { // 1. 在程序中加载读取配置文件 // 1.1 创建Properties对象 Properties pro = new Properties(); // 1.2 加载配置文件，转换为一个集合 // 1.2.1 获取类的类加载器 ClassLoader classLoader = DemoReflection.class.getClassLoader(); // 1.2.2 读取配置文件 // InputStream inputStream = classLoader.getResourceAsStream(\"pro.properties\"); InputStream inputStream = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo46/pro.properties\"); // 1.2.3 加载配置文件 pro.load(inputStream); // 2. 获取配置文件中定义的数据 // 2.1 获取类名称 String className = pro.getProperty(\"className\"); // 2.2 获取方法名称 String methodName = pro.getProperty(\"methodName\"); // 3. 加载该类进内存 Class&lt;?&gt; aClass = Class.forName(className); // 4. 创建对象 Object object = aClass.newInstance(); // 5. 获取方法对象 Method method = aClass.getMethod(methodName); // 6. 执行方法 method.invoke(object); }} 运行程序，控制台输出： 1我是Person中的方法！！！ 修改配置文件中的内容： 12className=view.study.demo46.StudentmethodName=studentMethod 运行程序，控制台输出： 1我是Student中的方法！！！ 如此，修改配置文件，不用修改代码。实现了创建任意类的对象，并且执行其中任意方法。","link":"/p/141106202005/"},{"title":"Java 利用Map集合计算一个字符串中每个字符出现的次数","text":"@Author: YiHua Lee @Address: Guangdong province, China 步骤分析 给出一串字符串，字符串中可以包含字母、数字、符号等等。 创建一个Map集合，key是字符串中的字符，value是字符的个数。 遍历字符串，获取每一个字符。 使用获取到的字符，去集合Map判断key(字符)是否存在。 假如key(字符)存在，那么该key对应的value数值增加1，即该字符的数量加一。 假如key(字符)不存在，value的值设为1，并将key-value添加到Map集合中。 遍历Map集合，输出每个字符个数的结果。 代码实现 创建一个CharNumber类，在类中定义keyValue方法，计算字符串中每个字符的个数 12345678910111213141516171819202122232425262728293031public class CharNumber { /** * 计算字符串中每个字符的个数 * @param string 要被计算字符个数的字符串 * @return &lt;字符-个数&gt; 的Map集合 */ public static HashMap&lt;Character, Integer&gt; keyValue(String string) { // 字符串转换为字符数组 char[] chars = string.toCharArray(); // 创建一个Map集合用来存放记录 HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;(); // 遍历字符串，获取每一个字符 for (char c : chars) { // 使用获取到的字符，去Map集合判断key是否存在 // 利用Map集合的containsKey()方法，判断key是否存在 // 如果存在 value ++，如果不存在 value = value if (hashMap.containsKey(c)) { // key存在，获取key对应的value，数值增加一，然后再更新到集合中 Integer value = hashMap.get(c); value ++; hashMap.put(c, value); } else { // key不存在，将key添加到Map集合中，且其对应的value为1 hashMap.put(c, 1); } } return hashMap; }} 创建一个CharNumber类，在类中定义iteratorMap方法，遍历输出计算结果 12345678910111213141516171819public class CharNumber { /** * 遍历输出Map集合 * @param hashMap &lt;字符-个数&gt; 的Map集合 */ public static void iteratorMap(HashMap&lt;Character, Integer&gt; hashMap) { // 调用Map集合的entrySet()方法，获取集合Map的Key-Value，赋值给Set集合 Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; set = hashMap.entrySet(); // 创建Set集合的迭代器 Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; kvIterator = set.iterator(); // 迭代输出Set集合 // hasNext()：是否存在下一个元素 // next()：获取下一个元素 while (kvIterator.hasNext()) { Map.Entry&lt;Character, Integer&gt; kv = kvIterator.next(); System.out.println(\"字符'\" + kv.getKey() + \"'的个数是：\" + kv.getValue()); } }} 测试一下CharNumber类，随便输入一串字符串，计算每个字符的个数 12345678public class DemoCharNumber { public static void main(String[] args) { Scanner scn = new Scanner(System.in); System.out.print(\"请输入一个字符串：\"); String string = scn.next(); CharNumber.iteratorMap(CharNumber.keyValue(string)); }} 运行代码(注意，不能输入空格)： 123456789请输入一个字符串：dafsdaganjsda!!!!!!字符'a'的个数是：4字符'!'的个数是：6字符's'的个数是：2字符'd'的个数是：3字符'f'的个数是：1字符'g'的个数是：1字符'j'的个数是：1字符'n'的个数是：1 代码总和CharNumber类12345678910111213141516171819202122232425262728293031import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class CharNumber { public static HashMap&lt;Character, Integer&gt; keyValue(String string) { char[] chars = string.toCharArray(); HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (char c : chars) { if (hashMap.containsKey(c)) { Integer value = hashMap.get(c); value ++; hashMap.put(c, value); } else { hashMap.put(c, 1); } } return hashMap; } public static void iteratorMap(HashMap&lt;Character, Integer&gt; hashMap) { Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; set = hashMap.entrySet(); Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; kvIterator = set.iterator(); while (kvIterator.hasNext()) { Map.Entry&lt;Character, Integer&gt; kv = kvIterator.next(); System.out.println(\"字符'\" + kv.getKey() + \"'的个数是：\" + kv.getValue()); } }} DemoCharNumber类12345678910import java.util.Scanner;public class DemoCharNumber { public static void main(String[] args) { Scanner scn = new Scanner(System.in); System.out.print(\"请输入一个字符串：\"); String string = scn.next(); CharNumber.iteratorMap(CharNumber.keyValue(string)); }}","link":"/p/070002202005/"},{"title":"Java 包装类的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 包装类的概念Java提供了两个类型系统：基本类型与引用类型。使用基本类型在于效率,然而很多情况,会创建对象使用,因为对象可以做更多的功能,如果想要我们的基本类型像对象一样操作,就可以使用基本类型对应的包装类 如下： 基本类型 对应的包装类（位于java.lang包中）byte Byteshort Shortint Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 基本数据类型使用起来非常方便但是没有对应的方法来操作这些基本类型的数据 可以使用一个类把基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类 我们可以使用类中的方法来操作这些基本类型的数据 装箱与拆箱说明装箱与拆箱： 基本类型与立的包装类对象之间,来回转换的过程称为装箱“与拆箱 装箱:从基本类型转换为对应的包装类对象。 拆箱:从包装类对象转换为对应的基本类型。 实例装箱123456789101112/** * 以Integer为例 * 装箱:把基本类型的数据,包装到包装类中(基本类型的数据-&gt;包装类) * 构造方法: * Integer(int value)构造一个新分配的 Integer对象,它表示指定的int值。 * Integer(String s)构造一个新分配的 Integer对象,它表示 String参数所指示的int值。 * 传递的字符串,必须是基本类型的字符串,否则会抛出昇常 如：\"2018\"正确，\"a\"抛昇常 * 静态方法: * static Integer valueOf(int i)返回一个表示指定的int值的 Integer实例。 * static Integer valueOf( String s)返回保存指定的 String的值的 Integer对象。 * */ 12345678910111213141516171819public class DemoPack { public static void main(String[] args) { // 构造方法： // int Integer integer1 = new Integer(1); System.out.println(\"Integer(int value)：\" + integer1); // string Integer integer2 = new Integer(\"1\"); System.out.println(\"Integer(String s)：\" + integer2); // 静态方法 // int Integer integer3 = Integer.valueOf(1); System.out.println(\"valueOf(int i)：\" + integer3); // string Integer integer4 = Integer.valueOf(\"1\"); System.out.println(\"valueOf(String s)：\" + integer3); }} 12345输出结果：Integer(int value)：1Integer(String s)：1valueOf(int i)：1valueOf(String s)：1 拆箱12345678910111213141516/** * 拆箱:在包装类中取出基本类型的数据(包装类-&gt;基本类型的数据) * 成员方法: * int involve()以int类型返回该Integer的值。 */public class DemoUnpack { public static void main(String[] args) { // 装箱 Integer integer = new Integer(1); System.out.println(\"Integer(int value)：\" + integer); // 拆箱 int i = integer.intValue(); System.out.println(\"int involve()：\" + i); }} 123输出结果：Integer(int value)：1int involve()：1 自动装箱与自动拆箱12345678910111213141516/** * 自动装箱与自动拆箱:基本类型的效据和包装类之间可以自动的相互转换 * JDK1.5之后出现的新特性 */public class DemoPackUnpackAutomatic { public static void main(String[] args) { // 自动装箱:直接把int类型的整数赋值包装类Integer // i = 1;就相当于 Integer i = new Integer(1) Integer i = 1; // 自动拆箱:i是包装类,无法直接参与运算,可以自动转换为基本数据类型,在进行计算 // i + 2 就相当于 i.intValue() + 2 = 3 // i = i.intValue() + 2 = 3 又是一个自动装箱 i = i + 2; }} 基本类型与字符串类型之间的相互转换基本类型转字符串类型1234567891011121314151617181920212223242526/** * 基本类型与字符串类型之间的相互转换 * 基本类型-&gt;字符串( string) * 1.基本类型的值 + \"\" * 2.包装类的静态方法 toString(参数),不是Object类的toString() * 如 static string toString(int)返回一个表示指定整数的string对象。 * 3.string类的静态方法 valueOf(参数) * 如 static String valueOf(int i)返回int参数的字符串表示形式。 */public class DemoType { public static void main(String[] args) { // 基本类型-&gt;字符串( string) int i1 = 666; String s1 = i1 + \"\"; s1 = s1 + 999; System.out.println(\"string1 = \" + s1); String s2 = Integer.toString(666); s2 = s2 + 999; System.out.println(\"string2 = \" + s2); String s3 = String.valueOf(666); s3 = s3 + 999; System.out.println(\"string3 = \" + s3); }} 1234输出结果：string1 = 666999string2 = 666999string3 = 666999 字符串类型转基本类型123456789101112131415161718/** * 字符串(string)-&gt;基本类型 * 使用包装类的静态方法 parseXXX(\"字符串\") * 如： Integer类: static int parseInt(String s) * Double类: static double parseDouble(String s) */public class DemoType2 { public static void main(String[] args) { // 基本类型-&gt;字符串( string) int i1 = 666; String s1 = i1 + \"\"; // 字符串(string)-&gt;基本类型 int i = Integer.parseInt(s1); i = i + 999; System.out.println(\"Integer.parseInt(Strong s) = \" + i); }} 12输出结果：Integer.parseInt(String s) = 1665","link":"/p/301801202005/"},{"title":"Java 增强for循环的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China foreach概述增强for循环：底层使用的是送代器,使用for循环的格式，简化了送代器的书写，foreach是JDK1.5之后出现的新特性 使用增强for循环遍历集合123456789/** * 遍历集合 * @param arrayList 集合 */public static void demoCollection(ArrayList&lt;String&gt; arrayList) { for (String string: arrayList) { System.out.println(string); }} 1234567891011121314public class DemoForEach { public static void main(String[] args) { ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(\"集合1号\"); arrayList.add(\"集合2号\"); arrayList.add(\"集合3号\"); arrayList.add(\"集合4号\"); arrayList.add(\"集合5号\"); // 遍历集合 demoCollection(arrayList); }} 123456输出结果：集合1号集合2号集合3号集合4号集合5号 遍历数组123456789/** * 遍历数组 * @param strings 数组 */public static void demoArray(String[] strings) { for (String string: strings) { System.out.println(string); }} 12345678public class DemoForEach { public static void main(String[] args) { String[] strings = {\"数组1号\", \"数组2号\", \"数组3号\", \"数组4号\", \"数组5号\"}; // 遍历数组 demoArray(strings); }} 123456输出结果：数组1号数组2号数组3号数组4号数组5号","link":"/p/581801202005/"},{"title":"Java 多态的简单理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 多态的格式与使用 多态中成员变量的使用 多态中成员方法的使用 使用多态的好处 对象的向上转型 对象的向下转型 instanceof 关键词的使用【向下转型使用instanceof关键词】 笔记本USB接口案例","link":"/p/251930202004/"},{"title":"Java 常用函数式接口之Consumer接口","text":"@Author: YiHua Lee @Address: Guangdong province, China JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的Consumer接口及使用示例。 Consumer接口 概述123456789101112131415@FunctionalInterfacepublic interface Consumer&lt;T&gt; { /** * 对给定参数执行消费操作。 * * @param t 输入参数 */ void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; { accept(t); after.accept(t); }; }} java.util.function.Consumer 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。 抽象方法：acceptConsumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如： 1234567891011import java.util.function.Consumer;public class Demo01Consumer { public static void main(String[] args) { consumerString(s -&gt; System.out.println(s)); } private static void consumerString(Consumer&lt;String&gt; function) { function.accept(\"Hello\"); }} 运行程序，控制台输出： 1Hello 当然，更好的写法是使用方法引用。 默认方法：andThen如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果:消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。 123456default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; { accept(t); after.accept(t); };}备注: java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。 要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组 合的情况： 12345678910111213141516import java.util.function.Consumer;public class Demo02Consumer { public static void main(String[] args) { consumerString( // toUpperCase()方法，将字符串转换为大写 s -&gt; System.out.println(s.toUpperCase()), // toLowerCase()方法，将字符串转换为小写 s -&gt; System.out.println(s.toLowerCase()) ); } private static void consumerString(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two) { one.andThen(two).accept(\"Hello\"); }} 运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。 12HELLOhello 练习：格式化打印信息题目下面的字符串数组当中存有多条信息，请按照格式“ 姓名:XX。性别:XX。 ”的格式将信息打印出来。要求将打印姓 名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实 例，将两个 Consumer 接口按照顺序“拼接”到一起。 1String[] array = { \"大雄，男\", \"静香，女\", \"胖虎，男\" }; 解答12345678910111213141516171819import java.util.function.Consumer;public class DemoPrintInfo { public static void main(String[] args) { String[] array = { \"大雄，男\", \"静香，女\", \"胖虎，男\" }; printInfo( s -&gt; System.out.print(\"姓名：\" + s.split(\"，\")[0] + \"，\"), s -&gt; System.out.println(\"性别：\" + s.split(\"，\")[1] + \"。\"), array ); } private static void printInfo(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two, String[] array) { for (String info : array) { one.andThen(two).accept(info); } }} 运行程序，控制台输出： 123姓名：大雄，性别：男。姓名：静香，性别：女。姓名：胖虎，性别：男。","link":"/p/191404202005/"},{"title":"Java 常用函数式接口之Function接口","text":"@Author: YiHua Lee @Address: Guangdong province, China JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的Function接口及使用示例。 Function接口概述java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。 12345@FunctionalInterfacepublic interface Function&lt;T, R&gt; { R apply(T t); ......} 抽象方法：applyFunction 接口中最主要的抽象方法为: R apply(T t) ，根据类型T的参数获取类型R的结果。 使用的场景例如:将 String 类型转换为 Integer 类型。 12345678910111213import java.util.function.Function;public class DemoFunctionApply { public static void main(String[] args) { method(s -&gt; Integer.parseInt(s)); } private static void method(Function&lt;String, Integer&gt; function) { int num = function.apply(\"10\"); System.out.println(num + 20); }} 运行程序，控制台输出： 130 当然，最好是通过方法引用的写法。 默认方法：andThenFunction 接口中有一个默认的 andThen 方法，用来进行组合操作。JDK源代码如： 1234default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t));} 该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多: 12345678910111213141516import java.util.function.Function;public class DemoFunctionAndThen { public static void main(String[] args) { method( str -&gt; Integer.parseInt(str)+10, i -&gt; i *= 10 ); } private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) { int num = one.andThen(two).apply(\"10\"); System.out.println(num + 20); }} 运行程序，控制台输出： 1220 第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。 1请注意，Function的前置条件泛型和后置条件泛型可以相同。 练习:自定义函数模型拼接题目请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为： 1String str = \"赵丽颖,20\"; 将字符串截取数字年龄部分，得到字符串; 将上一步的字符串转换成为int类型的数字; 将上一步的int数字累加100，得到结果int数字。 解答1234567891011121314151617181920212223import java.util.function.Function;public class DemoFunction { public static void main(String[] args) { String str = \"赵丽颖,20\"; int age = getAgeNum( str, s -&gt; s.split(\",\")[1], s -&gt; Integer.parseInt(s), n -&gt; n += 100 ); System.out.println(age); } private static int getAgeNum(String str, Function&lt;String, String&gt; one, Function&lt;String, Integer&gt; two, Function&lt;Integer, Integer&gt; three) { return one.andThen(two).andThen(three).apply(str); }} 运行程序，控制台输出： 1120","link":"/p/251404202005/"},{"title":"Java 常用函数式接口之Predicate接口","text":"@Author: YiHua Lee @Address: Guangdong province, China JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的Predicate接口及使用示例。 Predicate接口概述有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用java.util.function.Predicate 接口。 抽象方法：testPredicate 接口中包含一个抽象方法: boolean test(T t) 。用于条件判断的场景： 123456789101112import java.util.function.Predicate;public class Demo01Predicate { public static void main(String[] args) { method(s -&gt; s.length() &gt; 5); } private static void method(Predicate&lt;String&gt; predicate) { boolean veryLong = predicate.test(&quot;HelloWorld&quot;); System.out.println(&quot;字符串很长吗:&quot; + veryLong); }} 运行程序，控制台输出： 1字符串很长吗:true 条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 默认方法：and既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实 现“并且”的效果时，可以使用default方法 and 。其JDK源码为： 1234default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t);} 如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么： 1234567891011121314151617import java.util.function.Predicate;public class DemoPredicateAnd { public static void main(String[] args) { boolean isValid = method( // String.contains()方法，仅当此字符串包含指定的字符值序列时返回true。 s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;W&quot;) ); System.out.println(&quot;字符串符合要求吗:&quot; + isValid); } private static boolean method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) { boolean isValid = one.and(two).test(&quot;Hello world&quot;); return isValid; }} 运行程序，控制台输出： 1字符串符合要求吗:false 默认方法：or与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为： 1234default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t);} 如果希望实现逻辑“字符串包含大写“H”或者包含大写“W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变： 1234567891011121314151617import java.util.function.Predicate;public class DemoPredicateOr { public static void main(String[] args) { boolean isValid = method( // String.contains()方法，仅当此字符串包含指定的字符值序列时返回true。 s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;W&quot;) ); System.out.println(&quot;字符串符合要求吗:&quot; + isValid); } private static boolean method(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) { boolean isValid = one.or(two).test(&quot;Hello world&quot;); return isValid; }} 运行程序，控制台输出： 1字符串符合要求吗:true 默认方法：negate“与”、“或”已经了解了，剩下的“非”(取反)也会简单。默认方法 negate 的JDK源代码为： 123default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t);} 从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前 调用 negate 方法，正如 and 和 or 方法一样： 123456789101112import java.util.function.Predicate;public class DemoPredicateNegate { public static void main(String[] args) { method(s -&gt; s.length() &gt; 5); } private static void method(Predicate&lt;String&gt; predicate) { boolean veryLong = predicate.negate().test(&quot;HelloWorld&quot;); System.out.println(&quot;字符串很长吗:&quot; + veryLong); }} 运行程序，控制台输出： 1字符串很长吗:false 练习：集合信息筛选题目数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中，需要同时满足两个条件： \\1. 必须为女生; \\2. 姓名为4个字。 1String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; }; 解答12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;public class DemoPredicate { public static void main(String[] args) { String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; }; List&lt;String&gt; list = filter( array, s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]), s -&gt; s.split(&quot;,&quot;)[0].length() == 4 ); System.out.println(list); } private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String info : array) { if (one.and(two).test(info)) { list.add(info); } } return list; }}","link":"/p/231404202005/"},{"title":"Java 多线程安全问题的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 线程安全假如Java程序中有多个线程在同时运行，而这些线程可能会同时运行一部分的代码。如果说该Java程序每次运行的结果和单线程的运行结果是一样的，并且其他的变量值也都是和预期的结果是一样的，那么就可以说线程是安全的。 解析什么是线程安全：卖电影票案例假如有一个电影院上映《葫芦娃大战奥特曼》，售票100张（1-100号），分三种情况卖票： 情况1：该电影院开设一个售票窗口，一个窗口卖一百张票，没有问题。就如同单线程程序不会出现安全问题一样。 情况2：该电影院开设n（n&gt;1）个售票窗口，每个售票窗口售出指定号码的票，也不会出现问题。就如同多线程程序，没有访问共享数据，不会产生问题。 情况3：该电影院开设n（n&gt;1）个售票窗口，每个售票窗口出售的票都是没有规定的（如：所有的窗口都可以出售1号票），这就会出现问题了，假如三个窗口同时在卖同一张票，或有的票已经售出，还有窗口还在出售。就如同多线程程序，访问了共享数据，会产生线程安全问题。 卖100张电影票Java程序实现：出现情况3类似情况1234567891011121314151617181920212223242526public class MovieTicket01 implements Runnable { /** * 电影票数量 */ private static int ticketNumber = 100; /** * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务 */ @Override public void run() { // 设置此线程要执行的任务 while (ticketNumber &gt; 0) { // 提高程序安全的概率，让程序睡眠10毫秒 try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } // 电影票出售 System.out.println(\"售票窗口（\" + Thread.currentThread().getName() + \"）正在出售：\" + MovieTicket01.ticketNumber + \"号电影票\"); ticketNumber --; } }} 12345678910111213141516171819202122// 测试public class Demo01MovieTicket { public static void main(String[] args) { // 创建一个 Runnable接口的实现类对象。 MovieTicket01 movieTicket = new MovieTicket01(); // 创建Thread类对象，构造方法中传递Runnable接口的实现类对象(三个窗口)。 Thread window0 = new Thread(movieTicket); Thread window1 = new Thread(movieTicket); Thread window2 = new Thread(movieTicket); // 设置一下窗口名字，方便输出确认 window0.setName(\"window0\"); window1.setName(\"window1\"); window2.setName(\"window2\"); // 调用Threads类中的start方法，开启新的线程执行run方法 window0.start(); window1.start(); window2.start(); }} 12345678910111213141516171819202122控制台部分输出：售票窗口（window0）正在出售：100号电影票售票窗口（window2）正在出售：99号电影票售票窗口（window1）正在出售：100号电影票售票窗口（window0）正在出售：97号电影票售票窗口（window2）正在出售：97号电影票售票窗口（window1）正在出售：97号电影票售票窗口（window1）正在出售：94号电影票售票窗口（window2）正在出售：94号电影票......售票窗口（window0）正在出售：7号电影票售票窗口（window2）正在出售：4号电影票售票窗口（window0）正在出售：4号电影票售票窗口（window1）正在出售：2号电影票售票窗口（window1）正在出售：1号电影票售票窗口（window2）正在出售：0号电影票售票窗口（window0）正在出售：-1号电影票 可以看到，三个窗口（线程）同时出售不指定号数的票（访问共享数据），出现了卖票重复，和出售了不存在的票号数（0、-1） Java程序中为什么会出现这种情况 在CPU线程的调度分类中，Java使用的是抢占式调度。 我们开启了三个线程，3个线程一起在抢夺CPU的执行权，谁能抢到谁就可以被执行。 从输出结果可以知道，刚开始抢夺CPU执行权的时候，线程0（window0窗口）先抢到，再到线程1（window1窗口）抢到，最后线程2（window2窗口）才抢到。 那么为什么100号票已经在0号窗口出售了，在1号窗口还会出售呢？其实很简单，线程0先抢到CPU执行权，于是有了执行权后，他就开始嚣张了，作为第一个它通过while判断，很自豪的拿着ticketNumber = 100进入while里面开始执行 可线程0是万万没有想到，这时候的线程1，在拿到执行权后，在线程0刚刚实现print语句还没开始ticketNumber –的时候，线程1以ticketNumber = 100跑进了while里面。 线程2很遗憾，在线程0执行了ticketNumber –了才急匆匆的进入while里面，不过它也不甘落后，于是拼命追赶。终于，后来居上，在线程1还没开始print的时候，他就开始print了。于是便出现了控制台的前三条输出的情况。 123售票窗口（window0）正在出售：100号电影票售票窗口（window2）正在出售：99号电影票售票窗口（window1）正在出售：100号电影票 window0、window1、window2分别对应线程0、线程1、线程2 以此类推，直到最后程序执行完毕。 解决情况3的共享数据问题通过线程的同步，来解决共享数据问题。有三种方式，分别是同步代码块、同步方法、锁机制。 同步代码块1234567891011121314151617181920212223242526272829303132333435public class MovieTicket02 implements Runnable { /** * 电影票数量 */ private static int ticketNumber = 100; /** * 创建锁对象 */ Object object = new Object(); /** * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务 */ @Override public void run() { // 设置此线程要执行的任务 synchronized (object) { // 把访问了共享数据的代码放到同步代码中 while (ticketNumber &gt; 0) { // 提高程序安全的概率，让程序睡眠10毫秒 try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } // 电影票出售 System.out.println(\"售票窗口（\" + Thread.currentThread().getName() + \"）正在出售：\" + MovieTicket02.ticketNumber + \"号电影票\"); ticketNumber --; } } }} 12345678910111213141516171819202122// 进行测试public class Demo02MovieTicket { public static void main(String[] args) { // 创建一个 Runnable接口的实现类对象。 MovieTicket02 movieTicket = new MovieTicket02(); // 创建Thread类对象，构造方法中传递Runnable接口的实现类对象(三个窗口)。 Thread window0 = new Thread(movieTicket); Thread window1 = new Thread(movieTicket); Thread window2 = new Thread(movieTicket); // 设置一下窗口名字，方便输出确认 window0.setName(\"window0\"); window1.setName(\"window1\"); window2.setName(\"window2\"); // 调用Threads类中的start方法，开启新的线程执行run方法 window0.start(); window1.start(); window2.start(); }} 1234567891011121314151617控制台输出：售票窗口（window0）正在出售：100号电影票售票窗口（window0）正在出售：99号电影票售票窗口（window0）正在出售：98号电影票售票窗口（window0）正在出售：97号电影票售票窗口（window0）正在出售：96号电影票......售票窗口（window0）正在出售：5号电影票售票窗口（window0）正在出售：4号电影票售票窗口（window0）正在出售：3号电影票售票窗口（window0）正在出售：2号电影票售票窗口（window0）正在出售：1号电影票 这时候，控制台不再出售不存在的电影号数以及重复的电影号数了。 通过代码块中的锁对象，可以使用任意的对象。但是必须保证多个线程使用的锁对象是同一。锁对象作用：把同步代码块锁住，只让一个线程在同步代码块中执行。 总结：同步中的线程，没有执行完毕，不会释放锁，同步外的线程，没有锁，进不去同步。 同步方法12345678910111213141516171819202122232425262728293031323334353637public class MovieTicket03 implements Runnable { /** * 电影票数量 */ private static int ticketNumber = 100; /** * 创建锁对象 */ Object object = new Object(); /** * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务 */ @Override public void run() { // 设置此线程要执行的任务 ticket(); } public synchronized void ticket() { // 把访问了共享数据的代码放到同步代码中 while (ticketNumber &gt; 0) { // 提高程序安全的概率，让程序睡眠10毫秒 try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } // 电影票出售 System.out.println(\"售票窗口（\" + Thread.currentThread().getName() + \"）正在出售：\" + MovieTicket03.ticketNumber + \"号电影票\"); ticketNumber --; } }} 测试与同步代码块一样。 锁机制（Lock锁）在Java中，Lock锁机制又称为同步锁，加锁public void lock()，释放同步锁public void unlock()。 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MovieTicket05 implements Runnable { /** * 电影票数量 */ private static int ticketNumber = 100; Lock reentrantLock = new ReentrantLock(); /** * 在实现类中重写Runnable接口的run方法，并设置此线程要执行的任务 */ @Override public void run() { // 设置此线程要执行的任务 while (ticketNumber &gt; 0) { reentrantLock.lock(); // 提高程序安全的概率，让程序睡眠10毫秒 try { Thread.sleep(10); // 电影票出售 System.out.println(\"售票窗口（\" + Thread.currentThread().getName() + \"）正在出售：\" + MovieTicket05.ticketNumber + \"号电影票\"); ticketNumber --; } catch (InterruptedException e) { e.printStackTrace(); } finally { reentrantLock.unlock(); } } }} 1234567891011121314151617181920212223// 测试public class Demo05MovieTicket { public static void main(String[] args) { // 创建一个 Runnable接口的实现类对象。 MovieTicket05 movieTicket = new MovieTicket05(); // 创建Thread类对象，构造方法中传递Runnable接口的实现类对象(三个窗口)。 Thread window0 = new Thread(movieTicket); Thread window1 = new Thread(movieTicket); Thread window2 = new Thread(movieTicket); // 设置一下窗口名字，方便输出确认 window0.setName(\"window0\"); window1.setName(\"window1\"); window2.setName(\"window2\"); // 调用Threads类中的start方法，开启新的线程执行run方法 window0.start(); window1.start(); window2.start(); }} 12345678910111213141516171819控制台部分输出：售票窗口（window0）正在出售：100号电影票售票窗口（window0）正在出售：99号电影票售票窗口（window0）正在出售：98号电影票售票窗口（window0）正在出售：97号电影票售票窗口（window0）正在出售：96号电影票......售票窗口（window1）正在出售：7号电影票售票窗口（window1）正在出售：6号电影票售票窗口（window1）正在出售：5号电影票售票窗口（window1）正在出售：4号电影票售票窗口（window1）正在出售：3号电影票售票窗口（window2）正在出售：2号电影票售票窗口（window1）正在出售：1号电影票 与前两种方式不同，前两种方式，只有线程0能够进入同步机制执行代码，Lock锁机制，三个线程都可以进行执行，通过Lock锁机制来解决共享数据问题。","link":"/p/511502202005/"},{"title":"Java 常用函数式接口之Supplier接口","text":"@Author: YiHua Lee @Address: Guangdong province, China JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的Supplier接口及使用示例。 Supplier接口概述12345678910111213// Supplier接口源码@FunctionalInterfacepublic interface Supplier&lt;T&gt; { /** * Gets a result. * * @return a result */ T get();} java.util.function.Supplier 接口仅包含一个无参的方法: T get() 。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。如： 1234567891011121314151617import java.util.function.Supplier;public class Demo01Supplier { public static void main(String[] args) { String msgA = \"Hello \"; String msgB = \"World \"; System.out.println( getString( () -&gt; msgA + msgB ) ); } private static String getString(Supplier&lt;String&gt; stringSupplier) { return stringSupplier.get(); }} 控制台输出： 1Hello World 练习：求数组元素最大值使用 Supplier 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。接口的泛型使用 java.lang.Integer 类。 12345678910111213141516171819202122232425262728import java.util.function.Supplier;public class DemoNumberMax { public static void main(String[] args) { int[] numbers = {100, 200, 300, 400, 500, -600, -700, -800, -900, -1000}; int numberMax = arrayMax( () -&gt; { int max = numbers[0]; for (int number : numbers) { if (max &lt; number) { max = number; } } return max; } ); System.out.println(\"数组中的最大值为：\" + numberMax); } /** * 获取一个泛型参数指定类型的对象数据 * @param integerSupplier 方法的参数为Supplier，泛型使用Integer * @return 指定类型的对象数据 */ public static Integer arrayMax(Supplier&lt;Integer&gt; integerSupplier) { return integerSupplier.get(); }} 控制台输出： 1数组中的最大值为：500","link":"/p/161404202005/"},{"title":"Java 异常的概念、体系和分类","text":"@Author: YiHua Lee @Address: Guangdong province, China 异常概念 异常：指的是程序在执行过程中,出现的非正常的情况,最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中,异常本身是一个类,产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常体系 异常的机制，其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，这个根类下有两个子类，分别是java.lang.Error和java.lang.Exception，平常所说的异常指的是Exception异常。 Error：严重错误Error，无法通过处理的错误，只能事先避兔。好比绝症。 Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒。 Throwable中常用的方法123456public void printStackTrace()// 打印异常的详细信息。包含了异常的类型，异常的原因，还包括常出现的位置。在开发和调试阶段都得使用printStackTrace。public String getMessage()// 获取发生异常的原因。提示给用户时候就提示误原因。public String toString()// 获取异常的类型和异常描述信息。 异常分类Exception 编译期昇常 RuntimeException:运行期异常 Error错误错误就相当于程序得了一个无法治愈的毛病(非典,艾滋).必须修改源代码,程序才能继卖执行。","link":"/p/180002202005/"},{"title":"Java 抽象类的简单理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 抽象类语法上需要注意的细节第一点 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类创建对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体。 第二点 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的 super() ，需要访问父类构造方法。 第三点 在抽象类中，不一定包含抽象方法，但有抽象方法的类一定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 第四点 抽象类的子类，必须重写抽象父类中的所有抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么在创建对象后，调用抽象方法，没有意义。 抽象类的创建父类创建：创建一个动物类 子类创建：创建一个小狗类 测试 输出：","link":"/p/071930202004/"},{"title":"Java 成员变量与局部变量","text":"@Author: YiHua Lee @Address: Guangdong province, China 成员变量与局部变量的区别局部变量在方法内部的变量 形参：在方法签名中定义的变量。 方法局部变量：在方法内部定义的变量。 代码块局部变量：在代码块内定义的变量。 成员变量定义在类里的变量 实例变量：不用 static 修饰的变量。 类变量：static 修饰的变量。 举例1234567891011121314151617181920212223242526272829/** * @Author: YiHua Lee */public class ValueDifference { String name; // 实例变量 static int id; // 类变量 public ValueDifference(int id1, String name1) { this.name = name1; id = id1; } public void value1(int number) { int age; // 方法局部变量 for (int i = 0; i &lt; number; i++) { System.out.println(\"i 代码块局部变量\"); } } public static void value2() { String gender; // 方法局部变量 }} 局部变量和成员变量定义位置不同 局部变量：在方法内部。 成员变量：在方法的外部，直接写在类当中的变量。 代码理解 12345678910111213/** * @Author: YiHua Lee */public class ValueDifference { String name; // 成员变量 public void value() { int id; // 局部变量 }} 局部变量和成员变量作用范围不同 局部变量：只有在方法中才可以使用，如果出了方法，就不可以再用了。 成员变量：整个类中都是可以使用的。 代码理解 局部变量和成员变量默认值不同 局部变量：没有默认值，假如想使用，一定要手动进行赋值。 成员变量：如果没有赋值，会有默认值。 代码理解 注意：什么是局部变量、什么是成员变量","link":"/p/541830202004/"},{"title":"Java 数据类型和初始值","text":"@Author: YiHua Lee @Address: Guangdong province, China Java 基本数据类型byte、short、int、long、float、double、boolean、char byte 数据类型是8位、有符号的，以二进制补码表示的整数 short 数据类型是 16 位、有符号的，以二进制补码表示的整数 int 数据类型是32位、有符号的，以二进制补码表示的整数 long 数据类型是 64 位、有符号的以二进制补码表示的整数 float 数据类型是单精度、32位、符合IEEE 754标准的浮点数 double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数 boolean数据类型表示一位的信息 char类型是一个单一的 16 位 Unicode 字符 初始值 整数类型，默认为 0 浮点类型，默认为 0.0 字符类型，默认为 ‘\\u0000’ 布尔类型，默认为 false 引用类型，默认为 null 具体类型初始值 byte默认为 0 short默认为 0 int默认为 0 long默认为 0L float默认为 0.0f double默认为 0.0d boolean默认为 false char默认为 \\u0000 String默认为 null String 为引用数据类型","link":"/p/401830202004/"},{"title":"Java 接口的简单理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 接口概述接口就是一种公共的规范标准，只要符合标准，就可以大家通用。 接口的基本格式 接口的抽象方法定义 接口的抽象方法使用 接口的默认方法定义 接口的默认方法使用 接口的静态方法定义和使用 接口的私有方法定义和使用 接口的常量定义和使用 接口的内容小结 继承父类并实现多个接口 接口直接的多继承 总结 接口没有静态代码块、构造方法。 一个类的直接父类只有一个，但是他的接口可以有多个。 如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需覆盖重写一次即可。 如果实现类没有实现接口中的所有抽象方法，那么该实现类必须是抽象类。 如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法覆盖重写。 一个类如果直接父类当中的方法，和接口当中的默认方法冲突了，优先用父类当中的方法。 一个接口的多个父接口中，父接口的抽象方法如果重复，那么就继承一个。 一个接口的多个父接口中，父接口的默认方法如果重复，那么子接口必须对默认方法进行覆盖重写。","link":"/p/171930202004/"},{"title":"Java 数据结构快速入门","text":"@Author: YiHua Lee @Address: Guangdong province, China 数据结构：栈 简介：栈（stack），又称堆栈，它是运算受限的线性表。 限制：栈（stack）的限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 采用该结构的特点 先进后出（即：存进去的元素,要在后它后面的元素依次取出后，オ能取出该元素）。 栈的入口、出口的都是栈的顶端位置。 例如：子弹压进弹夹先压进去的子弹在下面，后压进去的子弾在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 说明： 栈（stack）：弹夹 入栈（压栈）：向弹夹中添加子弹 出栈（弹栈）：子弹从弹夹中弹出来 数据结构：队列 简介：队列（queue），简称队，它同堆栈一样，也是一种运算受限的线性表。 限制：队列的限制是仅允许在表的一端进行插入而在表的另一端进行删除。 采用该结构的特点 先进先出（即：存进去的元素，要在后它前面的元素依次取出后，オ能取出该元素）。 队列的入口、出口各占一侧。 例如：小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 数据结构：数组 简介：数组（Array）是有序的元素序列，数组是在堆内存中开辟一段连实的空间，并在此空间存放元素。 采用该结构的特点 查找元素快 增删元素慢 为什么说数组查找元素快，增删元素慢 数组查询快：数组的地址是连续的我们通过数组的首地址可以找到数组，通过数组的素引可以快速查找某一个 元素增删慢：数组的长度是固定的我们想要增加/删除一个元素，必须创建一个新数组把源数组的数据复制过来 增删元素，会在堆内存中频繁的创建新数组、复制数组中的元素、销毁数组，导致效率低下 举例：一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 数据结构：链表 简介：链表（linked、list）由一系列结点node(链表中毎一个元素称为结点)组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储结点地址的指针域。链表结构有单向链表与双向链表。 单向链表：链表中只有一条链子，不能保证元素的顺序（存储元素和取出元素的顺序有可能不一致） 双向链表：链表中有两条链子有一条链子是专门记录元素的顺序，是一个有序的集合 说明 链表中的每一个元素也称之为一个节点 一个节点包含了一个数据源（存储数据），两个指针域(存储地址)，一个指针域存储本节点的地址，一个指针域存储第一个节点的地址 采用该结构的特点 多个结点之间，通过地址进行连接。例如：多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。 增删元素快：增加或删除某个元素只需修改一下连接元素之间的地址值即可 为什么说链表查询慢，增删快 查询慢：链表中地址不是连续的每次查询元素都必须从头开始查询 增删快：链表结构增加/删除一个元素对链表的整体结构没有影响，所以增删快 图解 每个node 单向链表node之间的连接（无序的） 双向链表node之间的连接（有序的） 假如想要增删数据，只需更改连接下一个node的地址值即可 数据额结构：红黑树首先简单了解一下计算机中的树（如图：“下面分支的连接不是箭头，而是线”） 什么是二叉树分支不能够超过两个的树 如： 什么是排序树/查找树在二叉树的基础上，元素是有大小顺序的，左子树小，右子树大 如： 平衡树左子树 = 右子树 如： 不平衡树左子树 != 右子树 如： 红黑树 特点：趋近于平衡树，查询的速度非常的快，查询叶子节点最大次数和最小次数不能超过2倍 约束： 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点（空节点）是黑色的 每个红色的节点的子节点都是黑色的 任何一个节点到其每个叶子节点的所有路径上黑色节点数相同 如：","link":"/p/042101202005/"},{"title":"Java 数组索引异常的产生过程解析","text":"@Author: YiHua Lee @Address: Guangdong province, China 直接引入实例进行分析。 通过索引查询数组值1234567891011public class DemoArrayException { public static void main(String[] args) { int[] array = {0, 1, 2, 3}; int element = DemoArrayException.getElement(array, 4); } public static int getElement(int[] array, int index) { return array[index]; }} 很容易知道，数组array的元素个数是4个，不过索引值是从0开始的，所以最大索引是3。 其中，getElement方法是获取数组指定索引位置的值的。 运行程序，抛出错误：ArrayIndexOutOfBoundsException: 4 开始分析 这里通过getElement()方法，访问了array数组的4索引，这个时候，JVM就会检测到程序中出现异常。JVM检测出异常，它就会根据异常产生的原因，创建一个异常对象ArrayIndexOutOfBoundsException(“4”)，这个异常对象包含了内容、原因、位置。接着，JVM就会访问getElement方法，发现该方法中没有处理逻辑(try…catch)，这时候，JVM就会把异常对象ArrayIndexOutOfBoundsException(“4”)抛出给方法的调用者main方法来处理这个异常。 main方法接收到JVM抛出的异常对象ArrayIndexOutOfBoundsException(“4”)，而main方法也没有处理逻辑(try…catch)，于是继续把对象抛出给main方法的调用者JVM处理。 JVM接收到main方法抛回来的异常对象后，会把异常对象的内容、原因、位置以红色字体打印在控制台。然后JVM会终止当前正在执行的Java程序。","link":"/p/120002202005/"},{"title":"Java 方法重载 (Overload)","text":"@Author: YiHua Lee @Address: Guangdong province, China 为什么要用方法重载 对于功能类似的方法来说，因为参数列表不一样，如果定义不同名称的方法，太麻烦且难以记忆。 为了解决这个问题，引入方法的重载。重载的定义 多个方法的名称一样，但参数列表不一样。 实例不使用方法重载 定义三个功能类似的方法1234567891011public class TestOverload { public static int sumOne(int a) { return a; } public static int sumTwo(int a, int b) { return a + b; } public static int sumThree(int a, int b, int c) { return a + b + c; }} 使用这三个方法12345678910public static void main(String[] args) { System.out.println(sumOne(1)); // 输出 1 System.out.println(sumTwo(1, 2)); // 输出 3 System.out.println(sumThree(1, 2, 3)); // 输出 6} 使用方法重载 定义三个功能类似的方法1234567891011public class TestOverload { public static int sum(int a) { return a; } public static int sum(int a, int b) { return a + b; } public static int sum(int a, int b, int c) { return a + b + c; }} 使用这三个方法12345678910public static void main(String[] args) { System.out.println(sum(1)); // 输出 1 System.out.println(sum(1, 2)); // 输出 3 System.out.println(sum(1, 2, 3)); // 输出 6} 注意事项方法重载的相关因素参数个数不同123456public static int sum(int a) { return a;}public static int sum(int a, int b) { return a + b;} 参数类型不同123456public static int sum(int a, int b) { return a + b;}public static int sum(long a, long b) { return (int) (a + b);} 参数的多类型顺序不同123456public static int sum(int a, double b) { return (int) (a + b);}public static int sum(double a, int b) { return (int) (a + b);} 方法重载的不相关因素与参数的名称无关123456public static int sum(int a, int b) { return a + b;}public static int sum(int x, int y) { return x + y;} 与方法的返回值无关123456public static double sum(int a, int b) { return a + b;}public static int sum(int a, int b) { return a + b;} 总结如果有功能类似的方法，可以使用方法重载，这样不仅容易记忆，调用起来也方便。","link":"/p/311830202004/"},{"title":"Java 理解TCP通信案例：文件上传案例","text":"@Author: YiHua Lee @Address: Guangdong province, China 文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 原理：客户端读取本地的文件，把文件上传到服务器，服务器再把上传的文件保存到服务器的硬盘上。 信息回写分析图解5. 【服务端】获取网络字节缓冲输出流，回写数据。 6. 【客户端】获取网络字节缓冲输入流，解析回写数据。 基本实现步骤 客户端使用本地字节输入流，读取要上传的文件。 客户端使用网络字节输出流，把读取到的文件上传到服务器。 服务器使用网络字节输入流，读取客户端上传的文件。 服务器使用本地字节输出流，把读取到的文件，保存到服务器的硬盘上。 服务器使用网络字节输出流给客户端回写一个”上传成功”。 **客户端使用网络字节输入流读取服务器回写的数据。** ***释放资源。*** 服务端实现读取客户端上传的文件，保存到服务器的硬盘，给客户端回写”上传成功”。 保存目的地： 1&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo38/CopyFile.jpg&quot; 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class TcpFileUploadServer { public static void main(String[] args) throws IOException { System.out.println(\"服务器启动时间：\" + System.currentTimeMillis()); method(); System.out.println(\"服务器关闭时间：\" + System.currentTimeMillis()); } private static void method() throws IOException { // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(8888); // 2. 建立连接 Socket accept = serverSocket.accept(); // 3. 创建流对象 // 3.1 获取网络字节缓冲输入流,读取文件数据 BufferedInputStream bis1 = new BufferedInputStream(accept.getInputStream()); // 3.2 创建本地字节缓冲输出流,保存到本地 BufferedOutputStream bos1 = new BufferedOutputStream(new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo38/CopyFile.jpg\")); // 4. 读写上传文件的数据 byte[] b = new byte[1024]; int len; while ((len = bis1.read(b)) != -1) { bos1.write(b, 0, len); } // 5. 上传成功 // 5.1 服务端，创建网络字节缓冲输出流 BufferedOutputStream bos2 = new BufferedOutputStream(accept.getOutputStream()); // 5.2 给客户回写数据：\"上传成功\"。 bos2.write(\"上传成功\".getBytes()); // 5. 释放资源 bos1.close(); bis1.close(); bos2.close(); accept.close(); }} 客户端实现读取本地文件，上传到服务器，读取服务器回写的数据。 本地文件地址： 1&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo38/LocalFile.jpg&quot; 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.net.Socket;public class TcpFileUploadClient { public static void main(String[] args) throws IOException { System.out.println(\"客户端启动时间：\" + System.currentTimeMillis()); method(); System.out.println(\"客户端关闭时间：\" + System.currentTimeMillis()); } private static void method() throws IOException { // 1. 创建流对象 // 1.1 创建本地字节缓冲输入流,读取本地文件 BufferedInputStream bis1 = new BufferedInputStream(new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo38/LocalFile.jpg\")); // 1.2 创建网络字节缓冲输出流,写到服务端 Socket socket = new Socket(\"localhost\", 8888); BufferedOutputStream bos1 = new BufferedOutputStream(socket.getOutputStream()); // 2. 写出本地文件数据 byte[] bytes1 = new byte[1024]; int len1; while (( len1 = bis1.read(bytes1)) != -1) { bos1.write(bytes1, 0, len1); bos1.flush(); } // 3. 上传成功 // 3.1 客户端，创建网络字节缓冲输入流 BufferedInputStream bis2 = new BufferedInputStream(socket.getInputStream()); // 3.2 读取服务器回写的数据 byte[] bytes2 = new byte[1024]; int len2; while (( len2 = bis2.read(bytes2)) != -1) { bos1.write(bytes2, 0, len2); bos1.flush(); } // 3. 释放资源 bos1.close(); socket.close(); bis1.close(); }} 程序运行文件上传优化分析文件名称写死问题服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优\\化，保证文件名称唯一，代码如下：** 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+&quot;.jpg&quot;); // 文件名称 BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题服务端，只保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断\\的接收不同用户的文件，代码如下：** 12345// 每次接收新的连接，创建一个Socketwhile(true){ Socket accept = serverSocket.accept(); ......} 效率问题服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优\\化，代码如下：** 123456789101112while (true) { Socket accept = serverSocket.accept(); // accept交给子线程处理 new Thread(new Runnable() { @Override public void run() { ...... BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); ...... } }).start();} 这里使用了匿名内部类实现Runnable接口，由于该接口中只有一个抽象方法，所以也可以使用Lambda表达式来简化代码： 1234567891011while (true) { Socket accept = serverSocket.accept(); // accept交给子线程处理 new Thread( () -&gt; { ...... BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); ...... } ).start();} 优化实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class Tcp01FileUploadServer { public static void main(String[] args) throws IOException { System.out.println(\"服务器启动时间：\" + System.currentTimeMillis()); method(); System.out.println(\"服务器关闭时间：\" + System.currentTimeMillis()); } private static void method() throws IOException { // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收,建立连接 while (true) { // 2.1 建立连接 Socket accept = serverSocket.accept(); new Thread( () -&gt; { try ( // 3. 创建流对象 // 3.1 获取网络字节缓冲输入流,读取文件数据 BufferedInputStream bis1 = new BufferedInputStream(accept.getInputStream()); // 3.2 创建本地字节缓冲输出流,保存到本地 BufferedOutputStream bos1 = new BufferedOutputStream(new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo38/CopyFile.jpg\")); // 4. 上传成功 // 4.1 服务端，创建网络字节缓冲输出流 BufferedOutputStream bos2 = new BufferedOutputStream(accept.getOutputStream()); ) { // 5. 读写上传文件的数据 byte[] b = new byte[1024]; int len; while ((len = bis1.read(b)) != -1) { bos1.write(b, 0, len); } bos1.flush(); // 6. 给客户回写数据：\"上传成功\"。 bos2.write(\"上传成功\".getBytes()); bos2.flush(); // 7. 释放资源 bos1.close(); bis1.close(); bos2.close(); accept.close(); } catch (IOException e) { e.printStackTrace(); } } ).start(); } }} 这里虽然实现了多个文件同时上传，不过会在内存中不断的创建线程和销毁线程，造成效率低下，浪费内存资源。线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 线程池具体如何实现，可以查看：[Java线程池概念、原理、简单实现](","link":"/p/041404202005/"},{"title":"Java 网络编程入门","text":"@Author: YiHua Lee @Address: Guangdong province, China 软件结构 C/S结构：全称为Client/Servers结构，是指客户端和服务结构。常见程序有QQ、迅雪等软件。 B/S结构：全称为 Browser/ Servers结构，是指浏览器和服务结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议网络通信协议通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议传输控制协议/因特网互联协议(Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分別是应用层、传输层、网络层和链路层，每层分別负责不同的通信功能。 链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。 运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。 应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 网络通信协议的分类通信的协议还是比较复杂的，java.net包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net包中，提供了两种比较常见的网络协议的支持 UDP —— 用户数据报协议UDP全称User Datagram Protocol，UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视烦和普通数据的传输。例如视频会议都使用UDP协议，因为这种情況即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示： 特点：数据被限制在64kb以内，超出这个范围就不能发送了。 数据报( Datagram)：网络传输的基本单位。 TCP —— 传输控制协议TCP全称Transmission Control Protocol，TCP协议是面向连接的通信协议，即传输数据之前在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。 整个交互过程如下图所示： 第一次握手 第二次握手 第三次握手 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 网络编程三要素协议计算机网络通信必须遵守的规则。 IP地址IP地址：指互联网协议地址( Internet Protocol Address)，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把”个人电脑”比作一台电话的话,那么”IP地址”就相当于”电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d的形式，例如192.168.65.100。其中a、b、c、d都是0-255之间的十进制整数，那么最多可以表示42亿个 IPv6：由于互联网的達勃发展，IP地址的需求量越来越大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的毎一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？这时候就用到了端口号来进行区分。 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0-65535。其中，0-1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用【协议+IP地址+端口号】三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。","link":"/p/431803202005/"},{"title":"Java 用集合实现简单的斗地主发牌","text":"@Author: YiHua Lee @Address: Guangdong province, China 创建数组、集合，存放数据12345678910111213141516public class FightAgainstLandlords { /** * poker集合，存储54张牌 */ private ArrayList&lt;String&gt; poker; /** * colors数组存储牌的花色 */ private String[] colors; /** * numbers数组存储牌的值 */ private String[] numbers;} 构造方法FightAgainstLandlords1234567public class FightAgainstLandlords { public FightAgainstLandlords(ArrayList&lt;String&gt; poker, String[] colors, String[] numbers) { this.poker = poker; this.colors = colors; this.numbers = numbers; }} 定义打乱牌牌序方法1234567891011121314151617public class FightAgainstLandlords { /** * 存储54张牌 */ public ArrayList&lt;String&gt; fiftyFive() { for (String color: colors) { for (String number: numbers) { poker.add(color + number); } } poker.add(\"大王\"); poker.add(\"小王\"); // 洗牌，调用Collections类的静态方法shuffle()，用默认随机源对指定列表进行置换 Collections.shuffle(poker); return poker; }} 发牌123456789101112131415161718192021222324252627282930313233343536373839404142public class FightAgainstLandlords { /** * 发牌 * 获取玩家牌或者底牌 * j = 1, 2, 3 代表玩家牌 * j = 其他数字 代表底牌 */ public ArrayList&lt;String&gt; licensing(int j, ArrayList&lt;String&gt; pokers) { // 三个玩家 ArrayList&lt;String&gt; people1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; people2 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; people3 = new ArrayList&lt;&gt;(); // 底牌 ArrayList&lt;String&gt; basePoker = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; pokers.size(); i++) { String p = pokers.get(i); if ( i &lt; 51) { if (i % 3 == 0) { people1.add(p); } else if (i % 3 == 1) { people2.add(p); } else { people3.add(p); } } else { basePoker.add(p); } } // 返回玩家的牌、底牌 if (j == 1) { return people1; } else if (j == 2) { return people2; } else if (j == 3) { return people3; } else { return basePoker; } }} 测试FightAgainstLandlords类123456789101112131415161718192021222324252627import java.util.ArrayList;public class DemoFightAgainstLandlords { public static void main(String[] args) { ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); String[] colors = {\"红桃\", \"黑桃\", \"梅花\", \"方块\"}; String[] numbers = {\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"}; // new一个斗地主 FightAgainstLandlords fightAgainstLandlords = new FightAgainstLandlords(poker, colors, numbers); // 54张牌 ArrayList&lt;String&gt; pokers = fightAgainstLandlords.fiftyFive(); // 获取每个人的牌，和底牌 ArrayList&lt;String&gt; people1 = fightAgainstLandlords.licensing(1, pokers); ArrayList&lt;String&gt; people2 = fightAgainstLandlords.licensing(2, pokers); ArrayList&lt;String&gt; people3 = fightAgainstLandlords.licensing(3, pokers); ArrayList&lt;String&gt; basePoker = fightAgainstLandlords.licensing(4, pokers); // 看一下它们每个人的牌，和底牌 System.out.println(\"people1：\" + people1); System.out.println(\"people2：\" + people2); System.out.println(\"people3：\" + people3); System.out.println(\"basePoker：\" + basePoker); }} 12345输出结果（每个人的牌，和底牌都是随机的）：people1：[红桃3, 梅花J, 梅花K, 方块J, 方块K, 梅花10, 红桃6, 梅花9, 黑桃Q, 红桃Q, 梅花4, 黑桃A, 方块2, 红桃8, 方块4, 黑桃8, 红桃K]people2：[梅花A, 方块3, 小王, 黑桃J, 红桃7, 方块5, 方块9, 黑桃10, 方块8, 梅花Q, 方块6, 梅花6, 红桃10, 方块Q, 黑桃5, 黑桃2, 红桃A]people3：[梅花5, 梅花8, 黑桃7, 黑桃4, 红桃9, 黑桃9, 黑桃K, 方块7, 黑桃6, 梅花3, 方块10, 红桃4, 黑桃3, 红桃5, 大王, 红桃J, 方块A]basePoker：[红桃2, 梅花2, 梅花7] FightAgainstLandlords类的所有代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.ArrayList;import java.util.Collections;public class FightAgainstLandlords { /** * poker集合，存储54张牌 * 不是斗地主也可以存储52张牌（不存储大王、小王牌） */ private ArrayList&lt;String&gt; poker; /** * colors数组存储牌的花色 */ private String[] colors; /** * numbers数组存储牌的值 */ private String[] numbers; public FightAgainstLandlords(ArrayList&lt;String&gt; poker, String[] colors, String[] numbers) { this.poker = poker; this.colors = colors; this.numbers = numbers; } /** * 存储54张牌 */ public ArrayList&lt;String&gt; fiftyFive() { for (String color: colors) { for (String number: numbers) { poker.add(color + number); } } poker.add(\"大王\"); poker.add(\"小王\"); // 洗牌，调用Collections类的静态方法shuffle()，用默认随机源对指定列表进行置换 Collections.shuffle(poker); return poker; } /** * 发牌 * 获取玩家牌或者底牌 * j = 1, 2, 3 代表玩家牌 * j = 其他数字 代表底牌 */ public ArrayList&lt;String&gt; licensing(int j, ArrayList&lt;String&gt; pokers) { // 三个玩家 ArrayList&lt;String&gt; people1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; people2 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; people3 = new ArrayList&lt;&gt;(); // 底牌 ArrayList&lt;String&gt; basePoker = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; pokers.size(); i++) { String p = pokers.get(i); if ( i &lt; 51) { if (i % 3 == 0) { people1.add(p); } else if (i % 3 == 1) { people2.add(p); } else { people3.add(p); } } else { basePoker.add(p); } } // 返回玩家的牌、底牌 if (j == 1) { return people1; } else if (j == 2) { return people2; } else if (j == 3) { return people3; } else { return basePoker; } }}","link":"/p/482001202005/"},{"title":"Java 递归的简单学习与理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 递归概述概念：指在当前方法内调用自己的这种现象。 递归的分类：递归分为两种,直接递归和间接)递归。 直接递归称为方法自身调用自己 间接递归可以A方法调用B方法,B方法调用方法,C方法调用A方法。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 在递归中虽然有限定条件，但是递归次数不能太多，否则也会发生栈内存溢出。 构造方法，禁止递归。 假如有方法A，没有限制，不断的递归A方法，那么分配的栈内存中就有无数个A方法，最终导致栈内存溢出。构造方法中不可以递归，因为构造方法是创建对象使用的，一直递归会导致内存中有无数多个对象，直接编译报错。 使用递归计算1～n之间的和12345678910111213public class DemoSum { public static void main(String[] args) { System.out.println(sum(100)); } public static int sum(int n) { if (n == 1) { return 1; } return n + sum(n - 1); }} 12控制台输出：5050 使用递归来计算n的阶乘123456789101112public class DemoFactorial { public static void main(String[] args) { System.out.println(sum(10)); } public static int sum(int n) { if (n &gt; 1) { return n * sum(n - 1); } return 1; }} 12控制台输出：3628800 递归打印多级目录下的文件1234567891011121314151617181920212223242526272829303132333435import java.io.File;public class DemoFileAndDirectory { public static void main(String[] args) { File file = new File(\"/AAA/BBB/CCC/\"); ergodic(file); } /** * 遍历输出文件夹下的的文件，倘若给定的是一个文件，直接输出该文件 * @param file 文件或文件夹 */ public static void ergodic(File file) { // 是否存在该目录或文件 if (file.exists()) { // 存在该目录或文件，获取该目录下的所有目录和文件 File[] files = file.listFiles(); // 遍历该目录下的文件或目录 for (File f : files) { // 该目录下，如果是目录，使用递归。如果是文件，直接输出。 if (f.isDirectory()) { ergodic(f); } else { System.out.println(f.getAbsolutePath()); } } } else { if (file.isFile()) { System.out.println(\"不存在该文件\"); } else { System.out.println(\"不存在该目录\"); } } }} 12控制台输出：不存在该目录 递归打印多级目录下的.java文件123456789101112131415161718192021222324252627282930313233343536import java.io.File;public class Demo02FileAndDirectory { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study\"); ergodic(file); } /** * 遍历输出文件夹下的的.java文件，倘若给定的是一个文件，且是.java为后缀的文件，直接输出该文件 * @param file 文件或文件夹 */ public static void ergodic(File file) { // 是否存在该目录或文件 if (file.exists()) { // 存在该目录或文件，获取该目录下的所有目录和文件 File[] files = file.listFiles(); // 遍历该目录下的文件或目录 assert files != null; for (File f : files) { // 该目录下，如果是目录，使用递归。如果是文件，直接输出。 if (f.isDirectory()) { ergodic(f); } else if (f.getName().endsWith(\".java\")) { System.out.println(f.getName()); } } } else { if (file.isFile()) { System.out.println(\"不存在该文件\"); } else { System.out.println(\"不存在该目录\"); } } }} 1控制台输出所有后缀名为java的文件","link":"/p/301703202005/"},{"title":"Java 转换流的简单理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。编码：字符 –&gt; 字节 解码：字节 –&gt; 字符 字符编码，是一套自然语言的字符与二进制数之间的对应规则。 字符集 字符集，也叫编码表，是一个系统支持的所有字符集合，包括国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识別各种字符集符号，需要进行字符编码,一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 编码引出的问题在IDEA中，使用FileReader读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取系统中创建的文本文件时，由于系统的默认是GBK编码，就会出现乱码。 那么该如何解决呢？我们可以使用InputStreamReader类、OutputStreamWriter类，指定编码来进行读写操作，这时候就不会出现乱码的情况了。 OutputStreamWriter类java.io.OutputStreamWriter是字符流通向字节流的桥梁：可使用指定的charset将要写入流中的字符编码成字节（编码）。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 OutputStreamWriter类是java.io.Writer的子类，所以可以使用父类方法： 1234567891011121314151617181920public void write(int c)// 写入单个字符。public void write(char cbuf[])// 写入字符数组。abstract public void write(char cbuf[], int off, int len)// 写入字符数组的某一部分，off是数组的开始索引，len是写的字符个数。public void write(String str)// 写入字符串。public void write(String str, int off, int len)//写入字符的某一部分。off是字符的开始素，len是写的字符个数。abstract public void flush()// 刷新该流的缓冲。abstract public void close()// 关闭此流，但会先刷新它。 构造方法12345678OutputStreamWriter(OutputStream out)// 创建使用默认编码的OutputStreamWriter对象OutputStreamWriter(OutputStream out, String charsetName)// 创建使用指定编码的OutputStreamWriter对象参数：OutputStreamWriter out：字节输出流String charsetName：指定编码表的名称，不区分大小写。如utf-8/UTF-8。 使用步骤： 12341.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的編码表名称。2.使用OutputStreamWriter对象中的方法write，把字符转换为字节存储到缓冲区中（编码）。3.使用OutputStreamWriter对象中的方法flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）。4.释放资源。 举例：指定编码，将数据保存到文件中。 1234567891011121314151617181920212223242526import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;public class DemoOutputStreamWriter { public static void main(String[] args) throws IOException { Gbk_TXT(); } private static void Gbk_TXT() throws IOException { // 创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的編码表名称。指定编码为GBK。 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo35/OutputStreamWriter.txt&quot;), &quot;gbk&quot;); // 使用OutputStreamWriter对象中的方法write，把字符转换为字节存储到缓冲区中（编码）。 for (int i = 0; i &lt; 5; i++) { osw.write(&quot;你好！&quot; + i); osw.write(&quot;\\n&quot;); } // 使用OutputStreamWriter对象中的方法flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）。 osw.flush(); // 释放资源。 osw.close(); }} 运行，生成一个OutputStreamWriter.txt文件，文件内容如下： 由于IDEA默认编码是UTF-8，这里使用了GBK编码格式写入数据进文件，所以在IDEA里面查看文件的内容出现乱码。 InputStreamReader类java.io.InputStreamReader是字节流通向字符流的桥梁：它使用指定的charset读取字节并将其解码为字符（解码）。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 InputStreamReader类是java.io.Reader的子类，所以可以使用父类方法： 12345678public void close()// 关闭此流并释放与此流相关联的任何系统资源。public int read()// 从输入流读取一个字符。public int read(char[] chars)// 从输入流中读取一些字符，并将它们存储到字符数组chars中。 构造方法12345678InputStreamReader(InputStream in)// 创建默认字符集的InputStreamReader对象InputStreamReader(InputStream in, String charsetName)// 创建指定字符集的InputStreamReader对象参数：InputStream in：字符输入流String charsetName：指定编码表的名称，不区分大小写。如gbk/GBK。 使用步骤： 1231.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称。2.使用InputStreamReader对象中的方法read，读取文件。3.释放资源。 注意事项：构造方法中指定的编码表名称要和文件的编码相同，否则会发生乱码。 举例：按指定解码格式，读取OutputStreamWriter.txt文件的内容 1234567891011121314151617181920212223import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class DemoInputStreamReader { public static void main(String[] args) throws IOException { decode_GBK(); } private static void decode_GBK() throws IOException { // 创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称。 InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo35/OutputStreamWriter.txt&quot;), &quot;GBK&quot;); // 使用InputStreamReader对象中的方法read，读取文件。 char[] chars = new char[25]; while ((isr.read(chars)) != -1) { System.out.println(chars); } // 释放资源。 isr.close(); }} 控制台输出： 12345你好！0你好！1你好！2你好！3你好！4 练习：转换文件编码将编码GBK编码的文件文本，转换为UTF-8编码的文件文本。 分析： 123451.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称GBK。2.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称UTF-8。3.使用InputStreamReader对象中的方法read，读取文件。4.使用OutputStreamWriter对象中的方法write，把读取的数据写入到文件中。5.释放资源。 GBK.txt文件内容如下： 代码实现： 1234567891011121314151617181920212223242526272829import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.IOException;import java.io.FileInputStream;import java.io.FileOutputStream;public class DemoInOutAndReaderWriter { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称GBK。 InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo35/GBK.txt&quot;), &quot;GBK&quot;); // 创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称UTF-8。 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;/Users/liyihua/IdeaProjects/Study/src/view/study/demo35/UTF_8.txt&quot;), &quot;UTF-8&quot;); // 使用InputStreamReader对象中的方法read，读取文件。 int len = 0; while ((len = isr.read()) != -1) { osw.write(len); } // 释放资源。 isr.close(); osw.close(); }} 运行生成一个UTF_8.txt文件，文件内容如下：","link":"/p/201803202005/"},{"title":"Java 集合的工具类Collections的常用方法","text":"@Author: YiHua Lee @Address: Guangdong province, China Collections类：java.utils.Collections是集合工具类，用来对集合进行操作。 Collections类的常用方法1234567public static &lt;T&gt; boolean adda1l(Collection&lt;T&gt; c, T ... elements)// 往集合中添加一些元素。public static void shuff1e(List&lt;?&gt; 1ist)// 打乱顺序:打乱集合顺序。public static &lt;T&gt; void sort(List&lt;r&gt; 1ist)// 将集合中元素按照默认规则排序。public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt;)// 将集合中元素按照指定规则排序。 addAll(Collection c, T … elements)方法 参数说明： Collection c：是要被添加元素的集合 T … elements：可变参数，是要给集合添加的元素 方法功能：往集合中添加一些元素 例子： 123456789101112131415import java.util.Collections;import java.util.HashSet;public class DemoCollections { public static void main(String[] args) { // 创建一个HashSet集合 HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); // 调用Collections类的静态方法addAll，往集合hashSet中添加多个元素 Collections.addAll(hashSet, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"); // 输出HashSet集合 System.out.println(hashSet); }} 输出结果： 1[a, b, c, d, e, f, g] shuffle(List&lt;?&gt; list)方法 参数说明：List&lt;?&gt; list：表示传入的集合，即该方法传入的参数是一个集合 方法功能：打乱集合的顺序。 例子： 1234567891011121314151617import java.util.ArrayList;import java.util.Collections;public class DemoCollectionsShuffle { public static void main(String[] args) { // 创建一个ArrayList集合 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); // 往arrayList集合中添加元素 Collections.addAll(arrayList, \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"); System.out.println(\"没有打乱时的集合：\" + arrayList); // 调用Collections类的静态方法shuffle，将集合arrayList里面的元素顺序打乱 Collections.shuffle(arrayList); System.out.println(\"打乱以后的集合：\" + arrayList); }} 输出结果： 12没有打乱时的集合：[A, B, C, D, E, F, G]打乱以后的集合：[D, B, C, E, A, G, F] sort(List list)方法 参数说明：List&lt;?&gt; list：表示传入的集合，即该方法传入的参数是一个集合 方法功能：对集合进行排序（默认为升序排序） 例子： 1234567891011121314151617import java.util.ArrayList;import java.util.Collections;public class Demo01CollectionsSort { public static void main(String[] args) { // 创建一个ArrayList集合 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); // 往arrayList集合中添加元素 Collections.addAll(arrayList, 1, 2, 10, 9, 8); System.out.println(\"没有排序时的集合：\" + arrayList); // 调用sort()方法，将集合arrayList里面的元素进行排序 Collections.sort(arrayList); System.out.println(\"排序后的集合：\" + arrayList); }} 输出结果： 12没有排序时的集合：[1, 2, 10, 9, 8]排序后的集合：[1, 2, 8, 9, 10] sort(List list, Comparator&lt;? super T&gt;)方法首先，说明一下，这个方法仅做了解即可，学习过程中通常都是默认使用sort(List list)方法的。 参数说明： List&lt;?&gt; list：表示传入的集合，即该方法传入的第一个参数是一个集合 Comparator&lt;? super T&gt;：这是一个排序规则，自定义（覆盖重写该接口的排序方法） 方法功能：对集合进行排序（默认为升序排序） 例子： 12345678910111213141516171819202122232425262728293031323334353637// 随便创建一个Person类public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 自己定义一个排序规则进行测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 举例import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class Demo02CollectionsSort { public static void main(String[] args) { // 创建一个ArrayList集合 ArrayList&lt;Person&gt; arrayList = new ArrayList&lt;&gt;(); // 往arrayList集合中添加元素，集合存储的数据的类型是自定义类型(Person) Collections.addAll( arrayList, new Person(\"LeeHua\", 20), new Person(\"WanTao\", 18), new Person(\"XiaMin\", 22), new Person(\"HonMao\", 22) ); System.out.println(\"没有排序时的集合：\" + arrayList); // 自定义排序规则，对arrayList集合进行排序 Collections.sort(arrayList, new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { // 年龄相等，按照名字排序 while (o1.getAge() - o2.getAge() == 0) { if (o1.getName().length() &gt; o2.getName().length()) { for (int i = 0; i &lt; o2.getName().length(); i++) { if (o1.getName().charAt(i) - o2.getName().charAt(i) != 0 ) { return o1.getName().charAt(i) - o2.getName().charAt(i); } } return 1; } else if (o1.getName().length() &lt; o2.getName().length()) { for (int i = 0; i &lt; o1.getName().length(); i++) { if (o1.getName().charAt(i) - o2.getName().charAt(i) != 0 ) { return o1.getName().charAt(i) - o2.getName().charAt(i); } } return - 1; } else { for (int i = 0; i &lt; o2.getName().length(); i++) { if (o1.getName().charAt(i) - o2.getName().charAt(i) != 0 ) { return o1.getName().charAt(i) - o2.getName().charAt(i); } } return 0; } } // 年龄不相等，按照年龄排序 return o1.getAge() - o2.getAge(); } }); System.out.println(\"排序以后的集合：\" + arrayList); }} 输出结果： 12没有排序时的集合：[Person{name='LeeHua', age=20}, Person{name='WanTao', age=18}, Person{name='XiaMin', age=22}, Person{name='HonMao', age=22}]排序以后的集合：[Person{name='WanTao', age=18}, Person{name='LeeHua', age=20}, Person{name='HonMao', age=22}, Person{name='XiaMin', age=22}] 排序规则代码及注释 123456789101112131415161718192021222324252627282930313233343536373839404142new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { // 首先判断年龄是否相等 while (o1.getAge() - o2.getAge() == 0) { // 如果this年龄 == object年龄，那么就按名字的字母(char code)比较 // 按照名字的每个字母来比较 if (o1.getName().length() &gt; o2.getName().length()) { // o1的名字长度 &gt; o2的名字长度 for (int i = 0; i &lt; o2.getName().length(); i++) { if (o1.getName().charAt(i) - o2.getName().charAt(i) != 0 ) { return o1.getName().charAt(i) - o2.getName().charAt(i); } } // 假如o2的名字的所有字母，按顺序都与o1的名字对应位数的字母相等，字母长度大的排后，即o1排后 return 1; } // o1的名字长度 &lt; o2的名字长度 else if (o1.getName().length() &lt; o2.getName().length()) { for (int i = 0; i &lt; o1.getName().length(); i++) { if (o1.getName().charAt(i) - o2.getName().charAt(i) != 0 ) { return o1.getName().charAt(i) - o2.getName().charAt(i); } } // 假如o1的名字的所有字母，按顺序都与o2的名字对应位数的字母相等，字母长度大的排后，即o2排后 return - 1; } // o1的名字长度 = o2的名字长度 else { for (int i = 0; i &lt; o2.getName().length(); i++) { if (o1.getName().charAt(i) - o2.getName().charAt(i) != 0 ) { return o1.getName().charAt(i) - o2.getName().charAt(i); } } // 假如o1的名字的所有字母，按顺序都与o2的名字对应位数的字母相等，那么按照arrayList集合的添加顺序排序 return 0; } } // 年龄不相等，按照年龄排序 return o1.getAge() - o2.getAge(); } }","link":"/p/232301202005/"},{"title":"Java中两种获取Stream流的方式","text":"@Author: YiHua Lee @Address: Guangdong province, China 获取流java.util.stream.Stream 是Java 8新加入的最常用的流接口。(这并不是一个函数式接口。) 获取一个流非常简单，有以下几种常用的方式： 所有的 Collection 集合都可以通过 stream 默认方法获取流; Stream 接口的静态方法 of 可以获取数组对应的流。 根据Collection获取流首先， java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。 12345678910111213141516171819import java.util.*;import java.util.stream.Stream;public class Demo03Stream { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); // ... Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); // ... Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); // ... Stream&lt;String&gt; stream3 = vector.stream(); }} Collection接口中加入的默认方法 —— stream方法，其源码如下： 123default Stream&lt;E&gt; stream() { return StreamSupport.stream(spliterator(), false);} 根据Map获取流java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 123456789101112131415161718import java.util.HashMap;import java.util.Map;import java.util.Set;import java.util.stream.Stream;public class Demo04Stream { public static void main(String[] args) { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // ... Set&lt;String&gt; key = map.keySet(); Set&lt;String&gt; value = (Set&lt;String&gt;) map.values(); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); Stream&lt;String&gt; keyStream = key.stream(); Stream&lt;String&gt; valueStream = value.stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = entries.stream(); }} Map接口比较特殊，它保存的数据是 Key - Value的，所以要分为Key、Value以及Key-Value情况，Key-Value情况即entry情况。将每种分别保存在Set集合中，而Set接口继承于Collection接口，所以这里也就间接的使用了Collection接口的默认方法stream，来获取流。 根据数组获取流如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单： 123456789import java.util.stream.Stream;public class Demo05GetStream { public static void main(String[] args) { String[] array = { \"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\" }; Stream&lt;String&gt; stream = Stream.of(array); }}备注： of 方法的参数其实是一个可变参数，所以支持数组。","link":"/p/301404202005/"},{"title":"Java 通过实现简单的TCP通信程序来理解TCP通信","text":"@Author: YiHua Lee @Address: Guangdong province, China 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端(Client)与服务端(Server)。 两端通信的步骤 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 如下图： 客户端1和服务端进行一个通讯的交互①②③④，需要四个IO流对象，客户端2也是如此。那么两个客户端都和同一个服务端进行交互，服务端怎么区分呢？在服务器端有一个accept方法，可以获取到请求的客户端对象。 多个客户端同时和服务器进行交互，就需要使用多个IO流对象。服务器是没有IO流的，服务器可以获取到请求的客户端Socket对象t，使用每个客户端Socket中提供的IO流和客户端进行交互。服务器使用客户端的字节输入流读取客户端发送的数据，使用客户端的字节输出流给客户端回写数据。简单的说，就是服务器使用客户端的流和客户端交互。 Socket类Socket类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法123public Socket(String host, int port)// 创建套接字对象（两台设备之间通讯的端点对象）并将其连接到指定主机上的指定端// 口号。如果指定的host是null，则相当于指定地址为回送地址。 套接字：包含了IP地址（host）和端口号（port）的网络单位。 回送地址：回送地址(127.x.x.x)是本机回送地址(Loopback Address)，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 成员方法12345678OutputStream getOutputStream()// 返回此套接字的输出流。InputStream getInputStream()// 返回此套接字的输入流void close()// 关闭此套接字。 举例使用Java程序，进行客户端和服务端之间的通信。 TCP通讯的客户端向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据。 实现步骤： 12345678910111.创建一个客户端对象Socket，构造方法中绑定服务器的IP地址和端口号。2.使用Socket对象中的方法getOutputStream()，获取网络字节输出流OutputStream对象。3.使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。4.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。5.使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。6.释放资源(Socket)。 注意： 123451.客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象。2.当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过3次握手建立连接通路。这时如果服务器没有启动，那么就会抛出异常（ConnectException: Connection refused: connect）。如果服务器已经启动，那么就可以进行交互了。 客户端代码实现： 1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class TcpClient { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建一个客户端对象Socket，构造方法中绑定服务器的IP地址和端口号。 Socket socket = new Socket(\"127.0.0.1\", 8888); // 使用Socket对象中的方法getOutputStream()，获取网络字节输出流OutputStream对象。 OutputStream outputStream = socket.getOutputStream(); // 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。 outputStream.write(\"你好吖！服务器。\".getBytes()); // 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。 InputStream inputStream = socket.getInputStream(); // 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。 byte[] bytes = new byte[1024]; int len = inputStream.read(bytes); System.out.println(new String(bytes, 0, len)); // 释放资源(Socket)。 socket.close(); }} 完成了客户端代码的编写后，先了解一下ServerSocket类，然后编写服务端Java代码。 ServerSocket类ServerSocket类：此类现服务器套接字。服务器等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。 构造方法12ServerSocket(int port)// 创建绑定到特定端口的服务器套接字。 成员方法12Socket accept()// 侦听并接受到此套接字的连接。 服务器端必须明确一件事情，必须的知道是哪个客户端请求的服务器，所以可以使用accept方法获取到请求的客户端对象Socket。 举例接收客户端的请求，读取客户端发送的数据，给客户端回写数据。 TCP通信的服务端实现步骤： 123456789101112131.创建服务器ServerSocket对象，对象中传递系统要指定的端口号。2.使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket。3.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。4.使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据。5.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。6.使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据。7.释放资源（Socket，ServerSocket）。 服务端代码实现： 12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class TcpServer { public static void main(String[] args) throws IOException { method(); } private static void method() throws IOException { // 创建服务器ServerSocket对象，对象中传递系统要指定的端口号。 ServerSocket serverSocket = new ServerSocket(8888); // 使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket。 Socket socket = serverSocket.accept(); // 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。 InputStream inputStream = socket.getInputStream(); // 使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据。 byte[] bytes = new byte[1024]; int len = inputStream.read(bytes); System.out.println(new String(bytes, 0, len)); // 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。 OutputStream outputStream = socket.getOutputStream(); // 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据。 outputStream.write(\"收到，谢谢！\".getBytes()); // 释放资源（Socket，ServerSocket）。 socket.close(); serverSocket.close(); }} 客户端程序和服务端程序都已经编写完成，先运行服务端程序，然后再运行客户端程序。 客户端程序：控制台输出（收到来自服务端回写的数据） 1收到，谢谢您！客户端。 服务端程序：控制台输出（接收到客户端发来的请求数据） 1你好吖！服务器。 输出截图如下： 客户端程序和服务端程序对比（4K图，可放大）： 代码实现步骤： 第一步 1234567服务器端：// 创建服务器ServerSocket对象，对象中传递系统要指定的端口号。ServerSocket serverSocket = new ServerSocket(8888);// 使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket。Socket socket = serverSocket.accept(); 第二步 12345678910客户端：// 创建一个客户端对象Socket，构造方法中绑定服务器的IP地址和端口号。Socket socket = new Socket(\"127.0.0.1\", 8888);// 使用Socket对象中的方法getOutputStream()，获取网络字节输出流OutputStream对象。OutputStream outputStream = socket.getOutputStream();// 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。outputStream.write(\"你好吖！服务器。\".getBytes()); 第三步 123456789101112131415服务器端：// 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。InputStream inputStream = socket.getInputStream();// 使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据。byte[] bytes = new byte[1024];int len = inputStream.read(bytes);System.out.println(new String(bytes, 0, len));// 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。OutputStream outputStream = socket.getOutputStream();// 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据。outputStream.write(\"收到，谢谢您！客户端。\".getBytes()); 第四步 123456789客户端：// 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。InputStream inputStream = socket.getInputStream();// 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。byte[] bytes = new byte[1024];int len = inputStream.read(bytes);System.out.println(new String(bytes, 0, len)); 第五步 1234客户端：// 释放资源(Socket)。socket.close(); 第六步 12345服务器端：// 释放资源（Socket，ServerSocket）。socket.close();serverSocket.close();","link":"/p/531803202005/"},{"title":"JavaScript 的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China HTML + CSS + JavaScript 实现简单的 9 x 9 乘法表HTML + JavaScript 实现简单的电灯开关HTML + JavaScript 实现简单的轮播图HTML + CSS + JavaScript 实现简单的自动跳转页面HTML + CSS + JavaScript 实现简单的动态表格JavaScript常见的事件监听HTML + CSS + JavaScript 实现勾选动态表格中的记录HTML + CSS + JavaScript 实现注册页面信息验证（表单验证）","link":"/p/541606202005/"},{"title":"Jsp 入门学习","text":"@Author: YiHua Lee @Address: Guangdong province, China JSP 简介什么是Java Server Pages? JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。 JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。 JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。 为什么使用JSP？ JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。 JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。 JSP是Java EE不可或缺的一部分，是一个完整的企业级应用平台。这意味着JSP可以用最简单的方式来实现最复杂的应用。 JSP的优势 与纯 Servlet 相比：JSP可以很方便的编写或者修改HTML网页而不用去面对大量的println语句。 与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。 与静态HTML相比：静态HTML不包含动态信息。 JSP 的执行过程 首先，客户端发出请求(request )，请求访问JSP网页 接着，JSP Container将要访问的.JSP文件 转译成Servlet的源代码（.java文件） 然后，将产生的Servlet的源代码（.java文件）经过编译，生成.class文件，并加载到内存执行 最后把结果响应(response )给客户端 实例引入创建一个Java EE Tomcat项目，在 index.jsp 文件里面，进行修改： 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;JSP 的入门学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% System.out.println(\"这里可以定义Java代码！\"); %&gt; 这里是HTML ~ ~ ~ &lt;/body&gt;&lt;/html&gt; 启动tomcat服务器，访问该页面，页面内容如下： 1这里是HTML ~ ~ ~ 控制台输出： 1这里可以定义Java代码！ 项目被部署到的根目录为：~/Library/Caches/JetBrains/IntelliJIdea2020.1/tomcat/Tomcat_8_5_54_CookieStudy 在目录：apache/jsp/ 中可以看到一个 index_jsp.java 文件，这个文件就是通过index.jsp的内容生成的。查看该文件部分内容： 通过这里与上面的jsp文件，可以知道，其实给文件就是通过index.jsp文件生成的。且该类继承了Servlet的子类。 JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 如上面 20200530231540.png 图中的内容都是在 _jspService 类中的。 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象jsp一共有9个内置对象，在jsp页面中不需要获取和创建，可以直接使用这九个对象。 如： request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 1javax.servlet.jsp.JspWriter out=null response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 案例原Java类实现：cookie案例 通过JSP实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%@ page import=\"java.text.SimpleDateFormat\" %&gt;&lt;%@ page import=\"java.net.URLEncoder\" %&gt;&lt;%@ page import=\"java.net.URLDecoder\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Cookie 练习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% // 设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=utf-8\"); // 获取所有Cookie Cookie[] cookies = request.getCookies(); // 默认没有cookie为lastTime boolean flag = false; // 遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0) { for (Cookie cookie : cookies) { // 获取cookie的名称 String name = cookie.getName(); // 判断名称是否是：lastTime if(\"lastTime\".equals(name)) { // 有cookie为lastTime，不是第一次访问 flag = true; // 获取当前时间的字符串 Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String stringDate = simpleDateFormat.format(date); // 由于stringDate字符串中存在特殊字符（空格），需要URL编码 String encodeCookie = URLEncoder.encode(stringDate, \"utf-8\"); // 重新设置Cookie的值 cookie.setValue(encodeCookie); // 设置cookie的存活时间：存活一个小时 cookie.setMaxAge(60 * 60); // 在响应对象中添加该设置的cookie response.addCookie(cookie); // 响应数据 // 获取Cookie的value（时间） String value = cookie.getValue(); // 对获取到的cookie值进行URL解码 String decodeValue = URLDecoder.decode(value, \"utf-8\"); %&gt;&lt;h1&gt;欢迎回来，您上次访问时间为:&lt;%=decodeValue%&gt;&lt;/h1&gt;&lt;% // 已经完成了需求 break; } } } // 假如上面遍历了所有的cookie，都没有cookie为lastTime，或者用户的请求中没有cookie，说明用户是第一次访问 if(cookies == null || cookies.length == 0 || flag == false) { // 获取当前时间的字符串 Date date = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String stringDate = simpleDateFormat.format(date); // 由于stringDate字符串中存在特殊字符（空格），需要URL编码 stringDate = URLEncoder.encode(stringDate, \"utf-8\"); // 重新设置Cookie的值 Cookie cookie = new Cookie(\"lastTime\", stringDate); // 设置cookie的存活时间 cookie.setMaxAge(60 * 60); // 重新发送cookie response.addCookie(cookie); %&gt;&lt;h1&gt;您好，欢迎您首次访问！&lt;/h1&gt;&lt;% } %&gt; &lt;/body&gt;&lt;/html&gt; 与原java程序相比，这里将页面的输出语句，直接单独定义为HTML标签。 开启服务器，浏览器访问：http://localhost:8080/CookieStudy_war_exploded/cookie.jsp 再次访问该网址： 参考文献 JSP 简介| 菜鸟教程 JSP运行原理","link":"/p/481431202005/"},{"title":"Jsp 基础学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China JSP 中的指令 JSP中的三种指令标签： 指令 描述 &lt;%@ page … %&gt; 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等（配置JSP页面） &lt;%@ include … %&gt; 包含其他文件（导入页面资源文件） &lt;%@ taglib … %&gt; 引入标签库的定义 指令的使用格式： 1&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; page 指令 属性 描述 buffer 指定out对象使用缓冲区的大小 autoFlush 控制out对象的 缓存区 contentType 指定当前JSP页面的MIME类型和字符编码 errorPage 指定当JSP页面发生异常时需要转向的错误处理页面 isErrorPage 指定当前页面是否可以作为另一个JSP页面的错误处理页面 extends 指定servlet从哪一个类继承 import 导入要使用的Java类 info 定义JSP页面的描述信息 isThreadSafe 指定对JSP页面的访问是否为线程安全 language 定义JSP页面所用的脚本语言，默认是Java session 指定JSP页面是否使用session isELIgnored 指定是否执行EL表达式 isScriptingEnabled 确定脚本元素能否被使用 isErrorPage：标识当前也是是否是错误页面。 isErrorPage=true，可以使用内置对象exception isErrorPage=false，不可以使用内置对象exception errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 Include指令 JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 Include指令的语法格式如下： 1&lt;%@ include file=\"文件相对 url 地址\" %&gt; include 指令中的文件名实际上是一个相对的 URL 地址。如果您没有给文件关联一个路径，JSP编译器默认在当前路径下寻找。 Taglib指令 JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。 Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。 Taglib指令的语法： 1&lt;%@ taglib uri=\"uri\" prefix=\"prefixOfTag\" %&gt; uri属性确定标签库的位置，prefix属性指定标签库的前缀。 JSP 中的注释 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 &lt;!– 注释 –&gt; HTML注释，通过浏览器查看网页源代码时可以看见注释内容 JSP 隐式（内置）对象JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。 JSP所支持的九大隐式对象： 对象 描述 request HttpServletRequest 接口的实例 response HttpServletResponse 接口的实例 out JspWriter类的实例，用于把结果输出至网页上 session HttpSession类的实例 application ServletContext类的实例，与应用上下文有关 config ServletConfig类的实例 pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 类似于Java类中的this关键字 Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 request对象 request对象是javax.servlet.http.HttpServletRequest 类的实例。每当客户端请求一个JSP页面时，JSP引擎就会制造一个新的request对象来代表这个请求。 request对象提供了一系列方法来获取HTTP头信息，cookies，HTTP方法等等。 response对象 response对象是javax.servlet.http.HttpServletResponse类的实例。当服务器创建request对象时会同时创建用于响应这个客户端的response对象。 response对象也定义了处理HTTP头模块的接口。通过这个对象，开发者们可以添加新的cookies，时间戳，HTTP状态码等等。 out对象 out对象是 javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。 最初的JspWriter类对象根据页面是否有缓存来进行不同的实例化操作。可以在page指令中使用buffered=’false’属性来轻松关闭缓存。 JspWriter类包含了大部分java.io.PrintWriter类中的方法。不过，JspWriter新增了一些专为处理缓存而设计的方法。还有就是，JspWriter类会抛出IOExceptions异常，而PrintWriter不会。 下表列出了我们将会用来输出boolean，char，int，double，String，object等类型数据的重要方法： 方法 描述 out.print(dataType dt) 输出Type类型的值 out.println(dataType dt) 输出Type类型的值然后换行 out.flush() 刷新输出流 session对象 session对象是 javax.servlet.http.HttpSession 类的实例。和Java Servlets中的session对象有一样的行为。 session对象用来跟踪在各个客户端请求间的会话。 application对象 application对象直接包装了servlet的ServletContext类的对象，是javax.servlet.ServletContext 类的实例。 这个对象在JSP页面的整个生命周期中都代表着这个JSP页面。这个对象在JSP页面初始化时被创建，随着jspDestroy()方法的调用而被移除。 通过向application中添加属性，则所有组成您web应用的JSP文件都能访问到这些属性。 config对象 config对象是 javax.servlet.ServletConfig 类的实例，直接包装了servlet的ServletConfig类的对象。 这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 以下是config对象的使用方法，不是很重要，所以不常用： 1config.getServletName(); 它返回包含在元素中的servlet名字，注意，元素在 WEB-INF\\web.xml 文件中定义。 pageContext 对象 pageContext对象是javax.servlet.jsp.PageContext 类的实例，用来代表整个JSP页面。 这个对象主要用来访问页面信息，同时过滤掉大部分实现细节。 这个对象存储了request对象和response对象的引用。application对象，config对象，session对象，out对象可以通过访问这个对象的属性来导出。 pageContext对象也包含了传给JSP页面的指令信息，包括缓存信息，ErrorPage URL,页面scope等。 PageContext类定义了一些字段，包括PAGE_SCOPE，REQUEST_SCOPE，SESSION_SCOPE， APPLICATION_SCOPE。它也提供了40余种方法，有一半继承自javax.servlet.jsp.JspContext 类。 其中一个重要的方法就是 removeAttribute()，它可接受一个或两个参数。比如，pageContext.removeAttribute(“attrName”) 移除四个scope中相关属性，但是下面这种方法只移除特定 scope 中的相关属性： 1pageContext.removeAttribute(\"attrName\", PAGE_SCOPE); page 对象 这个对象就是页面实例的引用。它可以被看做是整个JSP页面的代表。 page 对象就是this对象的同义词。 exception 对象exception 对象包装了从先前页面中抛出的异常信息。它通常被用来产生对出错条件的适当响应。 参考文献 JSP 指令|菜鸟教程","link":"/p/572005202006/"},{"title":"Linux 常用命令","text":"@Author: YiHua Lee @Address: Guangdong province, China cd 命令 回到家目录 1cd ~ 切换到当前目录下的dir目录 1cd dir 切换到根目录 1cd / 切换到到上一级目录 1cd .. 切换到上二级目录 1cd ../.. ls 命令 以默认方式显示当前目录文件列表 1ls 显示所有文件包括隐藏文件 1ls -a 显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行 1ls -l 显示文件的大小，以容易理解的格式印出文件大小 (例如 1K 234M2G) 1ls -lh 显示文件，按照修改时间排序 1ls -lt cp 命令 将文件source复制为target 1cp source target 将/root下的文件source复制到当前目录 1cp /root /source. 将整个目录复制，两目录完全一样 1cp –av soure_dir target_dir rm 命令 删除某一个文件 1rm file 删除时候不进行提示。可以于r参数配合使用 1rm -f file 删除当前目录下叫dir的整个目录 1rm -rf dir mv 命令将文件移动走，或者改名 将文件source更名为target 1mv source target 将/usr/student下的所有文件和目录移到当前目录下 1mv /usr/student/* . diff 命令 比较目录1与目录2的文件列表是否相同 1diff dir1 dir2 比较文件1与文件2的内容是否相同 1diff file1 file2 查看文件内容命令cat命令 显示文件的内容 1cat file more命令 分页显示命令 1more file tail命令 显示文件的最后几行 1tail -n 100 aaa.txt 1说明：显示文件aaa.txt文件的最后100行 vi命令 编辑文件 1vi file 1说明：输入命令的方式为先按[ESC]键，然后输入:w(写入文件),:w!((不询问方式写入文件）,:wq保存并退出,:q退出,q!不保存退出 touch命令 创建一个空文件 1touch aaa.txt 1创建一个空文件，文件名为aaa.txt 基本系统命令man 命令查看某个命令的帮助 如：查看某个命令的帮助 1man ls w 命令 显示登录用户的详细信息 1w who命令 显示登录用户 1who last命令 查看最近那些用户登录系统 1last date命令 系统日期设定 1date uname命令 查看系统版本 1uname -R 1说明：显示操作系统内核的version 关闭和重新启动系统命令 重新启动计算机 1reboot 重新启动计算机，停止服务后重新启动计算机 1shutdown -r now 关闭计算机，停止服务后再关闭系统 1shutdown -h now 关闭计算机 1halt 1说明：一般用shutdown -r now,在重启系统是，关闭相关服务，shutdown -h now也是如此。 su命令 切换到root用户 1su - 切换到user用户 1su - user 监视系统状态命令top 命令查看系统cpu、内存等使用情况 1top free 命令查看内存和swap分区使用情况 1free ps 命令 显示进程信息 1ps 显示当前用户的进程 1ps ux 显示当前用户的进程的详细信息 1ps uxwww 显示所有用户的进程 1ps aux kill 命令干掉某个进程，进程号可以通过ps命令得到 将进程编号为 XXX 的程序干掉 1kill -9 XXX 将所有名字为 XXX 的程序杀死，kill不是万能的，对僵死的程序则无效。 1kill all -9 XXX 磁盘操作命令df命令检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 1df du 命令检测一个目录和（递归地）所有它的子目录中的文件占用的磁盘空间。 1du 用户和组相关命令groupadd命令添加组 12groupadd groupTest说明：添加groupTest组 12groupadd -g 123456 groupTest说明：添加groupTest组，组ID为123456 useradd命令 添加用户 1useradd user_name passwd命令 修改用户user1的密码 1passwd user1 将root用户的密码删除 1passwd -d root userdel命令 删除用户 1userdel user_name 压缩命令gzip 命令 压缩文件，并且显示进度 1gzip -v 解压缩 1gnuzip -f zip命令 压缩zip命令 1zip 解压缩zip命令 1unzip tar命令 压缩文件或目录 1tar -cvf 解压缩文件或目录 1tar -xvf 压缩文件或，格式tar.gz 1tar -zcvf 解压缩文件或，格式tar.gz 1tar -zxvf 压缩文件或，格式tgz 1tar -zcvf 解压缩文件或，格式tgz 1tar -zxvf 网络相关命令ifconfig命令12ifconfig说明：显示修改网卡的信息 route命令12route说明：显示当前路由设置情况 netstat命令 查看网络端口信息 1netstat -an 查看路由表信息（比route快很多） 1netstat -nr 网络排错1ping 其他命令ssh命令远程登陆到其他主机 1ssh user_name@ip scp命令安全copy 1scp -r local_file user_name@ip:user_path","link":"/p/471329202004/"},{"title":"Jstl学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China JSP 标准标签库（JSTL） 概念：JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。JSTL即JavaServer Pages Tag Library。（是由Apache组织提供的开源的免费的jsp标签） JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。 根据JSTL标签所提供的功能，可以将其分为5个类别。 核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 作用：用于简化和替换jsp页面上的java代码 JSTL 库安装Apache Tomcat安装JSTL 库步骤如下： 从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。 将 tld 下的需要引入的 tld 文件复制到 WEB-INF 目录下。 接下来我们在 web.xml 文件中添加以下配置： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt-1_0-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c-1_0-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/sql&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/sql-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql-1_0-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/x&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/x-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x-1_0-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 使用任何库，你必须在每个 JSP 文件中的头部包含 &lt;taglib&gt; 标签。 核心标签核心标签是最常用的 JSTL标签。引用核心标签库的语法如下： 1&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; 其中 “c” 为前缀，核心标签库的uri为 “http://java.sun.com/jsp/jstl/core&quot; 标签 描述 &lt;c:out&gt; 用于在JSP中显示数据，就像&lt;%= … &gt; &lt;c:set&gt; 用于保存数据 &lt;c:remove&gt; 用于删除数据 &lt;c:catch&gt; 用来处理产生错误的异常状况，并且将错误信息储存起来 &lt;c:if&gt; 与我们在一般程序中用的if一样 &lt;c:choose&gt; 本身只当做&lt;c:when&gt;和&lt;c:otherwise&gt;的父标签 &lt;c:when&gt; &lt;c:choose&gt;的子标签，用来判断条件是否成立 &lt;c:otherwise&gt; &lt;c:choose&gt;的子标签，接在&lt;c:when&gt;标签后，当&lt;c:when&gt;标签判断为false时被执行 &lt;c:import&gt; 检索一个绝对或相对 URL，然后将其内容暴露给页面 &lt;c:forEach&gt; 基础迭代标签，接受多种集合类型 &lt;c:forTokens&gt; 根据指定的分隔符来分隔内容并迭代输出 &lt;c:param&gt; 用来给包含或重定向的页面传递参数 &lt;c:redirect&gt; 重定向至一个新的URL. &lt;c:url&gt; 使用可选的查询参数来创造一个URL 格式化标签JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下： 1&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; 标签 描述 &lt;fmt:formatNumber&gt; 使用指定的格式或精度格式化数字 &lt;fmt:parseNumber&gt; 解析一个代表着数字，货币或百分比的字符串 &lt;fmt:formatDate&gt; 使用指定的风格或模式格式化日期和时间 &lt;fmt:parseDate&gt; 解析一个代表着日期或时间的字符串 &lt;fmt:bundle&gt; 绑定资源 &lt;fmt:setLocale&gt; 指定地区 &lt;fmt:setBundle&gt; 绑定资源 &lt;fmt:timeZone&gt; 指定时区 &lt;fmt:setTimeZone&gt; 指定时区 &lt;fmt:message&gt; 显示资源配置文件信息 &lt;fmt:requestEncoding&gt; 设置request的字符编码 SQL标签JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下： 1&lt;%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %&gt; 标签 描述 &lt;sql:setDataSource&gt; 指定数据源 &lt;sql:query&gt; 运行SQL查询语句 &lt;sql:update&gt; 运行SQL更新语句 &lt;sql:param&gt; 将SQL语句中的参数设为指定值 &lt;sql:dateParam&gt; 将SQL语句中的日期参数设为指定的java.util.Date 对象值 &lt;sql:transaction&gt; 在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行 XML 标签JSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下： 1&lt;%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %&gt; 在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的&lt;Tomcat 安装目录&gt;\\lib下: XercesImpl.jar、xalan.jar 函数 描述 fn:contains() 测试输入的字符串是否包含指定的子串 fn:containsIgnoreCase() 测试输入的字符串是否包含指定的子串，大小写不敏感 fn:endsWith() 测试输入的字符串是否以指定的后缀结尾 fn:escapeXml() 跳过可以作为XML标记的字符 fn:indexOf() 返回指定字符串在输入字符串中出现的位置 fn:join() 将数组中的元素合成一个字符串然后输出 fn:length() 返回字符串长度 fn:replace() 将输入字符串中指定的位置替换为指定的字符串然后返回 fn:split() 将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回 fn:startsWith() 测试输入字符串是否以指定的前缀开始 fn:substring() 返回字符串的子集 fn:substringAfter() 返回字符串在指定子串之后的子集 fn:substringBefore() 返回字符串在指定子串之前的子集 fn:toLowerCase() 将字符串中的字符转为小写 fn:toUpperCase() 将字符串中的字符转为大写 fn:trim() 移除首尾的空白符 常用标签的学习if 标签if标签，相当于java代码的if语句。属性 test 必须属性，接受boolean表达式。如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容。 一般情况下，test属性值会结合Expression Language表达式一起使用。 实例引入 123456789&lt;body&gt; &lt;c:if test=\"true\"&gt; &lt;h3&gt;我是会被显示的！！！&lt;/h3&gt; &lt;/c:if&gt; &lt;hr color=\"pink\"&gt; &lt;c:if test=\"false\"&gt; &lt;h3&gt;我是不会被显示的！！！&lt;/h3&gt; &lt;/c:if&gt;&lt;/body&gt; 输出集合的每个元素（集合不为空的情况下） 12345678910111213141516&lt;body&gt; &lt;% List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"赵三\"); list.add(\"李四\"); list.add(\"王五\"); request.setAttribute(\"list\", list); %&gt; &lt;%-- 在list不为空的情况下，输出list中的每个元素 --%&gt; &lt;c:if test=\"${not empty list}\"&gt; ${requestScope.list[0]}&lt;br/&gt; ${requestScope.list[1]}&lt;br/&gt; ${requestScope.list[2]}&lt;br/&gt; &lt;/c:if&gt;&lt;/body&gt; 浏览器页面输出： 123赵三李四王五 判断一个书是否为偶数 1234567891011121314&lt;body&gt; &lt;% int number = 179; request.setAttribute(\"number\", number); %&gt; &lt;c:if test=\"${number % 2 != 0}\"&gt; &lt;%= number %&gt; 不是偶数！！！ &lt;/c:if&gt; &lt;c:if test=\"${number % 2 == 0}\"&gt; &lt;%= number %&gt; 是偶数！！！ &lt;/c:if&gt;&lt;/body&gt; 浏览器页面输出： 1179 不是偶数！！！ choose 标签choose标签，相当于java代码的switch语句。用于在众多选项中做出选择。switch语句中有case，而&lt;c:choose&gt;标签中对应有&lt;c:when&gt;，switch语句中有default，而&lt;c:choose&gt;标签中有&lt;c:otherwise&gt;。 要求： 数字编号对应星期几案例： 域中存储一个数 使用choose标签取出该数 使用when标签做数据判断 实现： 1234567891011121314&lt;body&gt; &lt;% request.setAttribute(\"number\", 1); %&gt; &lt;c:choose&gt; &lt;c:when test=\"${requestScope.number == 1}\"&gt; 星期一 &lt;/c:when&gt; &lt;c:when test=\"${requestScope.number == 2}\"&gt; 星期二 &lt;/c:when&gt; &lt;c:when test=\"${requestScope.number == 3}\"&gt; 星期三 &lt;/c:when&gt; &lt;c:when test=\"${requestScope.number == 4}\"&gt; 星期四 &lt;/c:when&gt; &lt;c:when test=\"${requestScope.number == 5}\"&gt; 星期五 &lt;/c:when&gt; &lt;c:when test=\"${requestScope.number == 6}\"&gt; 星期六 &lt;/c:when&gt; &lt;c:when test=\"${requestScope.number == 7}\"&gt; 星期天 &lt;/c:when&gt; &lt;c:otherwise&gt; 数字输入有误 &lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/body&gt; 浏览器输出： 1星期一 forEach 标签&amp;forTokens 标签这些标签封装了Java中的for，while，do-while循环。相比而言，&lt;c:forEach&gt;标签是更加通用的标签，因为它迭代一个集合中的对象。&lt;c:forTokens&gt;标签通过指定分隔符将字符串分隔为一个数组然后迭代它们。 forEach 语法格式123456789&lt;c:forEach items=\"&lt;object&gt;\" begin=\"&lt;int&gt;\" end=\"&lt;int&gt;\" step=\"&lt;int&gt;\" var=\"&lt;string&gt;\" varStatus=\"&lt;string&gt;\"&gt; ... forTokens 语法格式12345678910&lt;c:forTokens items=\"&lt;string&gt;\" delims=\"&lt;string&gt;\" begin=\"&lt;int&gt;\" end=\"&lt;int&gt;\" step=\"&lt;int&gt;\" var=\"&lt;string&gt;\" varStatus=\"&lt;string&gt;\"&gt; ... 属性&lt;c:forEach&gt;标签有如下属性： 属性 描述 是否必要 默认值 items 要被循环的信息 否 无 begin 开始的元素（0=第一个元素，1=第二个元素） 否 0 end 最后一个元素（0=第一个元素，1=第二个元素） 否 Last element step 每一次迭代的步长 否 1 var 代表当前条目的变量名称 否 无 varStatus 代表循环状态的变量名称 否 无 &lt;c:forTokens&gt;标签与&lt;c:forEach&gt;标签有相似的属性，不过&lt;c:forTokens&gt;还有另一个属性： 属性 描述 是否必要 默认值 delims 分隔符 是 无 &lt;c:forEach&gt;实例演示12345&lt;body&gt; &lt;c:forEach var=\"i\" begin=\"1\" end=\"5\"&gt; Item &lt;c:out value=\"${i}\"/&gt;&lt;p&gt; &lt;/c:forEach&gt;&lt;/body&gt; 浏览器中显示： 123456789Item 1Item 2Item 3Item 4Item 5 &lt;c:forTokens&gt;演示实例12345678&lt;body&gt; &lt;c:forTokens items=\"java,python,linux,mysql,mongodb,redis,hadoop,spark,scala\" delims=\",\" var=\"name\"&gt; &lt;c:out value=\"${name}\"/&gt;&lt;p&gt; &lt;/c:forTokens&gt;&lt;/body&gt; 浏览器中显示： 1234567891011121314151617javapythonlinuxmysqlmongodbredishadoopsparkscala 综合练习 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中 实现 创建Users.java 12345678910111213141516171819202122232425262728293031public class Users { private String name; private int age; private Date birthday; public Users() { } public Users(String name, int age, Date birthday) { this.name = name; this.age = age; this.birthday = birthday; } public String getSimpleBirthday() { return (birthday != null) ? new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(birthday) : \"\"; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; }} 实现jsp 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;% List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(\"张三\", 20, new Date())); list.add(new Users(\"李四\", 22, new Date())); list.add(new Users(\"王五\", 21, new Date())); request.setAttribute(\"list\", list); %&gt; &lt;table align=\"center\" border=\"1\" width=\"500\"&gt; &lt;tr bgcolor=\"#ffc0cb\"&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;出生&lt;/td&gt; &lt;td&gt;编号&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"${list}\" var=\"user\" varStatus=\"i\"&gt; &lt;c:if test=\"${i.count % 2 != 0}\"&gt; &lt;tr bgcolor=\"#a9a9a9\"&gt; &lt;td&gt;${i.count}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.age}&lt;/td&gt; &lt;td&gt;${user.simpleBirthday}&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;c:if test=\"${i.count % 2 == 0}\"&gt; &lt;tr bgcolor=\"#6495ed\"&gt; &lt;td&gt;${i.count}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.age}&lt;/td&gt; &lt;td&gt;${user.simpleBirthday}&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt; 浏览器中显示： 参考文献 JSP 标准标签库（JSTL） | 菜鸟教程","link":"/p/381208202006/"},{"title":"Linux 操作系统的简单认识","text":"@Author: YiHua Lee @Address: Guangdong province, China 计算机入门知识介绍计算机原理 现代计算机大部分都是基于冯.诺依曼结构，该结构的核心思想是冯将程序和数据都存放在计算机中，按存储器的存储程序首地址执行程序的第一条指令，然后进行数据的处理计算。 计算机应包括运算器、储存器、控制器、输入和输出设备五大基本部件。 计算机内部应采用二进制来表示指令和数据,将编好的程序送入内储存器中，然后启动计算机工作，计算机勿需操作人员干预，能自动逐条取出指令和执行指令。 其中，计算机是由软件和硬件组成 软件和硬件硬件 计算机硬件主要由CPU、存储设置、输入输出设备组成。 软件 计算机的软件包括操作系统，系统软件和应用软件 各个层次之间的关系 操作系统概述 操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。 OS作为计算机系统资源的管理者，主要由以下作用： 管理处理器，用于分配和控制处理器 管理存储器，主要负责内存的分配与回收 管理I/O设备，负责I/O设备的分配与操纵 管理文件，负责文件的存取、共享和保护 常见操作系统： 操作系统 应用情况 Windows操作系统 1983 应用比较广泛 Linux操作系统 1991 免费使用，类UNIX，一般安装在服务器上面 Unix操作系统 1970 无界面，使用命令操作，一般安装在服务器上面 Mac操作系统 1993 苹果公司开发的，一般PC不能使用 Android操作系统 主要用于智能终端设备 Linux系统概述 Linux 诞生于1991年，作者上大学期间 Linux诞生原因：因为创始人在上大学期间经常需要浏览新闻和处理邮件，发现现有的操作系统不好用, 于是他决心自己写一个保护模式下的操作系统，这就是Linux的原型， 当时他21岁，后来经过全世界网友的支持, 现在能够兼容多种硬件，成为最为流行的服务器操作系统之一。 Linux的特点：开源，免费，拥有最为庞大的源码贡献者 Linux系统结构 Linux发行版介绍 对于Linux操作系统来说，其本身是一个整体，包括Linux内核、系统库和系统程序，Linux内核是其最基础的部分，它实现了对硬件资源的管理，并且提供了使用这些硬件资源的通用接口。自1991年发布Linux内核来，很多公司加入其中，在内核的基础上构建了自己的操作系统版本，这个被称为Linux的发行版。 Redhat：目前，全球最大的Linux发行厂商，功能全面、稳定。 Redhat 被 IBM 收购! Ubuntu：目前，是Linux桌面操作系统做的最好的。 Centos：免费版的redhat，Centos 基于 redhat 发行版基础之上，再重新编译发布的版本。 目前 Centos 已经被 Redhat 公司收购，但是依然免费 deepin:目前，国内做的最好的一款Linux发行版 Linux目录结构介绍 Linux的目录结构是一个树型结构 Windows 系统可以拥有多个盘符, 如 C盘、D盘、E盘 Linux没有盘符这个概念, 只有一个根目录 /, 所有文件都在它下面 常用的目录介绍 目录 作用 /bin 二进制命令所在的目录 /boot 系统引导程序所需要的文件目录 /dev 设备软件目录，磁盘，光驱， /etc 系统配置，启动程序 /home 普通用户的家，目录默认数据存放目录 /lib 共享库文件和内核模块存放目录 /mnt 临时挂载储存设备的挂载点 /opt 额外的应用软件包 /proc 操作系统运行时，进程信息和内核信息存放在这里 /root Linux超级权限用户root的家目录 /sbin 和管理系统相关的命令，【超级管理员用】 /tmp 临时文件目录，这个目录被当作回收站使用 /usr 用户或系统软件应用程序目录 /var 存放系统日志的目录 参考文献","link":"/p/391409202007/"},{"title":"Linux终端命令","text":"@Author: YiHua Lee @Address: Guangdong province, China 终端命令格式1command [-options] [parameter] 说明： - command : 命令名称， 相应功能的英文单词或单词的缩写 - [-options] : 选项，可用来对命令进行控制, 也可以省略 - parameter : 传给命令的参数，可以是 零个、一个 或者 多个 显示文件列表命令 ls 是英文单词 list 的简写, 其功能为列出目录的内容，是用户最常用的命令之一 ls常用选项 选项 含义 -a 显示指定目录下所有子目录与文件, 包含隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 常见使用命令 ls 查看当前目录内容 (缺点: 隐藏文件看不到) ls -a 查看当前目录内容 ,包括隐藏文件 ls -al 查看目录内容的详细信息(查看文件类型、权限、大小等) ls -lh 查看目录内容的详细信息,以K,M,G方式显示文件大小 ls /root 查看/root目录下内容 目录查看、目录创建和目录删除命令pwd命令 查看当前所在目录 mkdir命令 该命令用于创建目录。注意: 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 创建没有层级关系的目录：mkdir test 创建有层级的目录：mkdir -p /root/aaa/bbb rm命令 该命令用于删除文件或者目录 参数说明： 参数 英文 含义 -f force (强制) 强制删除,忽略不存在的文件或目录, 无需提示 -r recursive (递归) 递归地删除目录下的内容, 删除目录时必须加此参数 删除目录有提醒 1rm -r test 提示：rm：是否删除目录 &quot;test&quot;？ 直接删除目录（不管有没有内容） 1rm -fr test 没有提示。 目录切换命令 cd 是英文单词 change directory 的缩写, 其功能为 更改当前的工作目录, 也是用户最常用的命令之一 注意: linux的所有 目录 和 文件名 都是大小写敏感的 命令 含义 cd 切换到用户主目录（root用户主目录是/root，其他用户是/home/用户名） cd 目录 切换到指定目录下 cd .. 切换到上级目录 cd - 可以在最近的两次目录之间切换 文件操作命令touch命令 touch命令，创建文件 在当前目录创建a.txt文件 1touch a.txt 在/root目录创建a.txt文件 1touch /root/a.txt mv命令 通过mv 命令可以用来移动文件或目录, 也可以给文件或目录重命名 在目录 A 中，有一个文件 a.txt，将 a.txt 文件移动到目录 B 中（A、B路径一样） 1mv A/a.txt B/ 重命名一个文件 1mv 旧文件名 新文件名 cat命令 查看文件内容 cat 文件路径 1cat /root/A/a.txt 查看文件 a.txt 的内容 cp命令 拷贝命令，可以拷贝文件或文件夹 将a.txt复制到dir1目录 1cp a.txt dir1 将a.txt复制到b.txt 1cp a.txt b.txt 压缩和解压命令tar参数说明： 参数 解释 -c 创建一个新tar文件 -v 显示运行过程的信息 -f 指定文件名 -z 调用gzip压缩命令进行压缩 -t 查看压缩文件的内容 -x 解开tar文件 解压 将文件解压到当前目录 1tar -zxvf XXX.tar.gz 将文件解压到指定目录 1tar -zxvf XXX.tar.gz -C /root/dir 压缩 打包 1tar -cvf test.tar /root/test 打包并压缩 1tar -czvf test.tar.gz /root/test 文件查找命令find命令 find命令用于查找符合条件的文件 查找 / 目录下以文件名 AAA 开头的文件 1find / -name 'AAA*' 查找 /root目录下文件大小大于100M的文件 1find /root -type f -size +100M grep命令 grep命令可以对文件进行文本查询 在 A.txt 文件中查找内容 HellowGrep 1grep HellowGrep A.txt 在 B.txt 文件中查找内容 123 ，并且高亮显示 1grep 123 B.txt --color which命令 which 查看可执行文件的位置 查找pwd命令的路径 1which pwd 查找start-all.sh命令的路径 1which start-all.sh 系统管理命令ps命令 ps命令用来列出系统中当前运行的那些进程 参数说明： 参数 含义 -A 显示所有进程（等价于-e） -a 显示一个终端的所有进程，除了会话引线 -N 忽略选择 -d 显示所有进程，但省略所有的会话引线 -x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。 -p (pid)进程使用cpu的时间 -u 选择有效的用户id或者是用户名 -g 显示组的所有进程 -f 全部列出，通常和其他选项联用 -l 长格式 -j 作业格式 -o 用户自定义格式 v 以虚拟存储器格式显示 s 以信号格式显示 -m 显示所有的线程 -H 显示进程的层次(和其它的命令合用) e 命令之后显示环境 h 不显示第一行 列的说明： USER： 用户名 PID： 进程ID（Process ID） %CPU： 进程的cpu占用率 %MEM： 进程的内存占用率 VSZ： 进程所使用的虚存的大小（Virtual Size） RSS： 进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。 TTY： 与进程关联的终端（tty） STAT： 进程的状态：进程状态使用字符表示的（STAT的状态码） TIME： 进程使用的总cpu时间 COMMAND： 正在执行的命令行命令 查看所有进程： 1ps -ef kill命令 kill命令用于终止执行中的程序 杀死pid为12345的进程 1kill -9 12345 管道命令 管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入 查询名称中包含java的进程 1ps -ef | grep java 用户的创建和删除命令用户的创建 用户的创建： useradd [用户名] 、passwd [用户名] 创建新用户 Boss 1useradd Boss 设置用户 Boss 的密码 1passwd Boss 用户的删除 用户的删除：userdel -r [用户名] 删除用户Boss 1userdel -r Boss 权限管理命令文件权限概述 Linux操作系统是多任务多用户操作系统，每当我们使用用户名登录操作系统时，Linux都会对该用户进行认证、授权审计等操作。操作系统为了识别每个用户，会给每个用户定义一个ID，就是UID。用户组就相当于多个用户的容器；在Linux系统中，用户组也有一个ID ——— GID。 在Linux操作系统中，root的权限是最高的，相当于windows的administrator，拥有最高权限，能执行任何命令和操作,而其他用户都是普通用户。 Linux对文件创建者（所属用户），所属用户组，其他用户都赋予不同的权限。 文件权限解读 文件目录列查看权限 权限说明 r: 对文件是指可读取内容 对目录是可以ls w: 对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件) x: 对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录 chmod命令 chmod命令用来变更文件或目录的权限 赋予 a.txt 文件 666 权限 1chmod 666 a.txt 给 a.txt 文件属主添加 x 权限 1chmod u+x a.txt 赋予 a.txt 文件 761 权限 1chmod u=rwx,g=rw,o=x 网络和服务管理命令hostname命令 hostname命令：查看主机名 1[root@node1 ~]# hostname 1node1 ifconfig命令 查看主机ip地址 service命令 service命令是用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态 查看网络服务状态 ：service network status 停止网络服务：service network stop 启动网络服务：service network start 重启网络服务：service network restart 其他命令ln命令 ln命令可以用来创建软连接，类似于创建快捷方式 命令格式：ln [参数] [源文件或目录] [目标文件或目录] 如：ln -s jdk1.8.0_162 jdk clear命令 清屏命令，还可以使用快捷方式：ctrl + l（注意，是L，因为小写显示的看起来像i） vi 编辑器 vi是visual interface的简称, 是Linux中最经典的文本编辑器 vi的核心设计思想：让程序员的手指始终保持在键盘的 核心区域, 就能完成所有编辑操作 Vi编辑器三种模式 命令模式： 打开文件首先进入命令模式, 是使用vi的入口 通过 命令 对文件进行常规的编辑操作, 例如 定位 翻页 复制 粘贴 删除 末行模式： 要退出 vi 返回到控制台, 需要在莫行模式下输入命令末行模式 是 vi 的出口 执行 保存 退出等操作 编辑模式： 正常的编辑文字 命令行模式常用命令 命令 功能 o 在当前行后面插入一空行 O 在当前行前面插入一空行 dd 删除光标所在行 ndd 从光标位置向下连续删除 n 行 yy 复制光标所在行 nyy 从光标位置向下连续复制n行 p 粘贴 u 撤销上一次命令 gg 回到文件顶部 G 回到文件末尾 /str 查找内容 str 底行模式常用命令 命令 功能 :w 文件 另存为 :w 保存(ctrl + s) :q 退出, 如果没有保存,不允许退出 :q! 强行退出, 不保存退出 :wq 保存并退出 :x 保存并退出 :set nu 设置行号 :%s/旧文本/新文本/g 文本替换","link":"/p/281609202007/"},{"title":"Mac Tomcat安装部署","text":"@Author: YiHua Lee @Address: Guangdong province, China 安装 Tomcat 8备注：Tomcat 依赖 jdk，所以安装 Tomcat 请先安装好JDK，这里就不详细说明，安装JDK方面，网上有很多教程。 brew 安装 Tomcat首先，自己电脑要安装到 brew，且能正常使用，如果没安装 brew，可参考我的另一篇博文：Mac 安装 brew（最新教程，绝对可行，一行代码搞定，不报错） 搜索tomcat是否存在 1brew search tomcat 安装tomcat 1brew install tomcat 检查是否安装成功 1catalina -h 运行tomcat 1catalina run 启动后，我们可以通过浏览器访问 http://localhost:8080/ 来查看一下效果。 下载安装包方式安装 进入 Tomcat 官网 点击左边栏的 Tomcat 8 进入下载页面。 选择后缀名为 tar.gz 的压缩包，下载。这里下载好的是 apache-tomcat-8.5.54.tar.gz 下载好压缩包后，打开终端，将 apache-tomcat-8.5.54.tar.gz 解压缩到 ~/Library 目录下 进入 ~/Library 目录 1cd ~/Library 解压压缩包 1tar -zxvf tomcat压缩包路径 如果不知道压缩包路径，可以在输入 “tar -zxvf “ 之后找到该压缩包，将该压缩包拖到终端就可以了。 第1、2步，也可以一步完成 1sudo tar -zxvf tomcat压缩包路径 -C ~/Library/tomcat 使用这个方式，就不需要执行第4步了。 解压后生成一个 apache-tomcat-8.5.54 目录，为了方便，可以创建为这个目录软链接，或者修改这个目录的名称 创建软链接 1ln -s ~/Library/apache-tomcat-8.5.54 ~/Library/tomcat 2. 修改目录名 1mv ~/Library/apache-tomcat-8.5.54 ~/Library/tomcat 到这里 Tomcat 就已经安装好了，不过为了以后操作方便，可以配置一下环境变量。 配置 Tomcat 8 环境变量 配置系统环境变量 1vim ~/.bash_profile 添加如下内容： 注意用户名是自己的用户名，如 /Users/leehua/Library/tomcat 12export TOMCAT_HOME=/Users/用户名/Library/tomcatexport PATH=$PATH:$TOMCAT_HOME/bin 添加完成后，保存并退出。 使刚刚配置的环境变量生效 1source ~/.bash_profile 权限配置 打开终端，进入tomcat的bin目录下 1cd ~/Library/tomcat/bin 授权bin目录下的所有操作 1sudo chmod 755 *.sh 启动与关闭Tomcat服务 启动 Tomcat 服务 1startup.sh 启动后，我们可以通过浏览器访问 http://localhost:8080/ 来查看一下效果。（默认为8080端口） 关闭 Tomcat 服务 1shutdown.sh 参考文献 Mac下安装tomcat Mac 上 brew 安装Tomcat Linux 常用命令","link":"/p/281409202005/"},{"title":"Mac 安装 brew（最新教程，绝对可行，一行代码搞定，不报错）","text":"@Author: YiHua Lee @Address: Guangdong province, China 现在安装brew，一会报这个错，一会儿报那个错，上网查了很多教程，用了很多时间都是不可以，电脑开VPN翻墙也不行。下面介绍如何一行代码解决问题 Warning: The Ruby Homebrew installer is now deprecated and has been rewritten in Bash. Please migrate to the following command: /bin/bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 无论怎么弄，都下载不到，我直接从GitHub上面克隆，不可以。然后叫我用官网的命令，我用官网的命令下载，又说curl什么的访问不到。后来下载保存了一个brew_install.rb文件，通过ruby brew_install.rb下载，也不行，回过头来又叫我用官网命令下载。在网上看到说要改hosts文件，我也改了，都不可以。 解决不过看到一个大佬放上一条命令，直接解决了这一系列问题，可以下载。很感谢这位大佬，不多说直接上命令： 自动脚本(全部国内地址)（在Mac os终端中复制粘贴回车下面这句话) 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 下面是下载时的效果： 这行命令就是这位大佬发布的：金牛肖马","link":"/p/051706202005/"},{"title":"MacBook 安装 MySQL 5.7.29（新手都看得懂的安装教程）","text":"@Author: YiHua Lee @Address: Guangdong province, China banner:第一步：找到安装包地址 —— MySQL 下载地址 第二步：找到 MySQL 5.7.29 版本 第三步： 点击下载对应的.dmg文件 第四步：点击下载后，会跳转到另一个页面 第五步：下载完成后，双击 mysql-5.7.29-macos10.14-x86_64.dmg 文件，进行安装 第六步：点击继续 第七步：点击继续 第八步：点击同意 第九步：点击安装（可以更换安装位置，不知道的可以不用理会，直接点击安装），等待安装 第十步：安装完成后，到摘要这里时，点击关闭即可。 第十一步：点击方框中的图标 第十二步：点击“Start MySQL Server” 点击后可以看到如下图所示： 第十三步：启动完成后，打开终端，输入如下内容，然后按回车键 1alias mysql=/usr/local/mysql/bin/mysql 第十四步：输入如下内容，然后按回车键 1alias mysqladmin=/usr/local/mysql/bin/mysqladmin 第十五步：修改密码（示例：修改为12345678） 1mysqladmin -u root -p password 12345678 备注： 12MySQL5.7版本密码设置MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，密码长度至少为8个字符 第十六步：终端进入MySQL 输入如下，输入后按回车即可 1mysql -u root -p12345678 备注： 12用户名为：root密码为：12345678 出现如下类似情况，说明进入成功： 1234567891011121314mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 284Server version: 5.7.29 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 如果要退出，输入”quit”即可","link":"/p/231106202005/"},{"title":"Macbook 彻彻底底的卸载MySQL","text":"@Author: YiHua Lee @Address: Guangdong province, China 在终端，一行一行输入下面的命令即可： 1234567891011121314151617sudo rm /usr/local/mysqlsudo rm -rf /usr/local/mysql*sudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*edit /etc/hostconfig and remove the line MYSQLCOM=-YES-rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /private/var/db/receipts/*mysql* 上面的命令都实现后，系统偏好设置中的MySQL图标消失：","link":"/p/261106202005/"},{"title":"Maven 3.5.4 的安装（MacOS系统）","text":"@Author: YiHua Lee @Address: Guangdong province, China 下载 Maven 3.5.4 压缩包：https://archive.apache.org/dist/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 解压 maven 安装包 到目录 /Library 下 1sudo tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /Library 配置 maven 环境变量 1vim ~/.bash_profile 最后面添加如下内容： 12export M2_HOME=/Library/apache-maven-3.5.4 export PATH=$PATH:$M2_HOME/bin 是配置生效： 1source ~/.bash_profile 修改权限 1chmod a+x /Library/apache-maven-3.5.4/bin/mvn 查看是否安装成功 1mvn -v 自定义maven本地仓库位置 1vim /Library/apache-maven-3.5.4/conf/settings.xml 找到 &lt;localRepository&gt;&lt;/localRepository&gt; 标签，添加本地仓库路径 1&lt;localRepository&gt;/Library/apache-maven-3.5.4/repo&lt;/localRepository&gt; 创建本地仓库文件夹： 1mkdir /Library/apache-maven-3.5.4/repo 国内用户下载jar包很慢，可以配置阿里云镜像源： 1vim /Library/apache-maven-3.5.4/conf/settings.xml 将节点mirror原本内容修改为如下内容： 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 参考文献 《Hadoop 大数据技术与应用》 —— 杨治明、许桂秋","link":"/p/211913202007/"},{"title":"MySQL 中的 3 种注释","text":"@Author: YiHua Lee @Address: Guangdong province, China 单行注释 12注释的语法：--空格 如： 多行注释 12注释的语法：/* */ 如： 这是 mysql 特有的注释方式 12注释的语法：#","link":"/p/281106202005/"},{"title":"Maven 学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China Maven 仓库Maven 仓库的分类 maven 的工作需要从仓库下载一些 jar 包，如下图所示，本地的项目 A、项目 B 等都会通过 maven 软件从远程仓库（可以理解为互联网上的仓库）下载 jar 包并存在本地仓库，本地仓库 就是本地文 件夹，当第二次需要此 jar 包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库 理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 上图中央仓库位置错误，应该是：http://repo1.maven.org/maven2 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包， 优先从本地仓库查找。 默认本地仓库位置在 ${user.dir}/.m2/repository 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。 远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件。 全局 setting 与 用户 setting maven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。 在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project 项目，它作为 maven 的全局配置。 如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：${user. dir} /.m2/settings.xml 目录中。 maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 Maven 工程的认识Maven 工程的目录结构 作为一个 maven 工程，它的 src 目录和 pom.xml 是必备的。 进入 src 目录后，我们发现它里面的目录结构如下： src/main/java —— 存放项目的.java 文件 src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件 src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类 src/test/resources —— 测试资源文件 target —— 项目输出位置，编译后的 class 文件会输出到此目录 pom.xml——maven 项目核心配置文件 Maven 常用命令 compile（编译） compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target 目录下。 执行 mvn compile test（测试） test 是 maven 工程的测试命令 mvn test，会执行 src/test/java 下的单元测试类。 执行 mvn test clean（清理） clean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容。 执行 mvn clean package（打包） package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war 包。 执行 mvn package install（安装） install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。 执行 mvn install idea 开发 maven 项目idea 的 maven 配置打开 –&gt; File –&gt; Settings 配置 maven 依据图片指示，选择本地 maven 安装目录，指定 maven 安装目录下 conf 文件夹中 settings 配置文件。 idea 中创 建一个 maven 的 web 工程 打开 idea，选择创建一个新工程 选择 idea 提供好的 maven 的 web 工程模板 点击 Next 填写项目信息 点击 Next，此处不做改动。 ![image-20200714081830668](/Users/liyihua/Library/Application Support/typora-user-images/image-20200714081830668.png) 点击 Next 选择项目所在目录 点击 Finish 后开始创建工程，耐心等待，直到出现如下界面。 idea 中配置创建的 maven 的 web 项目 手动添加 src/main/java 目录，如下图右键 main 文件夹 –&gt; New –&gt; Directory 创建一个新的文件夹命名为 java 点击 OK 后，在新的文件夹 java 上右键 –&gt; Make Directory as –&gt; Sources Root 创建一个 Servlet src/java/main 创建了一个 Servlet，但报错 要解决问题，就是要将 servlet-api-xxx.jar 包放进来，作为 maven 工程应当添加 servlet 的坐标，从而 导入它的 jar 在 pom.xml 文件添加坐标 直接打开 hello_maven 工程的 pom.xml 文件，再添加坐标 pom.xml 文件中的配置每个 maven 工程都需要定义本工程的坐标，坐标是 maven 对 jar 包的身份定义，比如：入门程序的 坐标定义如下： 1234567891011&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;hello_maven&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release 为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!-- jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包--&gt;&lt;packaging&gt;打包类型&lt;/packaging&gt; 依赖范围A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括： compile：编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包 。 provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依 赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。 runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。 test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如：junit。由于运行时不需要所以 test 范围依赖不会被打包。 system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system 依赖不推荐使用。 默认值： 默认引入的 jar 包 ——- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ） servlet-api 、jsp-api —- — provided （编译、测试 有效， 运行时无效 防止和 tomcat 下 jar 冲突） jdbc 驱动 jar 包 —- runtime （测试、运行 有效 ） junit —– test （测试有效） 依赖范围由强到弱的顺序是：compile &gt; provided &gt; runtime &gt; test 项目中添加 &lt;scope&gt;&lt;/scope&gt; ，来规定依赖范围： 设置 jdk 编译版本这里使用 jdk1.8，需要设置编译版本为 1.8，这里需要使用 maven 的插件来设置： 在 pom.xml 中加入： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Web 工程 编写 servlet 编写 JSP ![image-20200714095621187](/Users/liyihua/Library/Application Support/typora-user-images/image-20200714095621187.png) 在 web.xml 中配置 servlet 访问路径 如： 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/HelloMaven&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 添加 tomcat7 插件123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/HelloMaven&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt; 此时点击 idea 最右侧 Maven Projects，就可以看到新添加的 tomcat7 插件。双击 tomcat7 插件下 tomcat7:run 命令直接运行项目： 手动输入 tomc7:run 命令运行项目： 总结pom 基本配置 &lt;project&gt; ：文件的根节点 . &lt;mo delversion&gt; ： pom.xml 使用的对象模型版本 &lt;groupId&gt; ：项目名称，一般写项目的域名 &lt;artifactId&gt; ：模块名称，子项目名或模块名称 &lt;version&gt; ：产品的版本号 . &lt;packaging&gt; ：打包类型，一般有 jar、war、pom 等 &lt;name&gt; ：项目的显示名，常用于 Maven 生成的文档。 &lt;description&gt; ：项目描述，常用于 Maven 生成的文档 &lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标 &lt;build&gt; ：项目构建配置，配置编译、运行插件等。 参考文献 黑马程序员（Java） —- Maven基础","link":"/p/131014202007/"},{"title":"MyBatis 学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China MyBatis 框架概述 mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 Mybatis 框架快速入门有如下一个数据库表： 123456789101112131415CREATE TABLE UserMyBatis( id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(32) NOT NULL COMMENT '用户名称', birthday DATETIME DEFAULT NULL COMMENT '生日', sex CHAR(1) DEFAULT NULL COMMENT '性别', address VARCHAR(256) DEFAULT NULL COMMENT '地址') ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into UserMyBatis(id, username, birthday, sex, address)values (41, '唐老鸭', '2018-02-27 17:47:08', '女', '北京'), (42, '米老鼠', '2018-03-02 15:09:37', '男', '上海'), (43, '小叮当', '2018-03-04 11:34:34', '男', '广州'), (45, '野比大雄', '2018-03-04 12:04:06', '男', '深圳'), (46, '静香', '2018-03-07 17:37:26', '女', '成都'), (48, '小马宝莉', '2018-03-08 11:44:00', '女', '重庆'); 创建 maven 工程 添加 Mybatis3.4.5 的坐标 在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写 User 实体类 123456789101112131415161718192021222324252627282930313233343536public class User { private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"User [id=\" + id + \", username=\" + username + \", birthday=\" + birthday + \", sex=\" + sex + \", address=\" + address + \"]\"; }} 编写持久层接口 UserDaoImpl UserDaoImpl 接口就是我们的持久层接口（也可以写成 UserDao 或者 UserMapper） 1234567public interface UserDaoImpl { /** * 查询所有用户 * @return 所有用户的信息 */ List&lt;User&gt; findAll();} MyBatis 系统的核心设置 SqlMapConfig.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/Study\"/&gt; &lt;!-- 连接链接 --&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;!-- mysql用户名 --&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;!-- mysql密码 --&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper resource=\"my/stringbug/dao/UserDaoImpl.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写持久层接口的映射文件 UserDaoImpl.xml 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id=\"findAll\" resultType=\"my.stringbug.domain.User\"&gt;SELECT * FROM user;&lt;/select&gt;&lt;/mapper&gt; 测试 12345678910111213141516171819202122public class MyBatisTest { @Test public void FindAllUserInfoTest() throws IOException { // 读取配置文件 InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建 SqlSessionFactory 工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); // 使用工厂生产 SqlSession 对象 SqlSession sqlSession = factory.openSession(); // 使用 SqlSession 创建 Dao 接口的代理对象 UserDaoImpl userDao = sqlSession.getMapper(UserDaoImpl.class); // 使用代理对象执行方法 List&lt;User&gt; userList = userDao.findAll(); for (User user : userList) { System.out.println(user); } // 释放资源 sqlSession.close(); inputStream.close(); }} 此外，还可以在持久层借口中添加注解来定义SQL语句 12345678public interface UserDaoImpl { /** * 查询所有用户 * @return 所有用户的信息 */ @Select(\"SELECT * FROM UserMyBatis\") List&lt;User&gt; findAll();} 这样就可以不用编写持久层接口的映射文件了。 运行 MyBatisTest ，查询结果如下： 123456User [id=41, username=唐老鸭, birthday=Tue Feb 27 17:47:08 CST 2018, sex=女, address=北京]User [id=42, username=米老鼠, birthday=Fri Mar 02 15:09:37 CST 2018, sex=男, address=上海]User [id=43, username=小叮当, birthday=Sun Mar 04 11:34:34 CST 2018, sex=男, address=广州]User [id=45, username=野比大雄, birthday=Sun Mar 04 12:04:06 CST 2018, sex=男, address=深圳]User [id=46, username=静香, birthday=Wed Mar 07 17:37:26 CST 2018, sex=女, address=成都]User [id=48, username=小马宝莉, birthday=Thu Mar 08 11:44:00 CST 2018, sex=女, address=重庆] 入门案例目录结构","link":"/p/381022202007/"},{"title":"MySQL 中的事务","text":"@Author: YiHua Lee @Address: Guangdong province, China 事务的应用场景说明什么是事务: 在实际的开发过程中，一个业务操作如:转账，往往是要多次访问数据库才能完成的。转 账是一个用户扣钱，另一个用户加钱。如果其中有一条 SQL 语句出现异常，这条 SQL 就可能执行失败。 事务执行是一个整体，所有的 SQL 语句都必须执行成功。如果其中有 1 条 SQL 语句出现异常，则所有的 SQL 语句都要回滚，整个业务执行失败。 案例说明转账的操作 12345678-- 创建数据表CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES ('LeeHua', 1000), ('Tom', 1000); 模拟LeeHua给Tom转 500 元钱，一个转账的业务操作最少要执行下面的 2 条语句： 1234-- LeeHua账号-500UPDATE account SET balance = balance - 500 WHERE name='LeeHua';-- Tom账号+500UPDATE account SET balance = balance + 500 WHERE name='Tom'; 假设当LeeHua账号上-500 元,服务器崩溃了。Tom的账号并没有+500 元，数据就出现问题了。我们需要保证其中 一条 SQL 语句出现问题，整个转账就算失败。只有两条 SQL 都成功了转账才算成功。这个时候就需要用到事务。 手动提交事务MySQL 中可以有两种方式进行事务的操作： 手动提交事务 自动提交事务 手动提交事务的 SQL 语句 功能 SQL语句 开启事务 start transaction; 提交事务 commit; 回滚事务 rollback; 手动提交事务使用过程执行成功的情况：开启事务 –&gt; 执行多条 SQL 语句 –&gt; 成功提交事务 执行失败的情况：开启事务 –&gt; 执行多条 SQL 语句 –&gt; 事务的回滚 案例演示1模拟LeeHua给Tom转 500 元钱(成功) 目前数据库数据如下： 实现： 第一步：开启事务 1START TRANSACTION; 第二步：执行多条 SQL 语句 12UPDATE account SET balance = balance - 500 WHERE name='LeeHua';UPDATE account SET balance = balance + 500 WHERE name='Tom'; 第三步：转账成功，提交事务 1COMMIT; 查看一下表中的数据： 1SELECT * FROM account; 案例演示2模拟LeeHua给Tom转 500 元钱(失败) 目前数据库数据如下： 现在表中的数据如下： 实现： 第一步：开启事务 1START TRANSACTION; 第二步：执行多条 SQL 语句 12UPDATE account SET balance = balance - 500 WHERE name='Tom';UPDATE account SET balance = balance + 500 WHERE name='LeeHua'; 第三步：转账失败，回滚事务 1ROLLBACK; 总结: 如果事务中 SQL 语句没有问题，commit 提交事务，会对数据库数据的数据进行改变。 如果事务中 SQL 语句有问题，rollback 回滚事务，会回退到开启事务时的状态。 自动提交事务MySQL 默认每一条增删改语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕，自动提交事务，MySQL 默认开始自动提交事务。 查看 MySQL 是否开启自动提交事务 1SELECT @@autocommit; @@表示全局变量，1 表示开启，0 表示关闭 取消自动提交事务 1SET @@autocommit = 0; 查看 MySQL 是否开启自动提交事务 1SELECT @@autocommit; 案例演示3取消自动提交事务，模拟LeeHua收入500元。 表中的数据如下： 取消自动提交事务： 1SET @@autocommit = 0; 实现： 使用下面这条语句，模拟LeeHua收入500元 1UPDATE account SET balance = balance + 500 WHERE name='LeeHua'; 查看表中的数据如下 发现数据并没有发生改变。为什么呢？其实是我们前面取消了自动提交事务，所以还要执行 commit 提交任务 1COMMIT; 这个时候，再查看表中的数据如下 事务原理其实事务开启之后, 所有的操作都会临时保存到事务日志中, 事务日志只有在得到 commit 命令才会同步到数据表 中，其他任何情况都会清空事务日志(rollback，断开连接)。 事务的步骤 客户端连接数据库服务器，创建连接时创建此用户临时日志文件 开启事务以后，所有的操作都会先写入到临时日志文件中 所有的查询操作从表中查询，但会经过日志文件加工后才返回 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件 回滚点什么是回滚点在某些成功的操作完成之后，后续的操作有可能成功，有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点。 回滚点的操作语句 回滚点的操作语句 语句 设置回滚点 savepoint 名字 回到回滚点 rollback to 名字 案例演示4如下图，表中的数据：LeeHua有1000元，Tom也有1000元 实现如下操作： LeeHua欠Tom 50元，LeeHua要还钱给Tom。 开启事务 LeeHua还10元钱给Tom。 LeeHua还30元钱给Tom。 设置回滚点 LeeHua还40元钱给Tom。 这时候发现，钱还多了，回到回滚点。 LeeHua这时候还欠Tom 10元钱，LeeHua 还10元钱给Tom。 提交事务 具体操作如下： 开启事务 1START TRANSACTION; LeeHua还10元钱给Tom。 1UPDATE account SET balance = balance - 10 WHERE name='LeeHua'; 1UPDATE account SET balance = balance + 10 WHERE name='Tom'; LeeHua还30元钱给Tom。 1UPDATE account SET balance = balance - 30 WHERE name='LeeHua'; 1UPDATE account SET balance = balance + 30 WHERE name='Tom'; 设置回滚点 1SAVEPOINT Four_Time; LeeHua还40元钱给Tom。 1UPDATE account SET balance = balance - 40 WHERE name='LeeHua'; 1UPDATE account SET balance = balance + 40 WHERE name='Tom'; 这时候发现，钱还多了，回到回滚点。 1ROLLBACK TO Four_Time; LeeHua这时候还欠Tom 10元钱，LeeHua 还10元钱给Tom。 1UPDATE account SET balance = balance - 10 WHERE name='LeeHua'; 1UPDATE account SET balance = balance + 10 WHERE name='Tom'; 发现没错了，LeeHua一共还了50元钱给Tom，提交事务 1COMMIT; 总结：设置回滚点可以让我们在失败的时候回到回滚点，而不是回到事务开启的时候。 事务的隔离级别事务的四大特性 ACID 事务特性 含义 原子性(Atomicity) 每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都失败。 一致性(Consistency) 事务在执行前数据库的状态与执行后数据库的状态保持一致。如:转账前 2 个人的 总金额是 2000，转账后 2 个人总金额也是 2000 隔离性(Isolation) 事务与事务之间不应该相互影响，执行时保持隔离的状态。 持久性(Durability) 一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 事务的隔离级别事务在操作时的理想状态：所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个 数据。可能引发并发访问的问题： 并发访问的问题 含义 脏读 一个事务读取到了另一个事务中尚未提交的数据 不可重复读 一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这 是事务 update 时引发的问题 幻读 一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致 的，这是 insert 或 delete 时引发的问题 12备注：脏读非常危险的，比如张三向李四购买商品，张三开启事务，向李四账号转入 500 块，然后打电话给李四说钱已经转了。李四一查询钱到账了，发货给张三。张三收到货后回滚事务，李四的再查看钱没了。 MySQL 数据库有四种隔离级别上面的级别最低，下面的级别最高。“是”表示会出现这种问题，“否”表示不会出现这种问题： 级别 名字 隔离级别 脏读 不可重复读 幻读 数据库默认隔离级别 1 读未提交 read uncommitted 是 是 是 2 读已提交 read committed 否 是 是 Oracle 和 SQL Server 3 可重复读 repeatable read 否 否 是 MySQL 4 串行化 serializable 否 否 否 1备注：隔离级别越高，性能越差，安全性越高。 MySQL 事务隔离级别相关的命令查询全局事务隔离级别1SELECT @@tx_isolation; 如：MySQL数据库默认的隔离级别 设置事务隔离级别，需要退出 MySQL 再重新登录才能看到隔离级别的变化1SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;","link":"/p/541406202005/"},{"title":"MySQL 中的运算符","text":"@Author: YiHua Lee @Address: Guangdong province, China 比较运算符 比较运算符 说明 &gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt; &lt;&gt;在 SQL 中表示不等于，在 mysql 中也可以使用!= 没有== BETWEEN…AND 在一个范围之内，如:between 100 and 200 相当于条件在 100 到 200 之间，包头又包尾 IN(集合) 集合表示多个值，使用逗号分隔 LIKE ‘张%’ 模糊查询 IS NULL 查询某一列为 NULL 的值，注:不能写=NULL 逻辑运算符 逻辑运算符 说明 and 或 &amp;&amp; 与，SQL 中建议使用前者，后者并不通用。 or 或 || 或 not 或 ! 非 MySQL通配符 通配符 说明 % 匹配任意多个字符串 _ 匹配一个字符","link":"/p/341406202005/"},{"title":"MySQL 之操作数据库","text":"@Author: YiHua Lee @Address: Guangdong province, China 创建数据库创建数据库的几种方式创建数据库1CREATE DATABASE 数据库名; 如： 创建一个数据库名为 db_1 的数据库。 判断数据库是否已经存在，不存在则创建数据库1CREATE DATABASE IF NOT EXISTS 数据库名; 如： 假如数据库 db_2 不存在，那么就创建一个名为 db_2 的数据库。 创建数据库并指定字符集1CREATE DATABASE 数据库名 CHARACTER SET 字符集; 如： 创建一个名为 db_3 的数据库，并指定字符集为 utf8 查看数据库查看所有数据库12SHOW DATABASES;备注：使用DataGrip操作，按 tab 键可以自动补全关键字 查看某个数据库的定义信息1SHOW CREATE DATABASE 数据库名; 如： 查看数据库 “library” 的定义信息。 修改数据库修改数据库默认的字符集1ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集; 如： 将 db_3 数据库的字符集改成 gbk 删除数据库删除数据库的语法1DROP DATABASE 数据库名; 如： 删除 db_2 数据库 使用数据库查看正在使用的数据库1SELECT DATABASE(); 使用/切换数据库1USE 数据库名; 如：现在正在使用 db_1 数据库，想要切换为 db_2 数据库 操作数据库的一道面试题在 MySQL 数据库软件中，有如下三个数据库: 登录数据库之后，输入语句： 1SELECT DATABASE Study; 运行结果是什么? 答：这是一条错误的语句，如果要选中一个数据库，应该使用： 1USE Study;","link":"/p/331106202005/"},{"title":"MySQL 之操作表中数据","text":"@Author: YiHua Lee @Address: Guangdong province, China 插入记录插入全部字段所有的字段名都写出来 12INSERT INTO 表名 (字段名1, 字段名2, 字段名3, ...) VALUES (值1, 值2, 值3, ...);或 不写字段名 1INSERT INTO 表名 VALUES (值1, 值2, 值3, ...); 插入部分数据1INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 备注： 1234567891、插入的数据应与字段的数据类型相同2、数据的大小应在列的规定范围内，例如:不能将一个长度为 80 的字符串加入到长度为 40 的列中。3、在 values 中列出的数据位置必须与被加入的列的排列位置相对应。4、字符和日期型数据应包含在单引号中。5、不指定列或使用 null，表示插入空值。 蠕虫复制蠕虫复制：将一张已经存在的表中的数据复制到另一张表中。 语法格式将“表名2”中的所有的列复制到“表名1”中 1INSERT INTO 表名1 SELECT * FROM 表名2; 只复制部分列 1INSERT INTO 表名1 (列1, 列2, ...) SELECT (列1, 列2, ...) FROM 表名2; 更新表记录不带条件修改数据不带条件的修改数据，即修改所有的行。 1UPDATE 表名 SET 字段名=值; 如： 1UPDATE students SET name='哆啦A梦'; 将students表中，字段名为name的值都修改为 哆啦A梦 带条件修改数据1UPDATE 表名 SET 字段名=值 WHERE 字段名=值; 如： 1UPDATE students SET name='哆啦A梦' WHERE id=2018001; 将students表中，字段名为name的值修改为 哆啦A梦，前提是id=2018001 删除表记录不带条件删除数据1DELETE FROM 表名; 带条件删除数据1DELETE FROM 表名 WHERE 字段名=值; 使用 truncate 删除表中所有记录1TRUNCATE TABLE 表名; truncate 和 delete 的区别truncate 相当于删除表的结构，再创建一张表。 查询表中的数据简单查询查询表所有行和列的数据1SELECT * FROM 表名; 查询指定列1SELECT 字段名1, 字段名2, 字段名3, ... FROM 表名; 指定列的别名进行查询对列指定别名1SELECT 字段名1 AS 别名1, 字段名2 AS 别名2, ... FROM 表名; 如： 1SELECT name AS '姓名', age AS '年龄' ... FROM students; 查看students表中的name字段和age字段的记录，其中name字段指定别名为 “姓名”，age字段指定别名为 “年龄”。 对列和表同时指定别名1SELECT 字段名1 AS 别名1, 字段名2 AS 别名2, ... FROM 表名 AS 别名; 如： 1SELECT name AS '姓名', age AS '年龄' ... FROM students AS '学生信息表'; 查看students表中的name字段和age字段的记录，其中name字段指定别名为 “姓名”，age字段指定别名为 “年龄”，students表指定别名为 “学生信息表”。 清除重复值查询指定列并且结果不出现重复数据 1SELECT DISTINCT 字段名 FROM 表名; 如： 12345-- 查询学生来至于哪些地方select address from student;-- 去掉重复的记录select distinct address from student; 查询学生来至于哪些地方 查询结果参与运算某列数据和固定值运算1SELECT 列名1 + 固定值 FROM 表名; 某列数据和其他列数据参与运算12SELECT 列名1 + 列名2 FROM 表名;注意: 参与运算的必须是数值类型 条件查询如果没有查询条件，则每次查询所有的行。实际应用中，一般要指定查询的条件。对记录进行过滤。 条件查询的语法： 1SELECT 字段名 FROM 表名 WHERE 条件;","link":"/p/401106202005/"},{"title":"MySQL 之操作表结构","text":"@Author: YiHua Lee @Address: Guangdong province, China 创建表创建表的格式1234CREATE TABLE 表名 ( 字段名1 字段类型1, 字段名2 字段类型2); 具体操作创建student表包含id，name，birthday字段 12345CREATE TABLE student ( id INT, name VARCHAR(20), birthday DATE); 查看表查看某个数据库中的所有表1SHOW TABLES; 查看表结构1DESCRIBE 表名; 或 1DESC 表名; DESCRIBE 的缩写为 DESC 查看创建表的 SQL 语句1SHOW CREATE TABLE 表名; 如： 1SHOW CREATE TABLE student; 查看创建student表时的SQL语句 快速创建一个表结构相同的表1CREATE TABLE 新表名 LIKE 旧表名; 如： 1CREATE TABLE new_tb LIKE old_tb; 快速创建一个表，表名为new_tb，结构与表old_tb的结构相同 删除表直接删除表1DROP TABLE 表名; 判断表是否存在，如果存在则删除表1DROP TABLE IF EXISTS 表名; 修改表的结构添加表列 —— ADD1ALTER TABLE 表名 ADD 列名 类型; 如： 1ALTER TABLE student ADD id INT; 向student表中添加个列字段，列名为id，该列存储的数据的类型为INT类型 修改列类型 —— MODIFY1ALTER TABLE 表名 MODIFY 列名 新的类型; 如： 1ALTER TABLE student MODIFY name VARCHAR(50); 将student表中的 name 列的类型修改为 VARCHAR(50) 类型 修改列名 —— CHANGE1ALTER TABLE 表名 CHANGE 旧列名 新列名 类型; 如： 1ALTER TABLE student CHANGE remark intro VARCHAR(30); 将student表中的remark字段名改成intro，类型varchar(30) 删除列 —— DROP1ALTER TABLE 表名 DROP 列名; 如： 1ALTER TABLE student DROP intro; 删除student表中的字段intro 修改表名 —— RENAME1RENAME TABLE 表名 TO 新表名; 如： 1RENAME TABLE student TO student2; 将学生表student改名成student2 修改字符集 —— CHARACTER SET1ALTER TABLE 表名 CHARACTER SET 字符集; 如： 1ALTER TABLE student CHARACTER SET gbk; 将student表的编码修改成gbk","link":"/p/361106202005/"},{"title":"MySQL 内部设置的编码与表中定义的编码问题","text":"@Author: YiHua Lee @Address: Guangdong province, China 有时候，我们向表中插入中文数据的字符串，可是却不能向表中插入该中文数据的字符串，其实是编码解码问题。MySQL 内部设置的编码与定义表的时候的编码不同，导致编码异常，要么就是不能够将数据插入到数据表中，要么就是数据已经插入到了编码表中了，可是却会出现乱码的情况。下面，是我个人的解决方案，能够实现插入中文数据： 查看 MySQL 内部设置的编码首先就是要查看 MySQL 内部设置的编码。查看包含character开头的全局变量 1SHOW VARIABLES LIKE 'character%'; 执行结果： 解决方案修改MySQL内部设置的编码修改 client、connection、results、database、server的编码为 GBK 或 UTF8 修改客户端的编码为 UTF8 1SET character_set_client = utf8; 修改连接的编码为 UTF8 1SET character_set_connection = utf8; 修改查询的结果编码为 UTF8 1SET character_set_results = utf8; 修改数据库编码为 UTF8 1SET character_set_database = utf8; 修改数据库服务器的编码为 UTF8 1SET character_set_server = utf8; 再次查看MySQL内部编码，查看是否修改成功 1SHOW VARIABLES LIKE 'character%'; 修改表中设置的编码查看创建表的SQL语句1SHOW CREATE TABLE 表名; 如students表： 1SHOW CREATE TABLE students; 该表是我为了测试已经创建好的，结果如下： 1234567CREATE TABLE `students` ( `Id` int(30) NOT NULL, `Name` varchar(10) DEFAULT NULL, `Age` int(4) DEFAULT NULL, `Gender` varchar(25) DEFAULT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1 可以看到CHARSET=latin1，即students表的编码格式为latin1。 修改表中的编码格式1ALTER TABLE 表名 CONVERT TO CHARACTER SET 新编码格式 COLLATE 排序规则; 如上面查看的students表： 1ALTER TABLE students CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; 将students表的编码格式修改为utf8，MySQL中的排序规则为utf8_general_ci 修改成功后，再次查看student表的SQL： 1234567CREATE TABLE `students` ( `Id` int(30) NOT NULL, `Name` varchar(10) DEFAULT NULL, `Age` int(4) DEFAULT NULL, `Gender` varchar(25) DEFAULT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 发现已经修改成功了。这个时候就可以向students表中添加中文数据了。","link":"/p/431106202005/"},{"title":"MySQL 多表查询","text":"@Author: YiHua Lee @Address: Guangdong province, China 多表查询的分类 内连接 隐式内连接 显式内连接 外连接 左外连接 右外连接 内连接用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如:从表.外键=主表.主键 隐式内连接隐式内连接：看不到 JOIN 关键字，条件使用 WHERE 指定 1SELECT 字段名 FROM 左表, 右表 WHERE 条件 如： 创建一个学生个人信息表 1234567CREATE TABLE students( Id INT(30), Name VARCHAR(10), Age INT(4), Gender VARCHAR(25), PRIMARY KEY(Id)); 创建一个学习成绩表 12345678910111213CREATE TABLE course( Id INT(30), Java INT(5), Python INT(5), MySQL INT(5), Hadoop INT(5), C INT(5), PHP INT(5), Linux INT(5), English INT(5), Math INT(5), CONSTRAINT id_course FOREIGN KEY(Id) REFERENCES students(Id)); 学习成绩表的外键连接学生个人信息表的主键。这个时候，如果我们想要查询学生的Java成绩， 1SELECT name, Java FROM students, course WHERE course.Id = students.Id; 显式内连接显示内连接：使用 INNER JOIN … ON 语句, 可以省略 INNER 1SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件 如： 还是上面创建的students表和course表 1SELECT * FROM students INNER JOIN course c ON students.Id = c.Id; 查询students表的所有信息，按ID插入course表的数据，一并查询出来。 外连接左外连接左外连接：使用 LEFT OUTER JOIN … ON，OUTER 可以省略 1SELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件 用左边表的记录去匹配右边表的记录，如果符合条件的则显示;否则，显示 NULL 。可以理解为：在内连接的基础上保证左表的数据全部显示。 右外连接右外连接:使用 RIGHT OUTER JOIN … ON，OUTER 可以省略 1SELECT 字段名 FROM 左表 RIGHT [OUTER] JOIN 右表 ON 条件 用右边表的记录去匹配左边表的记录，如果符合条件的则显示;否则，显示 NULL。可以理解为：在内连接的基础上保证右表的数据全部显示。","link":"/p/471406202005/"},{"title":"MySQL 数据库备份和还原","text":"@Author: YiHua Lee @Address: Guangdong province, China 备份的应用场景在服务器进行数据传输、数据存储和数据交换，就有可能产生数据故障。比如发生意外停机或存储介质损坏。 这时，如果没有采取数据备份和数据恢复手段与措施，就会导致数据的丢失，造成的损失是无法弥补与估量的。 使用mysqldump备份（导出）固定条件的数据库mysqldump 命令在终端使用。 导出整个数据库1mysqldump -u用户名 -p密码 数据库 &gt; 导出的文件名 如： 1234567-- 备份 library 数据库中的数据到 ~/Desktop/library.sql 文件中mysqldump -uRoot -p12345678 library &gt; ~/Desktop/library.sql备注：用户：Root密码：12345678要被备份的数据库：library备份后的数据库名称：~/Desktop/library.sql 导出一个数据表1mysqldump -u用户名 -p密码 数据库名 表名&gt; 导出的文件名 如： 1234567-- 备份 library 数据库中的 book 表数据到 ~/Desktop/library_book.sql 文件中mysqldump -uRoot -p12345678 library book &gt; ~/Desktop/library_book.sql备注：用户：Root密码：12345678要被备份的表：library 数据库中的 book 表备份后的数据库名称：~/Desktop/library_book.sql 批量导出多个数据库1mysqldump -u用户名 -p密码 --databases 数据库 导出的文件名 或 1mysqldump -u用户名 -p密码 -B 数据库 导出的文件名 导出所有数据库1mysqldump -u用户名 -p密码 -all-databases 导出的文件名 参数说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485--all-databases , -A导出全部数据库。mysqldump -uroot -p --all-databases--all-tablespaces , -Y导出全部表空间。mysqldump -uroot -p --all-databases --all-tablespaces--no-tablespaces , -y不导出任何表空间信息。mysqldump -uroot -p --all-databases --no-tablespaces--add-drop-database每个数据库创建之前添加drop数据库语句。mysqldump -uroot -p --all-databases --add-drop-database--add-drop-table每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用--skip-add-drop-table取消选项)mysqldump -uroot -p --all-databases (默认添加drop语句)mysqldump -uroot -p --all-databases –skip-add-drop-table (取消drop语句)--add-locks在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用--skip-add-locks取消选项)mysqldump -uroot -p --all-databases (默认添加LOCK语句)mysqldump -uroot -p --all-databases –skip-add-locks (取消LOCK语句)--allow-keywords允许创建是关键词的列名字。这由表名前缀于每个列名做到。mysqldump -uroot -p --all-databases --allow-keywords--apply-slave-statements在'CHANGE MASTER'前添加'STOP SLAVE'，并且在导出的最后添加'START SLAVE'。mysqldump -uroot -p --all-databases --apply-slave-statements--character-sets-dir字符集文件的目录mysqldump -uroot -p --all-databases --character-sets-dir=/usr/local/mysql/share/mysql/charsets--comments附加注释信息。默认为打开，可以用--skip-comments取消mysqldump -uroot -p --all-databases (默认记录注释)mysqldump -uroot -p --all-databases --skip-comments (取消注释)--compatible导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。mysqldump -uroot -p --all-databases --compatible=ansi--compact导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：--skip-add-drop-table --skip-add-locks --skip-comments --skip-disable-keysmysqldump -uroot -p --all-databases --compact--complete-insert, -c使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。mysqldump -uroot -p --all-databases --complete-insert--compress, -C在客户端和服务器之间启用压缩传递所有信息mysqldump -uroot -p --all-databases --compress--create-options, -a在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)mysqldump -uroot -p --all-databases--databases, -B导出几个数据库。参数后面所有名字参量都被看作数据库名。mysqldump -uroot -p --databases test mysql--debug输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.tracemysqldump -uroot -p --all-databases --debugmysqldump -uroot -p --all-databases --debug=” d:t:o,/tmp/debug.trace”--debug-check检查内存和打开文件使用说明并退出。mysqldump -uroot -p --all-databases --debug-check--debug-info输出调试信息并退出mysqldump -uroot -p --all-databases --debug-info--default-character-set设置默认字符集，默认值为utf8mysqldump -uroot -p --all-databases --default-character-set=latin1--delayed-insert采用延时插入方式（INSERT DELAYED）导出数据mysqldump -uroot -p --all-databases --delayed-insert--delete-master-logsmaster备份后删除日志. 这个参数将自动激活--master-data。mysqldump -uroot -p --all-databases --delete-master-logs--disable-keys对于每个表，用/*!40000 ALTER TABLE tbl_name DISABLE KEYS */;和/*!40000 ALTER TABLE tbl_name ENABLE KEYS */;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。mysqldump -uroot -p --all-databases --dump-slave该选项将导致主的binlog位置和文件名追加到导出数据的文件中。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，在命令前增加说明信息。该选项将会打开--lock-all-tables，除非--single-transaction被指定。该选项会自动关闭--lock-tables选项。默认值为0。mysqldump -uroot -p --all-databases --dump-slave=1mysqldump -uroot -p --all-databases --dump-slave=2--events, -E导出事件。mysqldump -uroot -p --all-databases --events--extended-insert, -e使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用--skip-extended-insert取消选项。mysqldump -uroot -p --all-databasesmysqldump -uroot -p --all-databases--skip-extended-insert (取消选项)--fields-terminated-by导出文件中忽略给定字段。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump -uroot -p test test --tab=”/home/mysql” --fields-terminated-by=”#”--fields-enclosed-by输出文件中的各个字段用给定字符包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump -uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=”#”--fields-optionally-enclosed-by输出文件中的各个字段用给定字符选择性包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump -uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=”#” --fields-optionally-enclosed-by =”#”--fields-escaped-by输出文件中的各个字段忽略给定字符。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump -uroot -p mysql user --tab=”/home/mysql” --fields-escaped-by=”#”--flush-logs开始导出之前刷新日志。请注意：假如一次导出多个数据库(使用选项--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--lock-all-tables或者--master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用--lock-all-tables 或者--master-data 和--flush-logs。mysqldump -uroot -p --all-databases --flush-logs--flush-privileges在导出mysql数据库之后，发出一条FLUSH PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。mysqldump -uroot -p --all-databases --flush-privileges--force在导出过程中忽略出现的SQL错误。mysqldump -uroot -p --all-databases --force--help显示帮助信息并退出。mysqldump --help--hex-blob使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。mysqldump -uroot -p --all-databases --hex-blob--host, -h需要导出的主机信息mysqldump -uroot -p --host=localhost --all-databases--ignore-table不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：--ignore-table=database.table1 --ignore-table=database.table2 ……mysqldump -uroot -p --host=localhost --all-databases --ignore-table=mysql.user--include-master-host-port在--dump-slave产生的'CHANGE MASTER TO..'语句中增加'MASTER_HOST=&lt;host&gt;，MASTER_PORT=&lt;port&gt;' mysqldump -uroot -p --host=localhost --all-databases --include-master-host-port--insert-ignore在插入行时使用INSERT IGNORE语句.mysqldump -uroot -p --host=localhost --all-databases --insert-ignore--lines-terminated-by输出文件的每行用给定字符串划分。与--tab选项一起使用，不能用于--databases和--all-databases选项。mysqldump -uroot -p --host=localhost test test --tab=”/tmp/mysql” --lines-terminated-by=”##”--lock-all-tables, -x提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭--single-transaction 和--lock-tables 选项。mysqldump -uroot -p --host=localhost --all-databases --lock-all-tables--lock-tables, -l开始导出前，锁定所有表。用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。mysqldump -uroot -p --host=localhost --all-databases --lock-tables--log-error附加警告和错误信息到给定文件mysqldump -uroot -p --host=localhost --all-databases --log-error=/tmp/mysqldump_error_log.err--master-data该选项将binlog的位置和文件名追加到输出文件中。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE MASTER命令前添加注释信息。该选项将打开--lock-all-tables 选项，除非--single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的--single-transaction选项）。该选项自动关闭--lock-tables选项。mysqldump -uroot -p --host=localhost --all-databases --master-data=1;mysqldump -uroot -p --host=localhost --all-databases --master-data=2;--max_allowed_packet服务器发送和接受的最大包长度。mysqldump -uroot -p --host=localhost --all-databases --max_allowed_packet=10240--net_buffer_lengthTCP/IP和socket连接的缓存大小。mysqldump -uroot -p --host=localhost --all-databases --net_buffer_length=1024--no-autocommit使用autocommit/commit 语句包裹表。mysqldump -uroot -p --host=localhost --all-databases --no-autocommit--no-create-db, -n只导出数据，而不添加CREATE DATABASE 语句。mysqldump -uroot -p --host=localhost --all-databases --no-create-db--no-create-info, -t只导出数据，而不添加CREATE TABLE 语句。mysqldump -uroot -p --host=localhost --all-databases --no-create-info--no-data, -d不导出任何数据，只导出数据库表结构。mysqldump -uroot -p --host=localhost --all-databases --no-data--no-set-names, -N等同于--skip-set-charsetmysqldump -uroot -p --host=localhost --all-databases --no-set-names--opt等同于--add-drop-table, --add-locks, --create-options, --quick, --extended-insert, --lock-tables, --set-charset, --disable-keys 该选项默认开启, 可以用--skip-opt禁用.mysqldump -uroot -p --host=localhost --all-databases --opt--order-by-primary如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。 mysqldump -uroot -p --host=localhost --all-databases --order-by-primary--password, -p连接数据库密码--pipe(windows系统可用)使用命名管道连接mysqlmysqldump -uroot -p --host=localhost --all-databases --pipe--port, -P连接数据库端口号--protocol使用的连接协议，包括：tcp, socket, pipe, memory.mysqldump -uroot -p --host=localhost --all-databases --protocol=tcp--quick, -q不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。mysqldump -uroot -p --host=localhost --all-databases mysqldump -uroot -p --host=localhost --all-databases --skip-quick--quote-names,-Q使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。mysqldump -uroot -p --host=localhost --all-databasesmysqldump -uroot -p --host=localhost --all-databases --skip-quote-names--replace使用REPLACE INTO 取代INSERT INTO.mysqldump -uroot -p --host=localhost --all-databases --replace--result-file, -r直接输出到指定文件中。该选项应该用在使用回车换行对（\\\\r\\\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。mysqldump -uroot -p --host=localhost --all-databases --result-file=/tmp/mysqldump_result_file.txt--routines, -R导出存储过程以及自定义函数。mysqldump -uroot -p --host=localhost --all-databases --routines--set-charset添加'SET NAMES default_character_set'到输出文件。默认为打开状态，使用--skip-set-charset关闭选项。mysqldump -uroot -p --host=localhost --all-databases mysqldump -uroot -p --host=localhost --all-databases --skip-set-charset--single-transaction该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。mysqldump -uroot -p --host=localhost --all-databases --single-transaction--dump-date将导出时间添加到输出文件中。默认为打开状态，使用--skip-dump-date关闭选项。mysqldump -uroot -p --host=localhost --all-databasesmysqldump -uroot -p --host=localhost --all-databases --skip-dump-date--skip-opt禁用–opt选项.mysqldump -uroot -p --host=localhost --all-databases --skip-opt--socket,-S指定连接mysql的socket文件位置，默认路径/tmp/mysql.sockmysqldump -uroot -p --host=localhost --all-databases --socket=/tmp/mysqld.sock--tab,-T为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。mysqldump -uroot -p --host=localhost test test --tab=&quot;/home/mysql&quot;--tables覆盖--databases (-B)参数，指定需要导出的表名。mysqldump -uroot -p --host=localhost --databases test --tables test--triggers导出触发器。该选项默认启用，用--skip-triggers禁用它。mysqldump -uroot -p --host=localhost --all-databases --triggers--tz-utc在导出顶部设置时区TIME_ZONE='+00:00' ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。mysqldump -uroot -p --host=localhost --all-databases --tz-utc--user, -u指定连接的用户名。--verbose, --v输出多种平台信息。--version, -V输出mysqldump版本信息并退出--where, -w只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。mysqldump -uroot -p --host=localhost --all-databases --where=” user=’root’”--xml, -X导出XML格式.mysqldump -uroot -p --host=localhost --all-databases --xml--plugin_dir客户端插件的目录，用于兼容不同的插件版本。mysqldump -uroot -p --host=localhost --all-databases --plugin_dir=”/usr/local/lib/plugin”--default_auth客户端插件默认使用权限。mysqldump -uroot -p --host=localhost --all-databases --default-auth=”/usr/local/lib/plugin/&lt;PLUGIN&gt;” 使用SOURCE命令，还原（导入）数据库source命令要进入mysql控制台使用。 1SOURCE 导入文件的路径; 步骤： 登录 MySQL 选中数据库 设置数据库编码，如果不设置，可能会出现乱码 使用 SOURCE 命令还原数据 查看还原结果 举例： 登录MySQL 1234mysql -uRoot -p12345678备注：用户名：Root密码：12345678 选中要被还原的数据库： 123USE library;备注：要被还原的数据库是：library 设置数据库编码： 1234567891011121314-- 客户端的编码SET character_set_client = utf8;-- 连接的编码SET character_set_connection = utf8;-- 查询的结果编码SET character_set_results = utf8;-- 数据库编码SET character_set_database = utf8;-- 数据库服务器的编码SET character_set_server = utf8; 使用 SOURCE 命令还原数据： 123SOURCE ~/Desktop/library.sql备注：导入文件的路径：~/Desktop/library.sql","link":"/p/391406202005/"},{"title":"MySQL 数据库表的约束","text":"@Author: YiHua Lee @Address: Guangdong province, China 数据库约束的种类 约束名 约束关键字 主键 primary key 唯一 unique 非空 not null 外键 foreign key 检查约束 check 注:mysql 不支持，sql支持 主键约束创建主键方式 在创建表的时候给字段添加主键 1字段名 字段类型 PRIMARY KEY 例1: 12345CREATE TABLE tb_info ( id INT PRIMARY KEY, name VARCHAR(30), age INT); 例2: 123456CREATE TABLE tb_info ( id INT, name VARCHAR(30), age INT, PRIMARY KEY(id)); 在已有表中添加主键 1ALTER TABLE 表名 ADD PRIMARY KEY(字段名); 例： 1ALTER TABLE tb_info ADD PRIMARY KEY(id); 删除主键的方式删除单表主键约束1ALTER TABLE 表名 DROP PRIMARY KEY; 删除有外键连接的表的主键第一步：解除外键约束 1ALTER TABLE 外键表 DROP FOREIGN KEY 外键名称 第二步：删除主键 1ALTER TABLE 主键表 DROP PRIMARY KEY; 如：删除tb1的主键 这里有两个表，tb2的外键连接tb1的主键 第一步：解除与tb2的外键约束 1ALTER TABLE tb2 DROP FOREIGN KEY id2; 第二步：删除tb1的主键约束 1ALTER TABLE tb1 DROP PRIMARY KEY; 主键自增12-- 表示自动增长(字段类型必须是整数类型)AUTO_INCREMENT 如： 12345CREATE TABLE tb ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(30), age INT); 默认地 AUTO_INCREMENT 的开始值是 1 创建表时指定起始值123CREATE TABLE 表名 ( 列名 INT PRIMARY KEY AUTO_INCREMENT) AUTO_INCREMENT=起始值; 如：指定起始值为5 12345CREATE TABLE tb ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(30), age INT) AUTO_INCREMENT=5; 创建好以后修改起始值12345ALTER TABLE 表名 AUTO_INCREMENT=起始值;备注：DELETE 和 TRUNCATE 对自增长的影响DELETE:删除所有的记录之后，自增长没有影响。TRUNCATE:删除以后，自增长又重新开始。 唯一约束唯一约束: 表中某一列不能出现重复的值 基本格式 1字段名 字段类型 UNIQUE 如：tb表中的 name 字段中的记录不能出现重复的 12345CREATE TABLE tb ( id INT, name VARCHAR(30) UNIQUE, age INT); 非空约束非空约束:某一列不能为null 基本语法格式 1字段名 字段类型 NOT NULL 如：tb表中的 id 字段不能出现null 12345CREATE TABLE tb ( id INT NOT NULL, name VARCHAR(30), age INT); 默认值基本语法格式 1字段名 字段类型 DEFAULT 默认值 如：tb表中的 age 字段的默认值为18 12345CREATE TABLE tb ( id INT, name VARCHAR(30), age INT DEFAULT 18); 外键约束创建外键约束新建表时增加外键1CONSTRAINT 外键约束名称 FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名) 如： 主表 123456CREATE TABLE tb1 ( id INT, name VARCHAR(30), age INT, PRIMARY KEY(id)); 从表 123456CREATE TABLE tb2 ( card INT, name VARCHAR(30), age INT, CONSTRAINT tb2_card FOREIGN KEY(card) REFERENCES tb1(id)); 从表的外键card，与主表的主键id关联，从表中外键约束的名为tb2_card。 已有表增加外键1ALTER TABLE 从表 ADD CONSTRAINT 外键约束名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主键字段名); 如： 表1 123456CREATE TABLE tb1 ( id INT, name VARCHAR(30), age INT, PRIMARY KEY(id)); 表2 12345CREATE TABLE tb2 ( card INT, name VARCHAR(30), age INT,); 在tb2表中添加外键约束，外键字段为card。连接tb1表中的主键，主键字段为id： 1ALTER TABLE tb2 ADD CONSTRAINT tb2_card FOREIGN KEY(card) REFERENCES tb1(id); 删除外键约束1ALTER TABLE 从表 DROP FOREIGN KEY 外键名称; 外键的级联级联操作：在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作。 级联操作语法 描述 ON UPDATE CASCADE 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新 ON DELETE CASCADE 级联删除 举例： 创建tb1表 123456CREATE TABLE tb1 ( id INT, name VARCHAR(30), age INT, PRIMARY KEY(id)); 创建tb2表 123456789-- 创建 tb2 表，添加级联更新和级联删除CREATE TABLE tb2 ( card INT, name VARCHAR(30), age INT, CONSTRAINT tb2_card FOREIGN KEY(card) REFERENCES tb1(id) ON UPDATE CASCADE ON DELETE CASCADE ); 这个时候，如果我们向tb1表中插入数据： 1INSERT INTO tb1 (id, name, age) VALUES (1001, 'LeeHua', 22) 那么，tb2中的card字段也会更新。 这个时候，如果主表执行删除，则会自动删除从表中的相应记录。","link":"/p/411406202005/"},{"title":"MySQL 用户管理和权限管理","text":"@Author: YiHua Lee @Address: Guangdong province, China 创建用户基本语法格式1CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 关键字说明 关键字 说明 用户名 将创建的用户名 主机名 ** ** 指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以 从任意远程主机登陆，可以使用通配符% 密码 ** ** 该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 具体操作 创建 user1 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123 1create user 'user1'@'localhost' identified by '123'; 创建 user2 用户可以在任何电脑上登录 mysql 服务器，密码为 123 1create user 'user2'@'%' identified by '123'; 1备注：创建的用户名都在 mysql 数据库中的 user 表中可以查看到，密码经过了加密。创建的新用户都是没什么权限的，需要授权。 给用户授权用户创建之后，没什么权限！需要给用户授权。 基本语法格式1GRANT 权限1, 权限2, ... ON 数据库名.表名 TO '用户名'@'主机名'; 关键字说明 关键字 说明 GRANT…ON…TO 授权关键字 权限 授予用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等。如果要授 予所有的权限则使用 ALL 数据库名.表名 该用户可以操作哪个数据库的哪些表。如果要授予该用户对所有数据库和表的相应操作 权限则可用表示，如.* ‘用户名‘@’主机名‘ 给哪个用户授权，注:有 2 对单引号 具体操作 给 user1 用户分配对 test 这个数据库操作的权限：创建表，修改表，插入记录，更新记录，查询 1grant create, alter, insert, update, select on test.* to 'user1'@'localhost'; 给 user2 用户分配所有权限，对所有数据库的所有表 1grant all on *.* to 'user2'@'%'; 撤销用户权限基本语法格式1REVOKE 权限1, 权限2, ... ON 数据库.表名; 关键字说明 关键字 说明 REVOKE…ON…FROM 撤销授权的关键字 权限 用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等，所有的权 限则使用 ALL 数据库名.表名 对哪些数据库的哪些表，如果要取消该用户对所有数据库和表的操作权限则可用表 示，如.* ‘用户名‘@’主机名‘ 给哪个用户撤销 具体操作 撤销 user1 用户对 test 数据库所有表的操作的权限 1revoke all on test.* from 'user1'@'localhost'; 查看用户权限基本语法格式1SHOW GRANTS FOR '用户名'@'主机名'; 具体操作 查看 user1 用户的权限 1SHOW GRANTS FOR 'user1'@'localhost'; 删除用户基本语法格式1DROP USER '用户名'@'主机名'; 具体操作 删除 user2 1drop user 'user2'@'%'; 修改管理员密码基本语法格式该语句是在控制台使用的，不是登录MySQL里面使用的。 12mysqladmin -u用户名 -p password 新密码注意：需要在未登陆 MySQL 的情况下操作，新密码不需要加上引号。 具体操作将 root 管理员的新密码改成 123456 第一步：cmd上（macOS在终端）输入下面的语句 1mysqladmin -uroot -p password 123456 第二步：输入上面这条语句后，按回车，会提示输入旧密码，输入旧密码，再按回车就修改成功了。 1备注：假如修改失败，找不到mysqladmin命令，说明MySQL环境变量没有配置好。自行查找相关资料配置环境变量。 修改普通用户密码基本语法格式该语句是要登录MySQL才能使用的。 12set password for '用户名'@'主机名' = password('新密码');注意：需要在登陆 MySQL 的情况下操作，新密码要加单引号。 具体操作 将’user1’@’localhost’的密码改成’666666’ 1set password for 'user1'@'localhost' = password('666666');","link":"/p/571406202005/"},{"title":"MySQL 查询语句","text":"@Author: YiHua Lee @Address: Guangdong province, China 排序查询通过 ORDER BY 子句，可以将查询出的结果进行排序(排序只是显示方式，不会影响数据库中数据的顺序) 12ASC: 升序，默认值DESC: 降序 单列排序只按某一个字段进行排序，单列排序。 1SELECT 字段名 FROM 表名 WHERE 字段=值 ORDER BY 字段名 [ASC|DESC]; 如： 12 -- 查询所有数据,使用年龄降序排序select * from student order by age desc; 组合排序同时对多个字段进行排序，如果第 1 个字段相等，则按第 2 个字段排序，依次类推。 1SELECT 字段名 FROM 表名 WHERE 字段=值 ORDER BY 字段名1 [ASC|DESC], 字段名2 [ASC|DESC]; 如： 12-- 查询所有数据,在年龄降序排序的基础上，如果年龄相同再以数学成绩升序排序 select * from student order by age desc, math asc; 聚合函数平常我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询， 它是对一列的值进行计算，然后返回一个结果值。聚合函数会忽略空值 NULL。 五个聚合函数 SQL 中的聚合函数 作用 max(列名) 求这一列的最大值 min(列名) 求这一列的最小值 avg(列名) 求这一列的平均值 count(列名) 统计这一列有多少条记录 sum(列名) 对这一列求总和 语法1SELECT 聚合函数(列名) FROM 表名; 如： 12345-- 查询学生总数select count(id) as 总人数 from student;或select count(*) as 总人数 from student; 由于聚合函数会忽略空值NULL，建议如果统计个数则不要使用有可能为 null 的列，但如果需要把 NULL 也统计进去，那么可以使用IFNULL()。 12-- 如果列名不为空，返回这列的值。如果为 NULL，则返回默认值。IFNULL(列名，默认值) 如： 1select count(ifnull(id,0)) from student; 分组查询分组查询是指使用 GROUP BY 语句对查询信息进行分组，相同数据作为一组。 1SELECT 字段1, 字段2, ... FROM 表名 GROUP BY 分组字段 [HAVING 条件]; GROUP BY 将分组字段结果中相同内容作为一组，并且返回每组的第一条数据，所以单独分组没什么用处。 分组的目的就是为了统计，一般分组会跟聚合函数一起使用。 例1：一个学生成绩表，该表中有 “性别” 字段和 “数学成绩” 字段。 12 -- 按性别进行分组，求男生和女生数学的平均分select sex, avg(math) from student3 group by sex; 实际上是将每组的 math 求了平均,返回每组统计的结果 例2： 12 -- 对分组查询的结果再进行过滤SELECT sex, COUNT(*) FROM student WHERE age &gt; 25 GROUP BY sex having COUNT(*) &gt;2; 查询student表中的不同性别的人的个数，要求年龄大于25岁，按性别分组并计算好不同性别的人的个数时，返回性别人数大于2的数据。 having 与 where 的区别 子名 作用 where 子句 1、对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，即先过滤 再分组。2、where 后面不可以使用聚合函数 having 子句 1、having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，即先分组再过滤。2、having 后面可以使用聚合函数 如： 1SELECT 字段1, 字段2, ... FROM 表名称 WHERE 筛选条件1 GROUP BY 字段3 having 筛选条件2; where要在分组之前，having要在分组之后。 筛选条件1不能是聚合函数，筛选条件2可以是聚合函数。 LIMIT语句LIMIT 是限制的意思，LIMIT 的作用就是限制查询记录的条数。 12SELECT 字段1 [AS 别名1], 字段2 [AS 别名2], ... FROM 表名 [WHERE子句] [GROUP BY子句] [HAVING 子句] [ORDER BY子句] [LIMIT子句]; LIMIT 语法格式 1LIMIT offset,length; 如： 12-- 查询学生表中数据，从第 3 条开始显示，显示 6 条。select * from student limit 2,6;","link":"/p/361406202005/"},{"title":"Python 操作 MongoDB 数据库","text":"@Author: YiHua Lee @Address: Guangdong province, China MongoDB是一个存储文档型的数据库（非关系型数据库） 利用pymongo连接MongoDB1234import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)# 或 pymongo.MongoClient('mongodb://localhost:23017/')# 默认端口为:27017 指定数据库12# 指定操作test数据库db = client.test 或 db = client['test'] 指定集合12# 指定一个集合要操作的集合studentscollection = db.students 或 collection = db['students'] 插入数据插入单条数据12# 插入一条数据insert_one()方法 1234567891011121314151617181920212223242526import pymongo# 连接MongoDBclient = pymongo.MongoClient(host='localhost', port=27017)# 指定数据库db = client.test# 指定集合collection = db.students# 数据student = { 'id': '20180001', 'name': 'Jordan', 'age': 20, 'gender': 'male'}# 利用insert_one()方法插入一条数据result = collection.insert_one(student)print(result)# 运行输出：&lt;pymongo.results.InsertOneResult object at 0x11089b448&gt;# 在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。# 使用 insert_one()和 insert_many()方法来分别插入单条记录和多条记录 插入多条数据12# 插入多条数据insert_many()方法 12345678910111213141516171819202122232425262728import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentsstudent1 = { 'id': '20180002', 'name': 'Lee Hua', 'age': 20, 'gender': 'male'}student2 = { 'id': '20180003', 'name': 'Mike', 'age': 21, 'gender': 'male'}result = collection.insert_many([student1, student2])print(result)print(result.inserted_ids)# 调用inserted_ids属性可以获取数据的_id列表# 运行输出：&lt;pymongo.results.InsertManyResult object at 0x110826d88&gt;[ObjectId('5d28b293e834575faf929428'), ObjectId('5d28b293e834575faf929429')] 查询查询一条数据12# 查询一条数据find_one() 123456789101112import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentsresult = collection.find_one({'name': 'Lee Hua'})print(result)# 输出：{'_id': ObjectId('5d28b293e834575faf929428'), 'id': '20180002', 'name': 'Lee Hua', 'age': 20, 'gender': 'male'} 查询多条数据 12# 查询一条数据find() 12345678910111213141516171819import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentsresult = collection.find()print(result)for r in result: print(r)# find()方法返回一个迭代器，用for循环逐条输出# 输出结果：&lt;pymongo.cursor.Cursor object at 0x10e0f7320&gt;{'_id': ObjectId('5d28ae0360105a198d9d501a'), 'id': '20180001', 'name': 'Jordan', 'age': 20, 'gender': 'male'}{'_id': ObjectId('5d28ae2d8b3d004feb604874'), 'id': '20180001', 'name': 'Jordan', 'age': 20, 'gender': 'male'}{'_id': ObjectId('5d28b293e834575faf929428'), 'id': '20180002', 'name': 'Lee Hua', 'age': 20, 'gender': 'male'}{'_id': ObjectId('5d28b293e834575faf929429'), 'id': '20180003', 'name': 'Mike', 'age': 21, 'gender': 'male'} 可以在这两个方法里面添加条件，如： 123456789find( { 'name': {'$regex': '^M.*'} })这里查找的是以'M'开头的名字的那些数据，$regex指定的是正则表达式，^M.*是一条正则表达式更多功能符号（如$regex）、数值比较符号的查看MongoDB官方文档：https://docs.mongodb.com/?searchProperty=manual 计数12345678910111213import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentscount = collection.count_documents( { 'id': {'$regex': '^(2018)'} })# 输出id为2018开头的数据的条数print(count) 排序123456789101112131415161718192021import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentsresult = collection.find().sort('id', pymongo.ASCENDING)for r in result: print(r)# 以id升序输出所有的数据：{'_id': ObjectId('5d28ae0360105a198d9d501a'), 'id': '20180001', 'name': 'Jordan', 'age': 20, 'gender': 'male'}{'_id': ObjectId('5d28ae2d8b3d004feb604874'), 'id': '20180001', 'name': 'Jordan', 'age': 20, 'gender': 'male'}{'_id': ObjectId('5d28b293e834575faf929428'), 'id': '20180002', 'name': 'Lee Hua', 'age': 20, 'gender': 'male'}{'_id': ObjectId('5d28b293e834575faf929429'), 'id': '20180003', 'name': 'Mike', 'age': 21, 'gender': 'male'}# sort()方法进行排序# pymongo.ASCENDING指定升序# pymongo.DESCENDING指定降序 偏移skip() 方法12345678910111213141516import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentsresults = collection.find().sort('id', pymongo.DESCENDING).skip(1)print( [ result['id'] for result in results ])# 输出：['20180002', '20180001', '20180001'] 1# skip(1)表示偏移1，即忽略前面一个元素 limit()方法123456789101112131415import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client.testcollection = db.studentsresults = collection.find().sort('id', pymongo.DESCENDING).skip(1).limit(2)print( [ result['id'] for result in results ])# 输出：['20180002', '20180001'] 1# limit(2) 即表示限制输出的数据条数为两条 注意：数据量很大时，不使用大的偏移量来查询数据。 更新update_one()方法1234567891011121314151617181920212223242526272829303132import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client['test']collection = db['students']# 查询条件：age &gt;= 20query_condition = { 'age': {'$gte': 20}}# 更新条件：数据的age加1update_condition = { '$inc': {'age': 1}}result = collection.update_one(query_condition, update_condition)print(result)print(result.matched_count, result.modified_count)# 输出：&lt;pymongo.results.UpdateResult object at 0x110a11c88&gt;1 1# 返回的结果是UpdateResul类型的# 调用matched_count属性，获得匹配数据的条数# 调用modified_count属性，获得影响数据的条数# $gte ： 大于等于# $inc ： 将字段递增指定的值# updata_one()更新与筛选器匹配的单个文档 update_many()方法123456789101112131415161718192021import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client['test']collection = db['students']query_condition = { 'age': {'$gte': 20}}update_condition = { '$inc': {'age': 1}}result = collection.update_many(query_condition, update_condition)print(result)print(result.matched_count, result.modified_count)# 输出：&lt;pymongo.results.UpdateResult object at 0x111c84448&gt;4 4 删除delete_one() 方法123456789101112import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client['test']collection = db['students']result = collection.delete_one({'age': 21})print(result.deleted_count)# delete_one()方法：删除第一条符合条件的数据# delete_count属性：获取删除数据的条数 delete_many() 方法1234567891011import pymongoclient = pymongo.MongoClient(host='localhost', port=27017)db = client['test']collection = db['students']result = collection.delete_many({'age': 21})print(result.deleted_count)# delete_many()方法：删除所有符合条件的数据 PyMongo的详细用法官方文档：http://api.mongodb.com/python/current/api/pymongo/collection.html","link":"/p/341430202004/"},{"title":"MySQL 表查询之子查询","text":"@Author: YiHua Lee @Address: Guangdong province, China 子查询的概念 一个查询的结果做为另一个查询的条件 有查询的嵌套，内部的查询称为子查询 子查询要使用括号 子查询结果的三种情况 子查询的结果是单行单列 子查询的结果是多行单列 子查询的结果是多行多列 子查询的结果是一个值1SELECT 查询字段 FROM 表 WHERE 字段=(子查询); 如： 创建一个学生个人信息表 1234567CREATE TABLE students( Id INT(30), Name VARCHAR(10), Age INT(4), Gender VARCHAR(25), PRIMARY KEY(Id)); 创建一个学习成绩表 12345678910111213CREATE TABLE course( Id INT(30), Java INT(5), Python INT(5), MySQL INT(5), Hadoop INT(5), C INT(5), PHP INT(5), Linux INT(5), English INT(5), Math INT(5), CONSTRAINT id_course FOREIGN KEY(Id) REFERENCES students(Id)); 案例：要查询Java成绩最高的学生的信息 1234567SELECT * FROM students WHERE id = ( SELECT id FROM course WHERE Java = ( SELECT MAX(Java)FROM course ) ); 子查询结果是多行单列子查询结果是单例多行，结果集类似于一个数组，父查询使用 IN 运算符，或者BETWEEN … AND … 1SELECT 查询字段 FROM 表 WHERE 字段 IN (子查询); 案例：要查询低于Java平均分的学生的信息 12345SELECT * FROM studentsWHERE id BETWEEN (SELECT MIN(id) FROM course WHERE Java &lt; (SELECT AVG(Java) FROM course)) AND (SELECT MAX(id) FROM course WHERE Java &lt; (SELECT AVG(Java) FROM course)); 子查询的结果是多行多列子查询结果只要是多列，肯定在 FROM 后面作为表 1SELECT 查询字段 FROM (子查询) 表别名 WHERE 条件; 子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段 如：查询学生的信息和Java、Python、English、Math成绩，且要求Math成绩大于平均分 第一步：查询Java、Python、English、Math所有成绩 1SELECT Java, Python, English, Math, id FROM course AS course1 第二步：查询Math成绩的平均分 1SELECT AVG(Math) FROM course 第三步：利用表连接，查询学生信息，和要求查询的学生科目，及分数要求 123SELECT * FROM studentsINNER JOIN (SELECT Java, Python, English, Math, id FROM course) AS course1 ON students.Id = course1.IdWHERE Math &gt; (SELECT AVG(Math) FROM course); 自查询总结： 子查询结果只要是单列，则在 WHERE 后面作为条件 子查询结果只要是多列，则在 FROM 后面作为表进行二次查询","link":"/p/491406202005/"},{"title":"Python 操作 MySQL 数据库","text":"@Author: YiHua Lee @Address: Guangdong province, China 利用PyMySQL连接MySQL连接数据库123456789101112131415161718192021222324import pymysql# 连接MySQL MySQL在本地运行 用户名为root 密码为123456 默认端口3306db = pymysql.connect(host='localhost', user='root', password='123456', port=3306)# cursor()方法获得MySQL的操作游标，利用游标来执行SQL语句，其中执行方法为execute()cursor = db.cursor()# 获取MySQL的当前版本cursor.execute('SELECT VERSION()')# fetchone()方法获得第一条数据，即版本号data = cursor.fetchone()print('Database version:', data)# 创建一个名为reptile的数据库,默认编码为utf8mb4cursor.execute(\"CREATE DATABASE reptile DEFAULT CHARACTER SET utf8mb4\")db.close()# 运行输出：Database version: ('8.0.16',)# 运行生成一个名为reptile的数据库 创建表1234567891011121314151617import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()sql = '''CREATE TABLE IF NOT EXISTS students ( id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id) )'''# 创建一个名为students的数据表，主键为idcursor.execute(sql)db.close()# 运行创建一个数据表 插入数据方式1 1234567891011121314151617181920212223242526import pymysqlid = '20180001'user = 'Lee Hua'age = 20# 连接数据库db = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')# 获得MySQL的操作游标cursor = db.cursor()sql = '''INSERT INTO students(id, name, age) VALUES(%s %s %s)'''try: # 执行 cursor.execute(sql, (id, user, age)) # 数据插入、更新、删除操作，都需要用到commit()方法才能生效 db.commit()except: # 调用rollback()执行数据回滚，相当于什么都没有发生过 db.rollback()db.close()# 运行，数据被插入到数据表中 方式2 1234567891011121314151617181920212223242526272829import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()data = { 'id': '20180002', 'user': 'Lao wang', 'age': 19}table_name = 'students'keys = ', '.join(data.keys()) # id, user, agevalues = ', '.join(['%s'] * len(data)) # ['%s', '%s', ......] len(data)个'%s'sql = '''INSERT INTO {table_name}({keys}) VALUES({values})'''.format(table_name=table_name, keys=keys, values=values)# sql = INSERT INTO students(id, name, age) VALUES(%s %s %s)try: tuple_ = tuple(data.values()) if cursor.execute(sql, tuple_): print('成功插入数据') db.commit()except: print('插入数据失败') db.rollback()db.close() 更新数据12345678910111213import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()sql = 'UPDATA students SET age = %s WHERE name = %s'try: cursor.execute(sql, (25, 'Bob')) db.commit()except: db.rollback()db.close() 实现去重（如果数据存在，则更新数据；如果数据不存在，则插入数据。） 12345678910111213141516171819202122232425262728293031import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()data = { 'id': '20180002', 'user': 'Lao wang', 'age': 19}table_name = 'students'keys = ', '.join(data.keys()) # keys = id, name, agevalues = ', '.join(['%s'] * len(data)) # values = %s, %s, %supdate = ', '.join( [\" {key} = %s\".format(key=key) for key in data]) # id = %s, name = %s, age = %ssql = '''INSERT INTO {table_name}({keys}) VALUES({values}) ON DUPLICATE KEY update'''.format(table_name=table_name, keys=keys, values=values)# ON DUPLICATE KEY UPDATE 表示：如果主键已经存在，那么就执行更新操作try: tuple_ = tuple(data.values()) if cursor.execute(sql, tuple_): print('成功插入数据') db.commit()except: print('插入数据失败') db.rollback()db.close() 删除数据123456789101112131415161718import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()table = 'students'condition = 'age &gt; 20'sql = 'DELETE FROM {table} WHERE {conditon}'.format(table=table, conditon=condition)try: cursor.execute(sql) db.commit()except: db.rollback()db.close()# 删除age &gt; 20的数据 查询数据123456789101112131415161718import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()sql = 'SELECT * FROM students WHERE age &gt;= 20'try: cursor.execute(sql) print('Count:', cursor.rowcount) # 调用cursor的rowcount属性，获取查询结果的条数 one = cursor.fetchone() # 获取结果的第一条信息 print('One:', one) result = cursor.fetchall() # 获取结果的所有数据 print('Result:', result) print('Result Type:', type(result)) for row in result: print(row)except: print('Error') 12345# 输出：Count: 0One: NoneResult: ()Result Type: &lt;class 'tuple'&gt; 一次性查询所有数据 123456789101112131415import pymysqldb = pymysql.connect(host='localhost', user='用户名', password='密码', port=3306, db='reptile')cursor = db.cursor()sql = 'SELECT * FROM students WHERE age &gt;= 20'try: cursor.execute(sql) print('Count:', cursor.rowcount) # 调用cursor的rowcount属性，获取查询结果的条数 row = cursor.fetchone() # 获取结果的第一条数据 while row: print('Row:', row) row = cursor.fetchone()except: print('Error')","link":"/p/151430202004/"},{"title":"Python 极客验证码识别","text":"@Author: YiHua Lee @Address: Guangdong province, China 简单验证码识别 12345678910111213141516171819202122232425import tesserocrfrom PIL import Imageimage = Image.open('PFET.jpg')# 利用 Image 对象的 convert() 方法传入参数 \"L\" ，即可将图片转化为灰度图像image = image.convert('L')# 阈值默认为127threshold = 127table = []for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1)image = image.point(table, '1')image = image.convert('1')image.show()result = tesserocr.image_to_text(image)print(result) 12# 输出：PFRT 极验滑动验证码的识别极客验证官网 数据初始化1234567891011EMAIL = 'zcs@163.com'PASSWORD = '123'BORDER = 6class CrackGeetest(): def __init__(self): self.url = 'https://account.geetest.com/login' self.browser = webdriver.Chrome() self.wait = WebDriverWait(self.browser, 10) self.email = EMAIL self.password = PASSWORD 获取验证按钮1234567891011def get_geetest_button(self): \"\"\" 获取初始验证按钮 :return: \"\"\" button = self.wait.until( EC.element_to_be_clickable( (By.CLASS_NAME, 'geetest_radar_tip') ) ) return button 获取验证码图片所在位置12345678910111213141516def get_position(self): \"\"\" 获取验证码位置 :return: 验证码位置元组(上, 下, 左, 右) \"\"\" img = self.wait.until( EC.presence_of_element_located( (By.CLASS_NAME, 'geetest_canvas_img') ) ) time.sleep(2) location = img.location size = img.size top, bottom, left, right = \\ location['y'], location['y'] + size['height'], location['x'], location['x'] + size['width'] return (top, bottom, left, right) 获取网页截图12345678910111213def get_screenshot(self): \"\"\" 获取网页截图 :return: 截图对象 \"\"\" screenshot = self.browser.get_screenshot_as_png() # 获取作为二进制数据的当前窗口的屏幕截图。 screenshot = Image.open(BytesIO(screenshot)) # Python在内存中读写数据，用到的模块是StringIO和BytesIO， # StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 return screenshot 获取滑块1234567891011def get_slider(self): \"\"\" 获取滑块 :return: 滑块对象 \"\"\" slider = self.wait.until( EC.element_to_be_clickable( (By.CLASS_NAME, 'geetest_slider_button') ) ) return slider 获取验证码图片截图12345678910111213def get_geetest_image(self, name='captcha.png'): \"\"\" 获取验证码图片 :return: 图片对象 \"\"\" top, bottom, left, right = self.get_position() print('验证码位置', top, bottom, left, right) screenshot = self.get_screenshot() # crop将图片裁剪 captcha = screenshot.crop((left, top, right, bottom)) # 将裁剪的验证码截图保存 captcha.save(name) return captcha 打开网页输入用户名密码123456789101112131415161718def open_url(self): \"\"\" 打开网页输入用户名密码 :return: None \"\"\" self.browser.get(self.url) email = self.wait.until( EC.presence_of_element_located( (By.ID, 'email') ) ) password = self.wait.until( EC.presence_of_element_located( (By.ID, 'password') ) ) email.send_keys(self.email) password.send_keys(self.password) 代码汇总123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244import timefrom io import BytesIOfrom PIL import Imagefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECEMAIL = 'zcs@163.com'PASSWORD = '123'BORDER = 6class CrackGeetest(): def __init__(self): self.url = 'https://account.geetest.com/login' self.browser = webdriver.Chrome() self.wait = WebDriverWait(self.browser, 10) self.email = EMAIL self.password = PASSWORD # 当需要删除对象来释放类所占用的资源的时候，就需要调用析构方法__del__()。 def __del__(self): self.browser.close() def open_url(self): \"\"\" 打开网页输入用户名密码 :return: None \"\"\" self.browser.get(self.url) email = self.wait.until( EC.presence_of_element_located( (By.ID, 'ivu-form-item.ivu-form-item-required.ivu-form-item-error .ivu-input') ) ) password = self.wait.until( EC.presence_of_element_located( (By.ID, '.ivu-input.ivu-input-has-value') ) ) email.send_keys(self.email) password.send_keys(self.password) def get_button(self): \"\"\" 获取验证按钮 :return: \"\"\" button = self.wait.until( EC.element_to_be_clickable( (By.CLASS_NAME, 'geetest_radar_tip') ) ) return button def get_slider(self): \"\"\" 获取滑块 :return: 滑块对象 \"\"\" slider = self.wait.until( EC.element_to_be_clickable( (By.CLASS_NAME, 'geetest_slider_button') ) ) return slider def get_image(self): \"\"\" 获取验证码图片 :return: 图片对象(无缺口图像和有缺口图像) \"\"\" return 1, 2 def get_distance(self, image1, image2): \"\"\" 获取缺口距离 :param image1: 无缺口的滑动验证码图片 :param image2: 有缺口的滑动验证码图片 :return: \"\"\" left = 60 # 根据滑块的像素为 60 ，选择 60 像素为起始点 threhold = 70 # 阈值为 70 for i in range(left, image1.size[0]): # 遍历 image1 的 left ~~ 最右端 for j in range(image1.size[1]): # 遍历 image1 的高 rgb1 = image1.load()[i, j] rgb2 = image2.load()[i, j] res1 = abs(rgb1[0] - rgb2[0]) res2 = abs(rgb1[1] - rgb2[1]) res3 = abs(rgb1[2] - rgb2[2]) if not (res1 &lt; threhold and res2 &lt; threhold and res3 &lt; threhold): return i # image1 和 image2 同一位置的 RGB差值 是否在阈值之内。假如不在，则为缺口位置 return left def get_track(self, distance): \"\"\" 根据偏移量获取移动轨迹 :param distance: 偏移量 :return: 移动轨迹 \"\"\" # 移动轨迹 track = [] # 当前位移 current = 0 # 减速阈值 mid = distance * 4 / 5 # 计算间隔 t = 0.2 # 初速度 v = 0 # 当滑块位移小于缺口距离这时候 while current &lt; distance: # 滑块位移小于缺口距离的 80% 这时，速度为2；否则速度为-3 if current &lt; mid: # 加速度为正2 a = 2 else: # 加速度为负3 a = -3 # 初速度v0 v0 = v # 当前速度v = v0 + at v = v0 + a * t # 移动距离x = v0t + 1/2 * a * t^2 move = v0 * t + 1 / 2 * a * t * t # 当前位移 current += move # 加入轨迹 track.append(round(move)) return track def move_to_gap(self, slider, track): \"\"\" 拖动滑块到缺口处 :param slider: 滑块 :param track: 轨迹 :return: \"\"\" # 创建新的操作链 action_chains1 = ActionChains(self.browser) # 按住鼠标左键 down_left_mouse = action_chains1.click_and_hold(slider) # 执行所有储存的操作 down_left_mouse.perform() # 遍历轨迹，获取每一小段位移距离 for x in track: # 创建新的操作链 action_chains2 = ActionChains(self.browser) # 按住鼠标后移动滑块 move_mouse = action_chains2.move_by_offset(xoffset=x, yoffset=0) # 执行 move_mouse.perform() time.sleep(0.5) # 执行滑块到缺口后，调用release()方法，松开鼠标 ActionChains(self.browser).release().perform() def login(self): \"\"\" 登录 :return: None \"\"\" submit = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest-btn'))) submit.click() time.sleep(10) print('登录成功') def crack(self): # 输入用户名密码 self.open_url() # 点击验证按钮 button = self.get_button() button.click() # 获取验证码图片和带缺口的验证码图片 image1, image2 = self.get_image() # 获取缺口位置 gap = self.get_distance(image1, image2) print('缺口位置', gap) # 减去缺口位移 gap = gap - BORDER # 获取移动轨迹 track = self.get_track(gap) print('滑动轨迹', track) # 拖动滑块 slider = self.get_slider() self.move_to_gap(slider, track) success = self.wait.until( EC.text_to_be_present_in_element((By.CLASS_NAME, 'geetest_success_radar_tip_content'), '验证成功')) print(success) # 失败后重试 if not success: self.crack() else: self.login()def main(): # 调用CrackGeetest()类 crack_geetest = CrackGeetest() # 输入用户名密码 crack_geetest.open_url() # 点击验证按钮 button = crack_geetest.get_button() button.click() # 获取验证码图片和带缺口的验证码图片 image1, image2 = crack_geetest.get_image() # 获取缺口位置 gap = crack_geetest.get_distance(image1, image2) print('缺口位置', gap) # 减去缺口位移 gap = gap - BORDER # 获取移动轨迹 track = crack_geetest.get_track(gap) print('滑动轨迹', track) # 拖动滑块 slider = crack_geetest.get_slider() crack_geetest.move_to_gap(slider, track) success = crack_geetest.wait.until( EC.text_to_be_present_in_element((By.CLASS_NAME, 'geetest_success_radar_tip_content'), '验证成功')) print(success) # 失败后重试 if not success: main() else: crack_geetest.login()if __name__ == '__main__': main()","link":"/p/361730202004/"},{"title":"Python 网络爬虫之 Ajax 数据爬取","text":"@Author: YiHua Lee @Address: Guangdong province, China Ajax 概述Ajax是利用 JavaScript在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。 Ajax基本原理 发送请求 解析内容 渲染页面查看请求 Ajax结果提取爬取一个人微博的前面10页 分析过程 Python代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from urllib.parse import urlencodeimport requests# 对https://m.weibo.cn/u/2830678474网页审查分析base_url = 'https://m.weibo.cn/api/container/getIndex?'headers = { 'Host': 'm.weibo.cn', 'Referer': 'https://m.weibo.cn/u/2830678474', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/75.0.3770.100 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest'}# page 为页码，返回每一页响应的JSON编码内容（如果有）def get_page(page): params = { 'type': 'uid', 'value': '2830678474', 'containerid': '1076032830678474', 'page': page } url = base_url + urlencode(params) try: response = requests.get(url, headers=headers) if response.status_code == 200: # response.status_code获取网页状态码 return response.json() # response.json()返回响应的JSON编码内容 except requests.ConnectionError as e: # 出现异常，捕获并输出其异常信息 print('Error:', e.args)from pyquery import PyQuery# 根据获取的json编码，筛选出我们需要的内容def parse_page(json): if json: items = json.get('data').get('cards') # 获取json编码中的data里面的cards的内容,返回结果是一个迭代器 for item in items: # 遍历每条cards内容 item = item.get('mblog') # 获取mblog中的内容 weibo = {} weibo['id'] = item.get('id') # 获取'id'内容 weibo['text'] = PyQuery(item.get('text')).text() # 利用get()获取'text'内容，再利用PyQuery()方法初始化Json编码形式，再利用text()获取子节点的文本表示形式。 weibo['attitudes'] = item.get('attitudes_count') # 获取'赞'的个数 weibo['comments'] = item.get('comments_count') # 获取'评论'数 weibo['reposts'] = item.get('reposts_count') # 获取'分享'次数 yield weibofrom pymongo import MongoClientclient = MongoClient() # 连接MongoDBdb = client['weibo'] # 指定weibi数据库collection = db['weibo'] # 指定weibo集合# 将数据插入Mongo数据库def save_to_mongo(result): if result: collection.insert_one(result) # 调用insert_one()方法，将一条数据插入到数据库中 print('Saved to Mongo')if __name__ == '__main__': for page in range(1, 11): # 获取10页 json = get_page(page) results = parse_page(json) for result in results: print(result) save_to_mongo(result) 结果 部分输出 12345678{'id': '4393921821587600', 'text': '老婆我爱你！ 花絮慎点啊。', 'attitudes': 16, 'comments': 4, 'reposts': 1}Saved to Mongo{'id': '4393850371867195', 'text': '执行力非常重要，做一个实干者。', 'attitudes': 1, 'comments': 0, 'reposts': 3}Saved to Mongo{'id': '4393608914828988', 'text': '欧耶！！！！！@长泽牙妹\\n济南', 'attitudes': 9, 'comments': 15, 'reposts': 0}Saved to Mongo{'id': '4393563145925473', 'text': '叔叔要和我喝酒了。\\n我好慌。 济南', 'attitudes': 10, 'comments': 20, 'reposts': 0}Saved to Mongo MongoDB数据库查看数据 异步（Ajax）爬取今日头条街拍美图类似上面爬微博的方法，爬取今日头条街拍美图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import requestsfrom urllib.parse import urlencodebase_url = 'https://www.toutiao.com/api/search/content/?'headers = { 'Host': 'www.toutiao.com', 'Referer': 'https://www.toutiao.com/search/?keyword=%E8%A1%97%E6%8B%8D', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/75.0.3770.100 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest'}# 一个关于offset和timestamp数据的列表def offset_timestamp(): offsets = [offset for offset in range(8)] timestamps = [1563094062541, 1563094066268, 1563094068231, 1563094069948, 1563094071549, 1563094073370, 1563094075154, 1563094077384] tuple_list = [] for i in range(8): tuple_list.append( (offsets[i], timestamps[i]) ) return tuple_list# 获取页面Json编码def get_page(tuple_): params = { 'aid': '24', 'app_name': 'web_search', 'offset': tuple_[0], 'format': 'json', 'keyword': '%E8%A1%97%E6%8B%8D', 'autoload': 'true', 'count': '20', 'en_qc': '1', 'cur_tab': '1', 'from': 'search_tab', 'pd': 'synthesis', 'timestamp': tuple_[1] } url = base_url + urlencode(params) try: response = requests.get(url, headers) if response.status_code == 200: return response.json() except requests.ConnectionError as e: print('Error:', e.args) return None# 获取图片URLdef get_images(json): if json.get('data'): data = json.get('data') if data.get('abstract'): for item in data.get('data'): abstract = item.get('abstract') images = item.get('image_list') for image in images: yield { 'image': image.get('url'), 'abstract': abstract }import osfrom hashlib import md5# 保存图片def save_image(item): if not os.path.exists(item.get('abstract')): # os.path.exists(path)方法，测试路径是否存在 os.mkdir(item.get('abstract')) # os.mkdir()方法，创建一个目录 try: response = requests.get(item.get('image')) # 对获取的image_URL发送请求 if response.status_code == 200: file_path = '{0}/{1}.{2}'.format(item.get('abstract'), md5(response.content).hexdigest(), 'jpg') # 图片的名称可以使用MD5值，这样可以去除重复。 # response.content属性返回响应内容。 # hexdigest()方法，以十六进制数字的字符串形式返回摘要值。 if not os.path.exists(file_path): with open(file_path, 'wb') as f: f.write(response.content) # 将响应的内容以二进制的形式写入文件file_path中 else: print('Already Downloaded', file_path) except requests.ConnectionError as e: print( 'Error:', e.args, '\\nFailed to Save Image' )if __name__ == '__main__': tuple_list = offset_timestamp() for tuple_ in tuple_list: json = get_page(tuple_) for item in get_images(json): print(item) save_image(item)","link":"/p/501430202004/"},{"title":"Python 网络爬虫代理设置","text":"@Author: YiHua Lee @Address: Guangdong province, China requestshttp/https代理设置123456789101112import requestsproxy = '120.78.225.5:3128'proxies = { 'http': 'http://' + proxy, 'https': 'https://' + proxy,}try: response = requests.get('http://httpbin.org/get', proxies=proxies) print(response.text)except requests.exceptions.ConnectionError as e: print('Error', e.args) 12345678910111213# 输出：{ \"args\": {}, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Cache-Control\": \"max-age=259200\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.21.0\" }, \"origin\": \"120.231.147.81, 120.78.225.5, 120.231.147.81\", \"url\": \"https://httpbin.org/get\"} SOCKS5代理12345678如果代理需要认证：proxy = 'username:password@127.0.0.1:9743' 即可，127.0.0.1:9743按代理Ip更改。如果要使用SOCKS5代理：proxies = { 'http': 'socks5://' + proxy, 'https': 'socks5://' + proxy,}即可。 全局设置SOCKS5代理1234567891011import requestsimport socksimport socketsocks.set_default_proxy(socks.SOCKS5, '218.91.112.56', 9999)socket.socket = socks.socksockettry: response = requests.get('http://httpbin.org/get') print(response.text)except requests.exceptions.ConnectionError as e: print('Error', e.args) Selenium代理IP（无需认证）1234567891011121314from selenium import webdriverimport timeproxy = '120.78.225.5:3128'# 通过ChromeOptions()方法来设置代理chrome_options = webdriver.ChromeOptions()# add_argument()方法向代理添加参数chrome_options.add_argument('--proxy-server=http://' + proxy)chrome = webdriver.Chrome(chrome_options=chrome_options)chrome.get('http://httpbin.org/get')time.sleep(5)chrome.close() 123456789101112131415# 输出：{ &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Cache-Control&quot;: &quot;max-age=259200&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot; }, &quot;origin&quot;: &quot;120.231.147.81, 120.78.225.5, 120.231.147.81&quot;, &quot;url&quot;: &quot;https://httpbin.org/get&quot;} 代理IP（需要认证）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport zipfileip = '218.91.112.56'port = 9999username = 'foo'password = 'bar'manifest_json = \"\"\"{ \"version\": \"1.0.0\", \"manifest_version\": 2, \"name\": \"Chrome Proxy\", \"permissions\": [ \"proxy\", \"tabs\", \"unlimitedStorage\", \"storage\", \"&lt;all_urls&gt;\", \"webRequest\", \"webRequestBlocking\" ], \"background\": { \"scripts\": [\"background.js\"] }}\"\"\"background_js = \"\"\"var config = { mode: \"fixed_servers\", rules: { singleProxy: { scheme: \"http\", host: \"%(ip)s\", port: %(port)s } } }chrome.proxy.settings.set({value: config, scope: \"regular\"}, function() {});function callbackFn(details) { return { authCredentials: { username: \"%(username)s\", password: \"%(password)s\" } }}chrome.webRequest.onAuthRequired.addListener( callbackFn, {urls: [\"&lt;all_urls&gt;\"]}, ['blocking'])\"\"\" % {'ip': ip, 'port': port, 'username': username, 'password': password}plugin_file = 'proxy_auth_plugin.zip'with zipfile.ZipFile(plugin_file, 'w') as zp: zp.writestr(\"manifest.json\", manifest_json) zp.writestr(\"background.js\", background_js)chrome_options = Options()# 向chrome_options对象中添加参数\"--start-maximized\"chrome_options.add_argument(\"--start-maximized\")# 将扩展名的路径添加到plugin_file中，将其提取到ChromeDriver的配置列表保存起来chrome_options.add_extension(plugin_file)browser = webdriver.Chrome(chrome_options=chrome_options)browser.get('http://httpbin.org/get')","link":"/p/481730202004/"},{"title":"Python 自动化库 Selenium 的使用","text":"@Author: YiHua Lee @Address: Guangdong province, China 基本使用123456789101112131415161718192021222324252627282930from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWait# webdriver 根据一个或多个贡献者许可协议授权给软件自由保护协会（SFC）。browser = webdriver.Chrome()try: browser.get('https://www.baidu.com') # get() 在当前浏览器会话中加载网页。 input = browser.find_element_by_id('kw') # find_element_by_id() 按ID查找元素 input.send_keys('Python') # send_keys() 模拟键入元素。 input.send_keys(Keys.ENTER) # Keys 是一组特殊钥匙代码。ENTER = '\\ue007' wait = WebDriverWait(browser, 10) # WebDriverWait()构造函数，获取WebDriver实例、超时（以秒为单位） wait.until( # until()调用随驱动程序提供的方法作为参数，直到返回值不为假。 expected_conditions.presence_of_element_located( # presence_of_element_located()检查页的DOM中是否存在元素的期望值。 # 这不一定意味着元素是可见的。locator-用于查找元素，一旦找到该元素，它将返回WebElement。 (By.ID, 'content_left') # By 是支持的定位策略集。ID = \"id\" ) ) print( browser.current_url, # current_url属性 获取当前页的URL。 browser.get_cookies(), # get_cookies()方法 返回一组字典，对应于当前会话中可见的cookie。 browser.page_source, # page_source属性 获取当前页的源码 sep='\\n' )finally: browser.close() # 关闭当前窗口 声明浏览器对象12345678910from selenium import webdriver# Selenium支持的一部分浏览器browser1 = webdriver.Chrome()browser2 = webdriver.Firefox()browser3 = webdriver.Edge()browser4 = webdriver.PhantomJS()browser5 = webdriver.Safari()# 完成浏览器对象的初始化并将其赋值为 browser 对象 访问页面123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com') # get()方法请求网页print(browser.page_source) # page_source属性获取网页源代码browser.close() 查找节点拿淘宝网为例 123456789101112131415from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 分别利用ID、CSS、XPath三种方式查找节点，以淘宝网源代码中的一个id='q'的节点为例。input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id=\"q\"]')print( 'ID方式查找节点:\\t', input_first, 'CSS选择器方式查找节点:\\t', input_second, 'XPath方式查找节点:\\t', input_third, sep='\\n')browser.close() 12345678# 输出：ID方式查找节点: &lt;selenium.webdriver.remote.webelement.WebElement (session=\"1ec980e4cd9be81c212a1b2285039dd9\", element=\"0.49282688108570993-1\")&gt;CSS选择器方式查找节点: &lt;selenium.webdriver.remote.webelement.WebElement (session=\"1ec980e4cd9be81c212a1b2285039dd9\", element=\"0.49282688108570993-1\")&gt;XPath方式查找节点: &lt;selenium.webdriver.remote.webelement.WebElement (session=\"1ec980e4cd9be81c212a1b2285039dd9\", element=\"0.49282688108570993-1\")&gt;# 输出均为WebElement 类型 获取结点的方法123456789# 获取单个节点的方法：find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector find_element()方法查找单个节点123456789101112from selenium import webdriverfrom selenium.webdriver.common.by import By browser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element(By.ID, 'q')print(input_first)browser.close()# find_element_by_id(id)就等价于find_element(By.ID, id)，二者得到的结果完全一致。# By是一个支持的定位策略集 find_elements()方法查找多个节点123456789101112131415from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')list1 = browser.find_elements_by_css_selector('.service-bd li')list2 = browser.find_elements(By.CSS_SELECTOR, '.service-bd li')print( 'find_elements_by_css_selector()方法:', list1, 'find_elements()方法:', list2, sep='\\n')browser.close() 123456789# 输出：find_elements_by_css_selector()方法:[&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bcb567fe9900ef1ec4336651fc12a1d\", element=\"0.257017382611505-1\")&gt;, ......&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bcb567fe9900ef1ec4336651fc12a1d\", element=\"0.257017382611505-16\")&gt;]find_elements()方法:[&lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bcb567fe9900ef1ec4336651fc12a1d\", element=\"0.257017382611505-1\")&gt;, ...... &lt;selenium.webdriver.remote.webelement.WebElement (session=\"4bcb567fe9900ef1ec4336651fc12a1d\", element=\"0.257017382611505-16\")&gt;] 123find_element()和find_elements()两个例子输出结果一样 节点交互12345678910111213from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_ = browser.find_element_by_id('q')input_.send_keys('iPhone') # 模拟键盘输入iPhonetime.sleep(1) # time.sleep() 将执行延迟给定秒数。input_.clear() # 清除输入input_.send_keys('iPad') # 模拟键盘数如iPadbutton = browser.find_element_by_class_name('tb-bg') # 找到一个属性值为tb-bg的节点button.click() # 模拟鼠标点击 Selenium驱动浏览器来执行一些操作 动作链12345678910111213from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()browser.get('http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable')browser.switch_to.frame('iframeResult') # 切换到框架'iframeResult'source = browser.find_element_by_css_selector('#draggable') # 要摇曳的节点target = browser.find_element_by_css_selector('#droppable') # 摇曳到的目标节点actions = ActionChains(browser) # ActionChains() 创建动作链actions.drag_and_drop(source, target) # drag_and_drop(）按住源元素上的鼠标左键，然后移动到目标元素并释放鼠标按钮。actions.perform() # perform() 执行所有存储的操作。 拖拽前 拖拽后 执行JavaScript利用 execute_script()方法将进度条下拉到最底部，然后弹出 alert提示框。 12345from selenium import webdriverbrowser = webdriver.Chrome()browser.get('http://www.zhihu.com/explore')browser.execute_script('window.scrollTo(0, document.body.scrollHeight)') 获取节点信息获取属性get_attribute()方法可以获取属性 123456789101112from selenium import webdriverbrowser = webdriver.Chrome()browser.get('http://www.zhihu.com/explore')logo = browser.find_element_by_id('zh-top-inner')print( logo, logo.get_attribute('class'), sep='\\n')browser.close() 123# 输出：&lt;selenium.webdriver.remote.webelement.WebElement (session=\"7f325513a2f34aaa95612698d78817e6\", element=\"0.5056570582847388-1\")&gt;zg-wrap modal-shifting clearfix 获取文本值text属性可以获取文本值 1相当于 Beautiful Soup 的 get_text()方法、 pyquery 的 text()方法 12345678from selenium import webdriverbrowser = webdriver.Chrome()browser.get('http://www.zhihu.com/explore')zhihu = browser.find_element_by_class_name('zu-top-link-logo')print(zhihu.text)browser.close() 12# 输出：知乎 获取id、位置、标签名和大小可以通过id、location、tag_name和size属性，来获取 1234567891011121314from selenium import webdriverbrowser = webdriver.Chrome()browser.get('http://www.zhihu.com/explore')input_ = browser.find_element_by_class_name('zu-top-add-question')print( input_.id, input_.location, input_.tag_name, input_.size, sep='\\n')browser.close() 12345# 输出：0.9009302916784063-1{'x': 849, 'y': 7}button{'height': 32, 'width': 66} 切换Frame123456789101112131415from selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult') # switch_to.frame() 切换Frametry: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: # NoSuchElementException 找不到元素时引发 print('NO LOGO')browser.switch_to.parent_frame()logo_ = browser.find_element_by_class_name('logo')print(logo_)print(logo_.text) 1234# 输出：NO LOGO&lt;selenium.webdriver.remote.webelement.WebElement (session=\"d24c9d62b8c5882adec32f3ed55b5d7b\", element=\"0.9706135395535092-2\")&gt;RUNOOB.COM 延时等待隐式等待1234567from selenium import webdriverbrowser = webdriver.Chrome()browser.implicitly_wait(10) # implicitly_wait()隐式等待，默认等待0秒，找不到继续等一会在找，容易受到页面加载时间的影响browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input) 显式等待12345678910111213from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser = webdriver.Chrome()browser.get('https://www.taobao.com/')wait = WebDriverWait(browser, 10) # WebDriverWait() 显式等待，不会受页面的加载时间、网络条件的影响input_ = wait.until(EC.presence_of_element_located((By.ID, 'q'))) # until()调用与驱动程序一起提供的方法作为参数，直到返回值不为假。button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))# presence_of_element_located这个条件，代表节点出现的意思# element_to_be_clickable这个条件代表可点击的print(input_, button, sep='\\n') 123# 输出：&lt;selenium.webdriver.remote.webelement.WebElement (session=\"497bc36663dd6ed41d7c59bd6a51982f\", element=\"0.8346683456577526-1\")&gt;&lt;selenium.webdriver.remote.webelement.WebElement (session=\"497bc36663dd6ed41d7c59bd6a51982f\", element=\"0.8346683456577526-2\")&gt; 显示等待的方法有很多，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181class title_is(object): \"\"\"An expectation for checking the title of a page. title is the expected title, which must be an exact match returns True if the title matches, false otherwise.\"\"\"class title_contains(object): \"\"\" An expectation for checking that the title contains a case-sensitive substring. title is the fragment of title expected returns True when the title matches, False otherwise \"\"\"class presence_of_element_located(object): \"\"\" An expectation for checking that an element is present on the DOM of a page. This does not necessarily mean that the element is visible. locator - used to find the element returns the WebElement once it is located \"\"\"class url_contains(object): \"\"\" An expectation for checking that the current url contains a case-sensitive substring. url is the fragment of url expected, returns True when the url matches, False otherwise \"\"\"class url_matches(object): \"\"\"An expectation for checking the current url. pattern is the expected pattern, which must be an exact match returns True if the url matches, false otherwise.\"\"\"class url_to_be(object): \"\"\"An expectation for checking the current url. url is the expected url, which must be an exact match returns True if the url matches, false otherwise.\"\"\"class url_changes(object): \"\"\"An expectation for checking the current url. url is the expected url, which must not be an exact match returns True if the url is different, false otherwise.\"\"\"class visibility_of_element_located(object): \"\"\" An expectation for checking that an element is present on the DOM of a page and visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0. locator - used to find the element returns the WebElement once it is located and visible \"\"\"class visibility_of(object): \"\"\" An expectation for checking that an element, known to be present on the DOM of a page, is visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0. element is the WebElement returns the (same) WebElement once it is visible \"\"\"class presence_of_all_elements_located(object): \"\"\" An expectation for checking that there is at least one element present on a web page. locator is used to find the element returns the list of WebElements once they are located \"\"\"class visibility_of_any_elements_located(object): \"\"\" An expectation for checking that there is at least one element visible on a web page. locator is used to find the element returns the list of WebElements once they are located \"\"\"class visibility_of_all_elements_located(object): \"\"\" An expectation for checking that all elements are present on the DOM of a page and visible. Visibility means that the elements are not only displayed but also has a height and width that is greater than 0. locator - used to find the elements returns the list of WebElements once they are located and visible \"\"\"class text_to_be_present_in_element(object): \"\"\" An expectation for checking if the given text is present in the specified element. locator, text \"\"\"class text_to_be_present_in_element_value(object): \"\"\" An expectation for checking if the given text is present in the element's locator, text \"\"\"class frame_to_be_available_and_switch_to_it(object): \"\"\" An expectation for checking whether the given frame is available to switch to. If the frame is available it switches the given driver to the specified frame. \"\"\"class invisibility_of_element_located(object): \"\"\" An Expectation for checking that an element is either invisible or not present on the DOM. locator used to find the element \"\"\"class invisibility_of_element(invisibility_of_element_located): \"\"\" An Expectation for checking that an element is either invisible or not present on the DOM. element is either a locator (text) or an WebElement \"\"\"class element_to_be_clickable(object): \"\"\" An Expectation for checking an element is visible and enabled such that you can click it.\"\"\"class staleness_of(object): \"\"\" Wait until an element is no longer attached to the DOM. element is the element to wait for. returns False if the element is still attached to the DOM, true otherwise. \"\"\"class element_to_be_selected(object): \"\"\" An expectation for checking the selection is selected. element is WebElement object \"\"\"class element_located_to_be_selected(object): \"\"\"An expectation for the element to be located is selected. locator is a tuple of (by, path)\"\"\"class element_selection_state_to_be(object): \"\"\" An expectation for checking if the given element is selected. element is WebElement object is_selected is a Boolean.\" \"\"\"class element_located_selection_state_to_be(object): \"\"\" An expectation to locate an element and check if the selection state specified is in that state. locator is a tuple of (by, path) is_selected is a boolean \"\"\"class number_of_windows_to_be(object): \"\"\" An expectation for the number of windows to be a certain value.\"\"\"class new_window_is_opened(object): \"\"\" An expectation that a new window will be opened and have the number of windows handles increase\"\"\"class alert_is_present(object): \"\"\" Expect an alert to be present.\"\"\"def _find_element(driver, by): \"\"\"Looks up an element. Logs and re-raises ``WebDriverException`` if thrown.\"\"\" 前进和返回back()方法，后退到上一个以页面。forward()方法，前进到下一个页面 123456789101112131415import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com/')time.sleep(1)browser.get('https://www.taobao.com/')time.sleep(1)browser.get('https://www.zhihu.com/')time.sleep(1)browser.back() # 现在位于https://www.zhihu.com/页面，返回上一个页面即为https://www.taobao.com/页面time.sleep(1)browser.forward() # 现在位于https://www.taobao.com/页面，跳到下一个页面即为https://www.zhihu.com/页面time.sleep(1)browser.close() Cookies12345678910from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')print(browser.get_cookies()) # 获取Cookiesbrowser.add_cookie({'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'}) # 添加Cookieprint(browser.get_cookies()) # 获取Cookiesbrowser.delete_all_cookies() # 删除Cookiesprint(browser.get_cookies()) # 获取Cookiesbrowser.close() 1234# 输出：[{'domain': '.zhihu.com', 'expiry': 1579115127, 'httpOnly': False, 'name': '__utmz', 'path': '/', 'secure': False, 'value': '51854390.1563347127.1.1.utm......][{'domain': 'www.zhihu.com', 'expiry': 2194067127, 'httpOnly': False, 'name': 'name', 'path': '/', 'secure': True, 'value': 'germey'}, {'domain': '.zhihu.com......][] 选项卡管理12345678910111213141516171819import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.execute_script('window.open()')# 调用了execute_script()方法，执行这里传入JavaScript。 window.open() 这个JavaScript语句新开启一个选项卡 。print(browser.window_handles)# 调用 window_handles 属性获取当前开启的所有选项卡，返回的是选项卡的代号列表browser.switch_to.window(browser.window_handles[1])# 调用 switch_to_window() 方法,切换选项卡browser.get('https://www.taobao.com')time.sleep(1)browser.switch_to.window(browser.window_handles[0])browser.get('https://zhihu.com')browser.close() # 关闭当前所在的选项卡 12# 输出：['CDwindow-BBF992DA636EC22831C022F29A7F976A', 'CDwindow-37A0508493A023D6BC1393D11D5F4D9F'] 异常处理1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('Time Out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('No Element')finally: browser.close() 12# 输出：No Element","link":"/p/171530202004/"},{"title":"Redis 学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China Redis 存储的数据 Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 类型 简介 特性 场景 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1. 最新消息排行等功能(比如朋友圈的时间线) 2. 消息队列 Set(集合) 哈希表实现,元素不重复 1. 添加、删除,查找的复杂度都是O(1)2. 为集合提供了求交集、并集、差集等操作 1. 共同好友 2. 利用唯一性,统计访问网站的所有独立ip 3. 好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1. 排行榜2. 带权重的消息队列 Redis 支持的五种数据String（字符串） string是redis最基本的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。 存储 String 数据：set key value 1set username &quot;LeeHua&quot; 获取 String 数据：get key 1get username 假如，这个时候执行命令 set username stringbug，再执行 get username 的时候，返回的值则是 “stringbug”，前面存储的 “LeeHua” 就会被覆盖掉 删除 String 数据：del key 1del username 这个时候如果再执行 get username ，那么将会返回 nil Hash（哈希） Redis hash 是一个键值(key=&gt;value)对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 存储 Hash（哈希） 数据：hset key field value 123hset testHash username &quot;LeeHua&quot;hset testHash password &quot;123456&quot;hset testHash age &quot;20&quot; 获取 Hash（哈希） 数据： 获取指定的 field对应的值：hget key field 123hget testHash usernamehget testHash passwordhget testHash age 获取所有field对应的值：hgetall key 1hgetall testHash 删除 Hash（哈希） 数据：hdel testHash field 12hdel testHash username passwordhdel testHash age List（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边：left）或者尾部（右边：right）。 添加 List（列表） 数据： 将元素加入列表的左边：lpush key value 12lpush testList Alpush testList B 将元素加入列表的右边：rpush key value 12rpush testList 1rpush testList 2 获取 List（列表） 数据： 范围获取：lrange key start end (这个只有 lrange，没有 rrange ) 1lrange testList 0 3 删除 List（列表） 数据： 删除列表最左边的元素，并将元素返回：lpop key 123lpop testListlpop testListlpop testList 删除列表最右边的元素，并将元素返回：rpop key 1rpop testList Set（集合） Redis 的 Set 是 string 类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。不允许重复元素。 存储 Set（集合） 数据：sadd key value 12sadd testSet LeeHuasadd testSet StringBug 如果这个时候，还向 testSet 中添加 LeeHua，是不会添加成功的 1sadd testSet LeeHua 获取 Set（集合） 数据：smembers key 1smembers testSet 删除 Set（集合） 数据：srem key value 1srem testSet LeeHua zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。zset的成员是唯一的,但分数(score)却可以重复。 存储 zset(sorted set：有序集合) 数据：zadd key sorce value 123zadd testSortSet 20 ZhangSanzadd testSortSet 22 WangWuzadd testSortSet 21 LiSi 获取 zset(sorted set：有序集合) 数据：zrange key start end 1zrange testSortSet 0 2 1zrange testSortSet 0 2 withscores 删除 zset(sorted set：有序集合) 数据：zrem key value 1zrem testSortSet LiSi Redis 五种数据类型常用命令String（字符串） 序号 命令及描述 1 SET key value 设置指定 key 的值 2 GET key 获取指定 key 的值。 3 GETRANGE key start end 返回 key 中字符串值的子字符 4 GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 5 GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 6 MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。 7 SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 8 SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 9 SETNX key value 只有在 key 不存在时设置 key 的值。 10 SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 11 STRLEN key 返回 key 所储存的字符串值的长度。 12 MSET key value [key value …] 同时设置一个或多个 key-value 对。 13 MSETNX key value [key value …] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 14 PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 15 INCR key 将 key 中储存的数字值增一。 16 INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。 17 INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 18 DECR key 将 key 中储存的数字值减一。 19 DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。 20 APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 Hash（哈希） 序号 命令及描述 1 HDEL key field2 [field2] 删除一个或多个哈希表字段 2 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 3 HGET key field 获取存储在哈希表中指定字段的值/td&gt; 4 HGETALL key 获取在哈希表中指定 key 的所有字段和值 5 HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 6 HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 7 HKEYS key 获取所有哈希表中的字段 8 HLEN key 获取哈希表中字段的数量 9 HMGET key field1 [field2] 获取所有给定字段的值 10 HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 11 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 12 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 13 HVALS key 获取哈希表中所有值 14 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 List（列表） 序号 命令及描述 1 BLPOP key1 [key2] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 2 BRPOP key1 [key2] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 3 BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 4 LINDEX key index 通过索引获取列表中的元素 5 LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素 6 LLEN key 获取列表长度 7 LPOP key 移出并获取列表的第一个元素 8 LPUSH key value1 [value2] 将一个或多个值插入到列表头部 9 LPUSHX key value 将一个或多个值插入到已存在的列表头部 10 LRANGE key start stop 获取列表指定范围内的元素 11 LREM key count value 移除列表元素 12 LSET key index value 通过索引设置列表元素的值 13 LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 14 RPOP key 移除并获取列表最后一个元素 15 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 16 [RPUSH key value1 [value2]](https://www.redis.net.cn/order/3592.html) 在列表中添加一个或多个值 17 RPUSHX key value 为已存在的列表添加值 Set（集合） 序号 命令及描述 1 SADD key member1 [member2] 向集合添加一个或多个成员 2 SCARD key 获取集合的成员数 3 SDIFF key1 [key2] 返回给定所有集合的差集 4 SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中 5 SINTER key1 [key2] 返回给定所有集合的交集 6 SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中 7 SISMEMBER key member 判断 member 元素是否是集合 key 的成员 8 SMEMBERS key 返回集合中的所有成员 9 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合 10 SPOP key 移除并返回集合中的一个随机元素 11 SRANDMEMBER key [count] 返回集合中一个或多个随机数 12 SREM key member1 [member2] 移除集合中一个或多个成员 13 SUNION key1 [key2] 返回所有给定集合的并集 14 SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中 15 SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素 sorted set（有序集合） 序号 命令及描述 1 ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 2 ZCARD key 获取有序集合的成员数 3 ZCOUNT key min max 计算在有序集合中指定区间分数的成员数 4 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment 5 ZINTERSTORE destination numkeys key [key …] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 6 ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 7 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员 8 ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员 9 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员 10 ZRANK key member 返回有序集合中指定成员的索引 11 ZREM key member [member …] 移除有序集合中的一个或多个成员 12 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 13 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 14 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 15 ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到底 16 ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序 17 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 18 ZSCORE key member 返回有序集中，成员的分数值 19 ZUNIONSTORE destination numkeys key [key …] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 20 ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） 通用命令 查询所有的键：keys * 获取键对应的value的类型：type key 删除指定的key value：del key 参考文献 Redis 教程_redis教程","link":"/p/410713202007/"},{"title":"Python 调用 Splash API","text":"@Author: YiHua Lee @Address: Guangdong province, China render.htmlrender.html 接口用于获取 JavaScript 渲染的页面的 HTML 代码，接口地址就是 Splash 的运行地址加此接口名称。 例如： 1http://0.0.0.0:8050/render.html?url=https://www.baidu.com&amp;wait=5 http://0.0.0.0:8050 + render.html + https://www.baidu.com + wait=5 12345import requestsurl = 'http://0.0.0.0:8050/render.html?url=https://www.baidu.com&amp;wait=5'response = requests.get(url)print(response.text) 12# 运行给此接口传递了一个url参数来指定渲染的URL，等待5秒钟，返回结果即页面渲染后的源代码。 render.pngrender.png 接口可以获取网页截图，通过 width 和 height 来控制宽高，它返回的是PNG 格式的图片二进制数据。 例如： 1http://localhost:8050/render.png?url=https://www.jd.com&amp;wait=5&amp;width=1000&amp;height=700 123456import requestsurl = 'http://localhost:8050/render.png?url=https://www.jd.com&amp;wait=5&amp;width=1000&amp;height=700'response = requests.get(url)with open('taobao.png', 'wb') as f: f.write(response.content) render.jpngrender.jpng 接口和 render.png 接口类似，只是多了个 quality 参数来设置图片的质量。 render.harrender.har 接口用于获取页面加载的HAR数据，它的返回结果非常多，是一个 JSON 格式的数据，其中包含页面加载过程中的 HAR 数据。 123456import requestsurl = 'http://localhost:8050/render.har?url=https://www.jd.com&amp;wait=5'response = requests.get(url)with open('jd1.json', 'wb') as f: f.write(response.content) 1# 运行生成一个名为jd.json的文件 execute 接口execute 接口 是一个很强大的接口 实例1 12345678910111213141516import requestsfrom urllib.parse import quote# lua脚本lua = '''function main(splash) return 'hello'end'''# quote()方法将lua脚本进行URL转码。lua_source作为参数传递url = 'http://localhost:8050/execute?lua_source=' + quote(lua)response = requests.get(url)print(response.text)print(quote(lua)) 123# 输出：hello%0Afunction%20main%28splash%29%0A%20%20%20%20return%20%27hello%27%0Aend%0A 实例2 12345678910111213141516171819import requestsfrom urllib.parse import quotelua = '''function main(splash, args) local treat = require(\"treat\") local response = splash:http_get(\"http://httpbin.org/get\") return { html=treat.as_string(response.body), url=response.url, status=response.status }end'''url = 'http://localhost:8050/execute?lua_source=' + quote(lua)response = requests.get(url)print(response.text)print(quote(lua)) 123# 输出：{\"html\": \"{\\n \\\"args\\\": {}, \\n \\\"headers\\\": {\\n \\\"Accept-Encoding\\\": \\\"gzip, deflate\\\", \\n \\\"Accept-Language\\\": \\\"en,*\\\", \\n \\\"Host\\\": \\\"httpbin.org\\\", \\n \\\"User-Agent\\\": \\\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/602.1 (KHTML, like Gecko) splash Version/9.0 Safari/602.1\\\"\\n }, \\n \\\"origin\\\": \\\"120.239.195.171, 120.239.195.171\\\", \\n \\\"url\\\": \\\"https://httpbin.org/get\\\"\\n}\\n\", \"status\": 200, \"url\": \"http://httpbin.org/get\"}%0Afunction%20main%28splash%2C%20args%29%0A%20%20local%20treat%20%3D%20require%28%22treat%22%29%0A%20%20local%20response%20%3D%20splash%3Ahttp_get%28%22http%3A//httpbin.org/get%22%29%0A%20%20%20%20return%20%7B%0A%20%20%20%20html%3Dtreat.as_string%28response.body%29%2C%0A%20%20%20%20url%3Dresponse.url%2C%0A%20%20%20%20status%3Dresponse.status%0A%20%20%20%20%7D%0Aend%0A Lua 脚本 123456789function main(splash, args) local treat = require(\"treat\") local response = splash:http_get(\"http://httpbin.org/get\") return { html=treat.as_string(response.body), url=response.url, status=response.status }end 12345678910111213141516// 输出：Objecthtml: String (length 347){ &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;en,*&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/602.1 (KHTML, like Gecko) splash Version/9.0 Safari/602.1&quot; }, &quot;origin&quot;: &quot;120.239.195.171, 120.239.195.171&quot;, &quot;url&quot;: &quot;https://httpbin.org/get&quot;}status: 200url: &quot;http://httpbin.org/get&quot;","link":"/p/081730202004/"},{"title":"Python 进行代理池的维护","text":"@Author: YiHua Lee @Address: Guangdong province, China 利用python创建自己的代理池，可以自己以后使用。 初始数据proxypool.setting1234567891011121314151617181920212223242526272829303132333435363738394041# Redis数据库地址REDIS_HOST = '127.0.0.1'# Redis端口REDIS_PORT = 6379# Redis密码，如无填NoneREDIS_PASSWORD = NoneREDIS_KEY = 'proxies'# 代理分数，最高为100分，最低我0分。初始分数为10分MAX_SCORE = 100MIN_SCORE = 0INITIAL_SCORE = 10# 有效的状态码VALID_STATUS_CODES = [200, 302]# 代理池数量界限POOL_UPPER_THRESHOLD = 50000# 检查周期TESTER_CYCLE = 20# 获取周期GETTER_CYCLE = 300# 测试API，建议抓哪个网站测哪个，这里用百度网来测试APITEST_URL = 'http://www.baidu.com'# API配置，API地址、端口API_HOST = '0.0.0.0'API_PORT = 5555# 开关TESTER_ENABLED = TrueGETTER_ENABLED = TrueAPI_ENABLED = True# 最大批测试量BATCH_TEST_SIZE = 10 异常问题proxypool.error123456789class PoolEmptyError(Exception): def __init__(self): # Exception类，是所有非退出异常的公共基类。 Exception.__init__(self) def __str__(self): # repr函数，返回对象的规范字符串表示形式。 return repr('代理池已经枯竭') 存储模块proxypool.db123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import redisfrom proxypool.error import PoolEmptyErrorfrom proxypool.setting import REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, REDIS_KEYfrom proxypool.setting import MAX_SCORE, MIN_SCORE, INITIAL_SCOREfrom random import choiceimport reclass RedisClient(object): def __init__(self, host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD): \"\"\" 初始化 :param host: Redis 地址 :param port: Redis 端口 :param password: Redis密码 \"\"\" # 创建链接数据库对象 self.db = redis.StrictRedis(host=host, port=port, password=password, decode_responses=True) def add(self, proxy, score=INITIAL_SCORE): \"\"\" 添加代理，设置分数为最高 :param proxy: 代理 :param score: 分数 :return: 添加结果 \"\"\" # zscore() 方法，返回 \"REDIS_KEY\" 中元素为 \"proxy\" 的分数。 # zadd() 方法，将任意数量的元素名称、分数对设置为键 \"REDIS_KEY\"。 if not re.match('\\d+\\.\\d+\\.\\d+\\.\\d+\\:\\d+', proxy): print('代理不符合规范', proxy, '丢弃') return if not self.db.zscore(REDIS_KEY, proxy): return self.db.zadd(REDIS_KEY, score, proxy) def random(self): \"\"\" 从数据库中随机获取有效代理，首先尝试获取最高分数代理，如果不存在，按照排名获取，否则异常 :return: 随机代理 \"\"\" # zrangebyscore() 方法，返回排序集 \"REDIS_KEY\" 中带分数的值，其中分数范围为 MAX_SCORE ～ MAX_SCORE ，即返回 100 分的代理 # 代理的有效程度以分数来区分，分数高，说明代理越稳定。 # 首先查找 100 分的代理，如果没有，则在 0 ～ 100 之间查找最高分的代理， # 如果还没有，则调用 proxypool.error.PoolEmptyError 抛出异常 result = self.db.zrangebyscore(REDIS_KEY, MAX_SCORE, MAX_SCORE) if len(result): return choice(result) else: result = self.db.zrevrange(REDIS_KEY, 0, 100) if len(result): return choice(result) else: raise PoolEmptyError def decrease(self, proxy): \"\"\" 代理值减一分，小于最小值则删除 :param proxy: 代理 :return: 修改后的代理分数 \"\"\" # zscore() 方法，返回 \"REDIS_KEY\" 中元素为 \"proxy\" 的分数。 # zincrby() 方法，按 “-1” 增加排序集 \"REDIS_KEY\" 中 \"proxy\" 的分数 # zrem() 方法，从排序集 \"REDIS_KEY\" 中删除成员 \"proxy\" score = self.db.zscore(REDIS_KEY, proxy) if score and score &gt; MIN_SCORE: print('代理', proxy, '当前分数', score, '减1') return self.db.zincrby(REDIS_KEY, proxy, -1) else: print('代理', proxy, '当前分数', score, '移除') return self.db.zrem(REDIS_KEY, proxy) def exists(self, proxy): \"\"\" 判断是否存在 :param proxy: 代理 :return: 是否存在 \"\"\" # zscore() 方法，返回 \"REDIS_KEY\" 中元素为 \"proxy\" 的分数。 return not self.db.zscore(REDIS_KEY, proxy) == None def max(self, proxy): \"\"\" 将代理设置为MAX_SCORE :param proxy: 代理 :return: 设置结果 \"\"\" print('代理', proxy, '可用，设置为', MAX_SCORE) # zadd() 方法，将任意数量的元素名称、分数对设置为键 \"REDIS_KEY\"。 return self.db.zadd(REDIS_KEY, MAX_SCORE, proxy) def count(self): \"\"\" 获取数量 :return: 数量 \"\"\" # zcard() 方法，返回排序集 \"REDIS_KEY\" 中的元素个数 return self.db.zcard(REDIS_KEY) def all(self): \"\"\" 获取全部代理 :return: 全部代理列表 \"\"\" # zrangebyscore()方法，获取 MIN_SCORE ～ MAX_SCORE 的代理，即所有代理 return self.db.zrangebyscore(REDIS_KEY, MIN_SCORE, MAX_SCORE) def batch(self, start, stop): \"\"\" 批量获取 :param start: 开始索引 :param stop: 结束索引 :return: 代理列表 \"\"\" # zrangebyscore()方法，获取 start ～ (stop - 1) 的代理 return self.db.zrevrange(REDIS_KEY, start, stop - 1)if __name__ == '__main__': conn = RedisClient() result = conn.batch(680, 688) print(result) 爬虫抓取代理proxypool.utils123456789101112131415161718192021222324252627import requestsfrom requests.exceptions import ConnectionErrorbase_headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7'}def get_page(url, options={}): \"\"\" 抓取代理 :param url: :param options: :return: \"\"\" headers = dict(base_headers, **options) print('正在抓取', url) try: response = requests.get(url, headers=headers) print('抓取成功', url, response.status_code) if response.status_code == 200: return response.text except ConnectionError: print('抓取失败', url) return None 获取模块获取代理的每个方法统一定义为以 crawl 开头 proxypool.crawler123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import jsonimport refrom .utils import get_pagefrom pyquery import PyQuery as pqclass ProxyMetaclass(type): \"\"\" 定义一个类 ProxyMetaclass，Crawl类将设置为元类，元类中实现了 __new__()方法，这个方法有固定几个参数， 第四个参数 attrs 包含了类的一些属性，通过遍历 attrs 这个参数即可获取类的所有方法信息，就同遍历字典一样， 键名对应方法的名，接着判断方法的开关是否 crawl，是则将其加入到 __CrawlFunc__属性中。 这样就将所有以 crawl 开头的方法定义成一个属性，动态获取到所有以 crawl 开头的方法列表。 \"\"\" def __new__(cls, name, bases, attrs): \"\"\" __new__() 方法与 __init__() 方法类似， __new__ 负责对象的创建 而 __init__ 负责对象的初始化。 \"\"\" count = 0 attrs['__CrawlFunc__'] = [] for k, v in attrs.items(): if 'crawl_' in k: attrs['__CrawlFunc__'].append(k) count = count + 1 attrs['__CrawlFuncCount__'] = count return type.__new__(cls, name, bases, attrs)class Crawler(object, metaclass=ProxyMetaclass): def get_proxies(self, callback): \"\"\" 将所有以 crawl 开头的方法都调用一遍 :param callback:要被回调的方法 :return: 每个方法返回的代理并组合成列表 \"\"\" proxies = [] for proxy in eval(\"self.{}()\".format(callback)): print('成功获取到代理', proxy) proxies.append(proxy) return proxies def crawl_daili66(self, page_count=4): \"\"\" 获取代理 \"66ip\" :param page_count: 页码 :return: 代理 \"\"\" start_url = 'http://www.66ip.cn/{}.html' urls = [start_url.format(page) for page in range(1, page_count + 1)] for url in urls: print('Crawling', url) html = get_page(url) # 爬取网页源代码 if html: doc = pq(html) # 对网页源代码进行解析 # 选取 \"class=containerbox\" 的节点里的 table 节点，再选择其中的带有以 \"0\" 开头的 gt 属性值的每个 &lt;tr&gt; 元素。 trs = doc('.containerbox table tr:gt(0)').items() for tr in trs: # 选择属于其父元素的第 1 个子元素的每个 &lt;td&gt; 元素。 ip = tr.find('td:nth-child(1)').text() # 选择属于其父元素的第 2 个子元素的每个 &lt;td&gt; 元素。 port = tr.find('td:nth-child(2)').text() yield ':'.join([ip, port]) def crawl_ip3366(self): \"\"\" 获取代理 \"ip3366\" :return:代理的迭代器 \"\"\" for page in range(1, 4): start_url = 'http://www.ip3366.net/free/?stype=1&amp;page={}'.format(page) html = get_page(start_url) # 获取网页源代码 ip_address = re.compile('&lt;tr&gt;\\s*&lt;td&gt;(.*?)&lt;/td&gt;\\s*&lt;td&gt;(.*?)&lt;/td&gt;') # 正则表达式对象 # \\s * 匹配空格，起到换行作用 re_ip_address = ip_address.findall(html) for address, port in re_ip_address: result = address+':' + port yield result.replace(' ', '') # 把 result 中的空格去掉 def crawl_kuaidaili(self): \"\"\" 获取代理 \"快代理\" :return:代理的迭代器 \"\"\" for i in range(1, 4): start_url = 'http://www.kuaidaili.com/free/inha/{}/'.format(i) html = get_page(start_url) # 获取网页源代码 if html: ip_address = re.compile('&lt;td data-title=\"IP\"&gt;(.*?)&lt;/td&gt;') re_ip_address = ip_address.findall(html) # 代理地址 port = re.compile('&lt;td data-title=\"PORT\"&gt;(.*?)&lt;/td&gt;') re_port = port.findall(html) # 代理端口 for address, port in zip(re_ip_address, re_port): # zip()将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表 address_port = address+':'+port yield address_port.replace(' ', '') def crawl_xicidaili(self): \"\"\" 获取代理 \"西刺代理\" :return:代理的迭代器 \"\"\" for i in range(1, 3): start_url = 'http://www.xicidaili.com/nn/{}'.format(i) headers = { 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Cookie': '_free_proxy_session=BAh7B0kiD3Nlc3Npb25faWQGOgZFVEkiJWRjYzc5MmM1MTBiMDMzYTUzNTZjNzA4NjBhNWRjZjliBjsAVEkiEF9jc3JmX3Rva2VuBjsARkkiMUp6S2tXT3g5a0FCT01ndzlmWWZqRVJNek1WanRuUDBCbTJUN21GMTBKd3M9BjsARg%3D%3D--2a69429cb2115c6a0cc9a86e0ebe2800c0d471b3', 'Host': 'www.xicidaili.com', 'Referer': 'http://www.xicidaili.com/nn/3', 'Upgrade-Insecure-Requests': '1', } html = get_page(start_url, options=headers) # 获取网页源代码 if html: find_trs = re.compile('&lt;tr class.*?&gt;(.*?)&lt;/tr&gt;', re.S) trs = find_trs.findall(html) for tr in trs: find_ip = re.compile('&lt;td&gt;(\\d+\\.\\d+\\.\\d+\\.\\d+)&lt;/td&gt;') re_ip_address = find_ip.findall(tr) # 代理地址 find_port = re.compile('&lt;td&gt;(\\d+)&lt;/td&gt;') re_port = find_port.findall(tr) # 代理端口 for address,port in zip(re_ip_address, re_port): address_port = address+':'+port yield address_port.replace(' ', '') def crawl_iphai(self): \"\"\" 获取代理 \"IP海\" :return:代理的迭代器 \"\"\" start_url = 'http://www.iphai.com/' html = get_page(start_url) # 获取网页源代码 if html: find_tr = re.compile('&lt;tr&gt;(.*?)&lt;/tr&gt;', re.S) trs = find_tr.findall(html) # 选择网页源代码中有代理信息的部分源码 for s in range(1, len(trs)): find_ip = re.compile('&lt;td&gt;\\s+(\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+&lt;/td&gt;', re.S) re_ip_address = find_ip.findall(trs[s]) # 代理地址 find_port = re.compile('&lt;td&gt;\\s+(\\d+)\\s+&lt;/td&gt;', re.S) re_port = find_port.findall(trs[s]) # 代理端口 for address, port in zip(re_ip_address, re_port): # zip()将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表 address_port = address+':'+port yield address_port.replace(' ', '') def crawl_data5u(self): \"\"\" 获取代理 \"无忧代理\" :return:代理的迭代器 \"\"\" start_url = 'http://www.data5u.com' headers = { 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7', 'Cache-Control': 'max-age=0', 'Connection': 'keep-alive', 'Cookie': 'JSESSIONID=47AA0C887112A2D83EE040405F837A86', 'Host': 'www.data5u.com', 'Referer': 'http://www.data5u.com/free/index.shtml', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36', } html = get_page(start_url, options=headers) # 获取网页源代码 if html: ip_address = re.compile('&lt;span&gt;&lt;li&gt;(\\d+\\.\\d+\\.\\d+\\.\\d+)&lt;/li&gt;.*?&lt;li class=\\\"port.*?&gt;(\\d+)&lt;/li&gt;', re.S) re_ip_address = ip_address.findall(html) # 返回 (代理地址, 代理端口) 组成的列表 for address, port in re_ip_address: result = address + ':' + port yield result.replace(' ', '') 代理存储proxypool.getter1234567891011121314151617181920212223242526272829303132333435from proxypool.tester import Testerfrom proxypool.db import RedisClientfrom proxypool.crawler import Crawlerfrom proxypool.setting import *import sysclass Getter(): def __init__(self): self.redis = RedisClient() self.crawler = Crawler() def is_over_threshold(self): \"\"\" 判断是否达到了代理池限制 \"\"\" if self.redis.count() &gt;= POOL_UPPER_THRESHOLD: return True else: return False def run(self): print('获取器开始执行') if not self.is_over_threshold(): # 遍历定义的 Crawler 类中的几个 craw 开头的网页代理爬虫，运行着几个爬虫 for callback_label in range(self.crawler.__CrawlFuncCount__): callback = self.crawler.__CrawlFunc__[callback_label] # 获取代理 proxies = self.crawler.get_proxies(callback) sys.stdout.flush() for proxy in proxies: # 将代理逐个加入到数据库中 self.redis.add(proxy) 检测模块proxypool.tester12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import asyncioimport aiohttpimport timeimport systry: from aiohttp import ClientErrorexcept: from aiohttp import ClientProxyConnectionError as ProxyConnectionErrorfrom proxypool.db import RedisClientfrom proxypool.setting import *class Tester(object): def __init__(self): self.redis = RedisClient() async def test_single_proxy(self, proxy): \"\"\" 测试单个代理 :param proxy: :return: \"\"\" conn = aiohttp.TCPConnector(verify_ssl=False) async with aiohttp.ClientSession(connector=conn) as session: try: if isinstance(proxy, bytes): proxy = proxy.decode('utf-8') real_proxy = 'http://' + proxy print('正在测试', proxy) # 测试所选的代理，如果响应状态码在 [200, 302] 里面，说明代理可用，否则代理分数减 1 async with session.get(TEST_URL, proxy=real_proxy, timeout=15, allow_redirects=False) as response: if response.status in VALID_STATUS_CODES: self.redis.max(proxy) print('代理可用', proxy) else: self.redis.decrease(proxy) print('请求响应码不合法 ', response.status, 'IP', proxy) except (ClientError, aiohttp.client_exceptions.ClientConnectorError, asyncio.TimeoutError, AttributeError): self.redis.decrease(proxy) print('代理请求失败', proxy) def run(self): \"\"\" 测试主函数 :return: \"\"\" print('测试器开始运行') try: # 数据库中代理个数 count = self.redis.count() print('当前剩余', count, '个代理') # 遍历所有代理，间隔为 BATCH_TEST_SIZE = 10 for i in range(0, count, BATCH_TEST_SIZE): # 开始测试的代理，停止测试的代理 start = i stop = min(i + BATCH_TEST_SIZE, count) print('正在测试第', start + 1, '-', stop, '个代理') # 通过 redis.batch() 方法，批量获取代理（10个代理） test_proxies = self.redis.batch(start, stop) # asyncio.get_event_loop() 方法，返回异步事件循环。 loop = asyncio.get_event_loop() # 通过异步处理，测试10个代理， run_until_complete() 方法：运行事件循环，直到完成。 # asyncio.wait(tasks) ， 等待 \"tasks\" 提供的未来和协同工作完成 tasks = [self.test_single_proxy(proxy) for proxy in test_proxies] loop.run_until_complete(asyncio.wait(tasks)) # sys.stdout.flush() ， 1、 flush() 刷新缓存区。 2、缓冲区满时，自动刷新。 3、文件关闭或者是程序结束自动刷新。 sys.stdout.flush() time.sleep(5) except Exception as e: print('测试器发生错误', e.args) 接口模块proxypool.api12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, gfrom .db import RedisClient__all__ = ['app']# __name__ 参数，让flask知道什么是属于自己的应用程序。app = Flask(__name__)# 获取连接def get_conn(): # hasattr() 返回对象是否具有具有给定名称的属性。 if not hasattr(g, 'redis'): g.redis = RedisClient() return g.redis# http://localhost:port# http://127.0.0.0:5555@app.route('/')def index(): # 返回副标题 \"Welcome to Proxy Pool System\" return '&lt;h2&gt;Welcome to Proxy Pool System&lt;/h2&gt;'# http://localhost:port/random# http://127.0.0.0:5555/random@app.route('/random')def get_proxy(): \"\"\" Get a proxy :return: 随机代理 \"\"\" conn = get_conn() return conn.random()# http://localhost:port/count# http://127.0.0.0:5555/count@app.route('/count')def get_counts(): \"\"\" Get the count of proxies :return: 代理池总量 \"\"\" conn = get_conn() return str(conn.count())if __name__ == '__main__': app.run() 调度模块scheduler123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import time# 多处理程序from multiprocessing import Processfrom proxypool.api import appfrom proxypool.getter import Getterfrom proxypool.tester import Testerfrom proxypool.db import RedisClientfrom proxypool.setting import *class Scheduler(): def schedule_tester(self, cycle=TESTER_CYCLE): \"\"\" 定时测试代理 cycle = TESTER_CYCLE = 20:检查周期 \"\"\" tester = Tester() while True: print('测试器开始运行') tester.run() time.sleep(cycle) def schedule_getter(self, cycle=GETTER_CYCLE): \"\"\" 定时获取代理 cycle = GETTER_CYCLE = 300:获取周期 \"\"\" getter = Getter() while True: print('开始抓取代理') getter.run() time.sleep(cycle) def schedule_api(self): \"\"\" 开启API \"\"\" app.run(API_HOST, API_PORT) def run(self): print('代理池开始运行') ''' 开关 TESTER_ENABLED = True:测试开关 GETTER_ENABLED = True:获取开关 API_ENABLED = True:API开关 ''' if TESTER_ENABLED: tester_process = Process(target=self.schedule_tester) tester_process.start() if GETTER_ENABLED: getter_process = Process(target=self.schedule_getter) getter_process.start() if API_ENABLED: api_process = Process(target=self.schedule_api) api_process.start() 运行run1234567891011121314151617181920from proxypool.scheduler import Schedulerimport sysimport io# 文本 IO 包装:打包流# sys.stdout.buffer ，标准输出的缓冲区# 将 sys.stdout.buffer（标准输出的缓冲区 ）中的内容打包sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')def main(): try: s = Scheduler() s.run() except: main()if __name__ == '__main__': main() 获取代理有了上面的代码，可以通过 ‘http://127.0.0.1:5555/random' 随机从数据库中获取我们爬取到的可用代理123456789101112131415161718192021222324import requestsPROXY_POOL_URL = 'http://127.0.0.1:5555/random'def get_proxy(): try: response = requests.get(PROXY_POOL_URL) if response.status_code == 200: return response.text except ConnectionError: return Noneproxy = get_proxy()proxies = { 'http': 'http://' + proxy, 'https': 'https://' + proxy,}try: response = requests.get('http://httpbin.org/get', proxies=proxies) print(response.text)except requests.exceptions.ConnectionError as e: print('Error', e.args)","link":"/p/021830202004/"},{"title":"Redis 持久化机制","text":"@Author: YiHua Lee @Address: Guangdong province, China Redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 配置在 /usr/local/redis-5.0.8/redis.conf，可以自己修改该配置。 AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 这种持久化机制，默认是关闭的，可以修改 /usr/local/redis-5.0.8/redis.conf配置文件，开启AOF 修改AOF配置：","link":"/p/230813202007/"},{"title":"Redis 学习笔记2（Java 操作Redis）","text":"@Author: YiHua Lee @Address: Guangdong province, China Jedis 简介 Jedis 是 Java 操作 Redis 的驱动架包。在使用前需要先下载好驱动架包jedis.jar 首先你需要下载驱动包 下载 jedis.jar，确保下载好驱动包。 在 classpath 中包含该驱动包。 连接到 redis 服务1234567891011/** 连接 Redis 数据库 */@Testpublic void ConnectionRedisTest() { // 获取连接 Jedis jedis = new Jedis(\"127.0.0.1\", 6379); System.out.println(\"连接成功\"); // 查看服务是否运行 System.out.println(\"服务正在运行: \" + jedis.ping()); // 关闭连接 jedis.close();} 输出： 12连接成功服务正在运行: PONG Jedis 操作 Redis 中的各种数据结构String（字符串）123456789101112131415161718192021/** 操作 Redis String 类型的数据 */@Testpublic void OperateStringTest() throws InterruptedException { // 获取连接：空参，默认为 \"127.0.0.1\", 6379 Jedis jedis = new Jedis(); // 存储 String 类型的数据 jedis.set(\"username\", \"LeeHua\"); // 获取存储的 String 数据 System.out.println(jedis.get(\"username\")); // 使用 setex() 方法存储数据，可以指定过期时间 ---- key, value // 将 checkCode: AbCd 键值对存入 Redis，10秒后删除 jedis.setex(\"checkCode\", 10, \"AbCd\"); System.out.println(jedis.get(\"checkCode\")); // 程序停顿10秒 Thread.sleep(10000); System.out.println(\"停顿10秒后，再获取 checkCode：\" + jedis.get(\"checkCode\")); // 删除 username jedis.del(\"username\"); // 关闭连接 jedis.close();} 输出： 123LeeHuaAbCd停顿10秒后，再获取 checkCode：null Hash (哈希)1234567891011121314151617181920212223242526272829/** 操作 Redis Hash 类型的数据 */@Testpublic void OperateHashTest() throws InterruptedException { // 获取连接：空参，默认为 \"127.0.0.1\", 6379 Jedis jedis = new Jedis(); // 存储 hash jedis.hset(\"user\", \"name\", \"LeeHua\"); jedis.hset(\"user\", \"age\", \"21\"); jedis.hset(\"user\", \"gender\", \"male\"); // 获取hash中的一个数据 System.out.println(jedis.hget(\"user\", \"name\")); System.out.println(jedis.hget(\"user\", \"age\")); System.out.println(jedis.hget(\"user\", \"gender\")); // 获取hash中所有map数据 Map&lt;String, String&gt; userMap = jedis.hgetAll(\"user\"); Set&lt;String&gt; users = userMap.keySet(); Iterator&lt;String&gt; userIterator = users.iterator(); while (userIterator.hasNext()) { String key = userIterator.next(); String value = userMap.get(key); System.out.println(key + \": \" + value); } // 删除 user 中的某个 key: value jedis.hdel(\"user\", \"name\"); jedis.hdel(\"user\", \"age\"); jedis.hdel(\"user\", \"gender\"); // 关闭连接 jedis.close();} 输出： 123456LeeHua21malegender: malename: LeeHuaage: 21 List（列表）12345678910111213141516171819202122232425/** 操作 Redis List 类型的数据 */@Testpublic void OperateListTest() { // 获取连接：空参，默认为 \"127.0.0.1\", 6379 Jedis jedis = new Jedis(); // 从 List 的左边存入数据 jedis.lpush(\"testList\", \"1\", \"2\", \"3\"); // 从 List 的右边存入数据 jedis.rpush(\"testList\", \"A\", \"B\", \"C\"); // 获取 List（列表） 数据 System.out.println(jedis.lrange(\"testList\", 0, 5)); // 删除 List（列表） 数据 // 从左边开始删除 String leftFirst = jedis.lpop(\"testList\"); String leftSecond = jedis.lpop(\"testList\"); String leftThird = jedis.lpop(\"testList\"); // 从右边开始删除 String rightFirst = jedis.rpop(\"testList\"); String rightSecond = jedis.rpop(\"testList\"); String rightThird = jedis.rpop(\"testList\"); System.out.println(\"左边开始删除：\" + leftFirst + \"、\" + leftSecond + \"、\" + leftThird); System.out.println(\"右边开始删除：\" + rightFirst + \"、\" + rightSecond + \"、\" + rightThird); // 关闭连接 jedis.close();} 输出： 123[3, 2, 1, A, B, C]左边开始删除：3、2、1右边开始删除：C、B、A Set（无序集合）12345678910111213141516/** 操作 Redis Set 类型的数据 */@Testpublic void OperateSetTest() { // 获取连接：空参，默认为 \"127.0.0.1\", 6379 Jedis jedis = new Jedis(); // 存储数据（存储的数据是没顺序的） jedis.sadd(\"BigData\", \"HDFS\", \"MapReduce\", \"Spark\", \"Storm\"); // 获取数据 Set&lt;String&gt; bigData = jedis.smembers(\"BigData\"); System.out.println(Arrays.toString(bigData.toArray())); // 删除数据 jedis.srem(\"BigData\", \"HDFS\", \"MapReduce\", \"Spark\", \"Storm\"); // 关闭连接 jedis.close();} 输出（无序的）： 1[Storm, HDFS, Spark, MapReduce] Zset（有序集合）123456789101112131415161718/** 操作 Redis Set 类型的数据 */@Testpublic void OperateSortSetTest() { // 获取连接：空参，默认为 \"127.0.0.1\", 6379 Jedis jedis = new Jedis(); // 存储数据（存储的数据是有顺序的，按照 score 进行排序的） jedis.zadd(\"BigData\", 10, \"HDFS\"); jedis.zadd(\"BigData\", 20, \"MapReduce\"); jedis.zadd(\"BigData\", 30, \"Spark\"); jedis.zadd(\"BigData\", 1, \"Storm\"); // 获取数据 Set&lt;String&gt; bigData = jedis.zrange(\"BigData\", 0, 3); System.out.println(Arrays.toString(bigData.toArray())); // 删除数据 jedis.zrem(\"BigData\", \"HDFS\", \"MapReduce\", \"Spark\", \"Storm\"); // 关闭连接 jedis.close();} 输出： 1[Storm, HDFS, MapReduce, Spark] Jedis 连接池Jedis 连接池的使用12345678910@Testpublic void JedisPoolTest() { // 创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(\"127.0.0.1\", 6379); // 从 Jedis 连接池中获取 Redis 连接对象 Jedis jedis = jedisPool.getResource(); System.out.println(\"服务正在运行: \" + jedis.ping()); // 将 Redis 连接对象归还到 Jedis 连接池 jedis.close();} 输出： 1服务正在运行: PONG Jedis 连接池工具类 配置文件：jedis.properties 12345678# redis服务器的IPhost=127.0.0.1# redis服务器的端口port=6379# 最大活动对象数maxTotal=50# 最大能够保持 idel 状态的对象数maxIdle=10 数据库连接池：JedisPoolUtils.java 12345678910111213141516171819202122232425262728293031323334353637383940414243import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class JedisPoolUtils { private static JedisPool jedisPool; // 读取配置文件 static { // 获取类加载器 ClassLoader classLoader = JedisPoolUtils.class.getClassLoader(); // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取 jedis.properties 配置文件资源输入流 InputStream jedisProperties = classLoader.getResourceAsStream(\"jedis.properties\"); // 加载配置文件 try { properties.load(jedisProperties); } catch (IOException e) { e.printStackTrace(); } // 将加载的配置文件数据，设置到 JedisPoolConfig 中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(properties.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(properties.getProperty(\"maxIdle\"))); // 初始化jedis连接池对象 jedisPool = new JedisPool( config, properties.getProperty(\"host\"), Integer.parseInt(properties.getProperty(\"port\")) ); } /** 获取连接的方法 */ public static Jedis getJedis() { return jedisPool.getResource(); }} 测试连接池 1234567891011/** 测试 JedisPoolUtils */@Testpublic void JedisPoolUtilsTest() { // 获取 Jedis 连接对象 Jedis jedis = JedisPoolUtils.getJedis(); System.out.println(\"连接成功\"); // 查看服务是否运行 System.out.println(\"服务正在运行: \" + jedis.ping()); // 将 Redis 连接对象归还到 Jedis 连接池 jedis.close();} 输出： 12连接成功服务正在运行: PONG 参考文献 Redis 教程| 菜鸟教程","link":"/p/291513202007/"},{"title":"Request和Response学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China 简单说明Request原理创建一个Tomcat项目 创建一个JavaEE项目：RequestAndResponse 创建一个demo.java：ServletDemo.java 123456789101112131415import javax.servlet.GenericServlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import java.io.IOException;@WebServlet(\"/demo01\")public class ServletDemo01 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"响应与请求的学习！！！\"); }} 启动服务器，客户端访问 http://localhost:8080/RequestAndResponse_war_exploded/demo01 ： 服务器端，执行service方法：即有 12控制台输出：响应与请求的学习！！！ 原理说明 客户端访问 http://localhost:8080/RequestAndResponse_war_exploded/demo01 ，也就是客户端发出请求 —— Request tomcat 服务器，会根据请求 URL 中的资源路径（ /RequestAndResponse_war_exploded/demo01 ），创建对应请求的 ServletDemo01 的对象。 然后，tomcat 服务器，会创建Request对象和Response对象，而Reques对象用来封装客户端请求的消息数据。 创建Request对象和Response对象之后，将这两个对象传递给 ServletDemo01 中的 service 方法。 获取到Request对象和Response对象之后，通过 service 方法体中的内容，来设置响应的消息数据。 服务器在给浏览器作出响应之前，会从Response对象中获取响应的消息数据。 参考假设来自客户的请求为：http://localhost:8080/test/index.jsp 12345678910111213141516171819202122232425请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得；Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应；Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host；Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）；localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context；Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为&quot;&quot;的Context去处理）；path=&quot;/test&quot;的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet；Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类；构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法；Context把执行完了之后的HttpServletResponse对象返回给Host；Host把HttpServletResponse对象返回给Engine；Engine把HttpServletResponse对象返回给Connector；Connector把HttpServletResponse对象返回给客户browser； 详情参考：https://www.jianshu.com/p/ffbf89dc2aba request 对象的继承体系结构 创建一个demo.java：ServletDemo02.java 12345678910111213141516171819202122import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo02\")public class ServletDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(req); // 获取request System.out.println(resp); // 获取response } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(req); // 获取request System.out.println(resp); // 获取response }} 启动服务器，并访问 http://localhost:8080/RequestAndResponse_war_exploded/demo02 ： 控制台输出： 12org.apache.catalina.connector.RequestFacade@2e009bd9org.apache.catalina.connector.ResponseFacade@2a3f0ac1 继承关系： HttpServletRequest接口 extends ServletRequest接口 RequestFacade 类 implements HttpServletRequest 接口 同样的，ResponseFacade类的继承关系，也是类似的。 为了确定 RequestFacade 类的继承关系，可以下载tomcat的源代码下来 从控制台的输出可以知道，RequestFacade类位于：/apache-tomcat-8.5.54-src/java/org/apache/catalina/connector/RequestFacade.java 查看其源码，可以知道： 123public class RequestFacade implements HttpServletRequest { ... ...} 参考文献 理解Tomcat工作原理 走进JavaWeb技术世界5：初探Tomcat的HTTP请求过程","link":"/p/540018202005/"},{"title":"Request和Response学习笔记3","text":"@Author: YiHua Lee @Address: Guangdong province, China 获取请求参数通用方式获取请求参数通用方式1234567891011String getParameter(String name)// 根据参数名称获取参数值String[] getParameterValues(String name)// 根据参数名称获取参数值的数组 Enumeration&lt;String&gt; getParameterNames()// 获取所有请求的参数名称Map&lt;String,String[]&gt; getParameterMap()// 获取所有参数的map集合 1无论get还是post请求方式都可以使用这些方法来获取请求参数 根据参数获取参数值 创建一个html文件：login02.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/RequestAndResponse_war_exploded/study/request/demo04&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;userEmail&quot; placeholder=&quot;请输入您的邮箱&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;userPassword&quot; placeholder=&quot;请输入您的密码&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;post登录&quot;&gt; &lt;/form&gt; &lt;br&gt; &lt;form action=&quot;/RequestAndResponse_war_exploded/study/request/demo04&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;userEmail&quot; placeholder=&quot;请输入您的邮箱&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;userPassword&quot; placeholder=&quot;请输入您的密码&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;get登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建一个类，RequestDemo04.java 1234567891011121314151617181920212223242526package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/study/request/demo04&quot;)public class RequestDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String userEmail = req.getParameter(&quot;userEmail&quot;); String userPassword = req.getParameter(&quot;userPassword&quot;); System.out.println(&quot;userEmail = &quot; + userEmail + &quot;\\n&quot; + &quot;userPassword = &quot; + userPassword); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String userEmail = req.getParameter(&quot;userEmail&quot;); String userPassword = req.getParameter(&quot;userPassword&quot;); System.out.println(&quot;userEmail = &quot; + userEmail + &quot;\\n&quot; + &quot;userPassword = &quot; + userPassword); }} 上面的 doGet() 方法 和 doPost() 方法中的方法体内容一样，可以进行修改： 1234567891011121314public class RequestDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String userEmail = req.getParameter(\"userEmail\"); String userPassword = req.getParameter(\"userPassword\"); System.out.println(\"userEmail = \" + userEmail + \"\\n\" + \"userPassword = \" + userPassword); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); }} 浏览器访问：http://localhost:8080/RequestAndResponse_war_exploded/login02.html Post 请求 控制台输出： 12userEmail = post@icloud.comuserPassword = 123456 页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo04 Get 请求 控制台输出： 12userEmail = get@icloud.comuserPassword = abcdef 页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo04?userEmail=get%40icloud.com&amp;userPassword=abcdef 根据参数名称获取参数值的数组 创建一个html文件：login03.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;爱好&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/RequestAndResponse_war_exploded/study/request/demo05\" method=\"post\"&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt; 学习 &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt; 游戏 &lt;br&gt; &lt;input type=\"submit\" value=\"post提交\"&gt; &lt;/form&gt; &lt;br&gt; &lt;form action=\"/RequestAndResponse_war_exploded/study/request/demo05\" method=\"get\"&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt; 学习 &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt; 游戏 &lt;br&gt; &lt;input type=\"submit\" value=\"get提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建一个demo.java：RequestDemo05.java 1234567891011121314151617181920212223242526package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/study/request/demo05\")public class RequestDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 根据参数名称获取参数值的数组 String[] hobbies = req.getParameterValues(\"hobby\"); // 参数名称为hobby for (String hobby : hobbies) { System.out.println(hobby); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); }} 启动服务器，访问：http://localhost:8080/RequestAndResponse_war_exploded/login03.html 这里两种提交方式都一样！！！ 选择：study，并提交，控制台输出 1study 浏览器页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo05 选择：study、game并提交，控制台输出 1study game 浏览器页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo05 获取所有请求的参数名称 创建一个类，RequestDemo06.java 1234567891011121314151617181920212223242526272829package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/study/request/demo06\")public class RequestDemo06 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取所有请求参数名称 Enumeration&lt;String&gt; parameterNames = req.getParameterNames(); while (parameterNames.hasMoreElements()) { String parameterName = parameterNames.nextElement(); // 输出参数名称，已经根据参数名称输出对应的值 System.out.println(parameterName + \":\" + req.getParameter(parameterName) + \"\\n\"); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); }} 创建余个html文件：login04.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户爱好&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/RequestAndResponse_war_exploded/study/request/demo06\" method=\"get\"&gt; &lt;label&gt;&lt;input type=\"email\" name=\"userEmail\" placeholder=\"请输入您的邮箱\"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;&lt;input type=\"password\" name=\"userPassword\" placeholder=\"请输入您的密码\"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby1\" value=\"study\"&gt;&lt;/label&gt; 学习 &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby2\" value=\"game\"&gt;&lt;/label&gt; 游戏 &lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器，访问：http://localhost:8080/RequestAndResponse_war_exploded/login04.html 提交，控制台输出： 1234567userEmail:stringbug@icloud.comuserPassword:123456hobby1:studyhobby2:game 浏览器页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo06?userEmail=stringbug%40icloud.com&amp;userPassword=123456&amp;hobby1=study&amp;hobby2=game 获取所有参数的map集合 创建一个html文件：login05.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户爱好&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/RequestAndResponse_war_exploded/study/request/demo07\" method=\"get\"&gt; &lt;label&gt;&lt;input type=\"email\" name=\"userEmail\" placeholder=\"请输入您的邮箱\"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;&lt;input type=\"password\" name=\"userPassword\" placeholder=\"请输入您的密码\"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt;&lt;/label&gt; 学习 &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt;&lt;/label&gt; 游戏 &lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login05.html 与 login04.html 的差别是：将hobby1、hobby2均改为了hobby 将路径中的demo06改为了demo07 创建一个类：RequestDemo07.java 12345678910111213141516171819202122232425262728293031323334353637package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Map;import java.util.Set;@WebServlet(\"/study/request/demo07\")public class RequestDemo07 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取所有请求参数的map集合 Map&lt;String, String[]&gt; parameterMap = req.getParameterMap(); // 获取所有的请求名称 Set&lt;String&gt; parameterNames = parameterMap.keySet(); for (String parameterName : parameterNames) { // 输出每个请求名称 System.out.println(\"请求名称 -- \" + parameterName); // 根据请求名称获取对应的请求值 String[] parameterValues = req.getParameterValues(parameterName); for (String parameterValue : parameterValues) { // 输出每个请求值 System.out.println(parameterName + \":\" + parameterValue); } } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); }} 启动服务器，访问：http://localhost:8080/RequestAndResponse_war_exploded/login05.html 提交，控制台输出： 1234567请求名称 -- userEmailuserEmail:stringbug@icloud.com请求名称 -- userPassworduserPassword:123456请求名称 -- hobbyhobby:studyhobby:game 浏览器页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo07?userEmail=stringbug%40icloud.com&amp;userPassword=123456&amp;hobby=study&amp;hobby=game 参考文献无","link":"/p/562118202005/"},{"title":"Request和Response学习笔记2","text":"@Author: YiHua Lee @Address: Guangdong province, China Request 获取请求行数据获取方法123456789101112131415161718String getMethod()// 获取请求方式String getContextPath()// 获取虚拟目录String getServletPath()// 获取Servlet路径String getRequestURI()StringBuffer getRequestURL()// 获取请求URI、URLString getProtocol()// 获取协议及版本String getRemoteAddr()// 获取客户机的IP地址 URI &amp; URL 的说明： URL：统一资源定位符 URI：统一资源标识符 如： 例子1 http://localhost/stringbug/demo1 —— URL /stringbug/demo1 —— URI 例子2 中华人民共和国 —— URL 共和国 —— URI 创建一个类，继承HttpServlet类1234567891011121314151617181920package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/study/request/demo01\")public class RequestDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { }} String getMethod() 方法12345protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getMethod() 获取请求方式 System.out.println(req.getMethod());} String getContextPath() 方法12345protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getContextPath() 获取虚拟目录 System.out.println(req.getContextPath());} String getServletPath() 方法12345protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getServletPath() 获取Servlet路径 System.out.println(req.getServletPath());} String getRequestURI()、StringBuffer getRequestURL() 方法1234567protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getRequestURI() 获取请求URI // StringBuffer getRequestURL() 获取请求URL System.out.println(req.getRequestURI()); System.out.println(req.getRequestURL());} String getProtocol() 方法12345protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getProtocol() 获取协议及版本 System.out.println(req.getProtocol());} String getRemoteAddr() 方法12345protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getRemoteAddr() 获取客户机的IP地址 System.out.println(req.getRemoteAddr());} 创建一个html文件12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Request Study&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/RequestAndResponse_war_exploded/study/request/demo01\" method=\"get\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"get提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 开启服务器 用户访问：http://localhost:8080/RequestAndResponse_war_exploded/HelloRequest.html 随便输入点内容，提交，如输入：RequestTest 页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo01?username=RequestTest 获取请求方式：getMethod() 方法输出 1GET 获取虚拟目录：getContextPath() 方法输出 1/RequestAndResponse_war_exploded 获取Servlet路径：getServletPath() 方法输出 1/study/request/demo01 获取请求URI：getRequestURI() 方法输出 1/RequestAndResponse_war_exploded/study/request/demo01 获取请求URL：getRequestURL() 方法输出 1http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo01 获取协议及版本：getProtocol() 方法输出 1HTTP/1.1 获取客户机的IP地址：getRemoteAddr() 方法输出 10:0:0:0:0:0:0:1 Request 获取请求头数据获取方法12345String getHeader(String name)// 通过请求头的名称获取请求头的值Enumeration&lt;String&gt; getHeaderNames()// 获取所有的请求头名称 创建一个类(RequestDemo02.java)，使用这两个方法1234567891011121314151617181920212223242526package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/study/request/demo02\")public class RequestDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取所有请求头名称 Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); // Enumeration接口，功能由Iterator复制。 while (headerNames.hasMoreElements()) { String headerName = headerNames.nextElement(); // 根据请求头名称获取请求头名称的值 String headerValue = req.getHeader(headerName); System.out.println(headerName + \" : \" + headerValue); } }} 开启服务器访问：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo02 控制台输出： 自己根据请求头名字获取请求头user-agent获取用户访问资源链接时使用的浏览器。 12345678910111213141516171819202122232425262728293031package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/study/request/demo02\")public class RequestDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 演示获取请求头数据：user-agent String userAgentValue = req.getHeader(\"user-agent\"); // 判断用户使用什么浏览器发出的请求 if (userAgentValue.contains(\"Chrome\")) { System.out.println(\"来自谷歌浏览器的访问！！！\"); } else if (userAgentValue.contains(\"Firefox\")) { System.out.println(\"来自火狐浏览器的访问！！！\"); } else if (userAgentValue.contains(\"XXX\")) { System.out.println(\"来自 XXX 浏览器的访问！！！\"); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { }} 谷歌浏览器访问：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo02 控制台输出： 1来自谷歌浏览器的访问！！！ referer获取用户跳转到目的页面之前的那个页面的URL 1234567891011121314151617181920212223242526272829package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/study/request/demo02\")public class RequestDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 演示获取请求头数据：referer String refererValue = req.getHeader(\"referer\"); System.out.println(refererValue); if (refererValue.contains(\"/RequestAndResponse_war_exploded\")) { System.out.println(\"可以正常访问\"); } else { System.out.println(\"不可以正常访问\"); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { }} 浏览器访问：http://localhost:8080/RequestAndResponse_war_exploded/HelloRequest02.html 点击看电影，页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo02?View+Name=唐人街探案3 控制台输出： 12http://localhost:8080/RequestAndResponse_war_exploded/HelloRequest02.html可以正常访问 假如不是从 /RequestAndResponse_war_exploded 资源链接中跳转过来的话，那么，控制台会输出：不可以正常访问 也可以更改上例中的部分内容，是的部分输出在页面上： 1234// 将这部分内容修改System.out.println(\"可以正常访问\");System.out.println(\"不可以正常访问\"); 12345678// 修改为System.out.println(\"可以正常访问\");resp.setContentType(\"text/html;charset=utf-8\");resp.getWriter().write(\"你可以看电影～～～\");System.out.println(\"不可以正常访问\");resp.setContentType(\"text/html;charset=utf-8\");resp.getWriter().write(\"你不可以看电影～～～\"); 从 /RequestAndResponse_war_exploded 资源链接中跳转过来，控制台输出： 12http://localhost:8080/RequestAndResponse_war_exploded/HelloRequest02.html可以正常访问 点击看电影，页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo02?View+Name=唐人街探案3 页面内容如下： Request 获取请求体的数据步骤 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 简单实现 创建一个demo.java：RequestDemo03.java 123456789101112131415161718192021222324package study.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;@WebServlet(\"/study/request/demo03\")public class RequestDemo03 extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取请求消息体 // 1. 获取字符流 BufferedReader reqReader = req.getReader(); String line; while ((line = reqReader.readLine()) != null) { System.out.println(line); } }} 创建一个html文件：login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/RequestAndResponse_war_exploded/study/request/demo03\" method=\"post\"&gt; &lt;input type=\"email\" name=\"userEmail\" placeholder=\"请输入您的邮箱\"&gt;&lt;br&gt; &lt;input type=\"password\" name=\"userPassword\" placeholder=\"请输入您的密码\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器，浏览器访问：http://localhost:8080/RequestAndResponse_war_exploded/login.html 点击登录，页面跳转到：http://localhost:8080/RequestAndResponse_war_exploded/study/request/demo03 控制台输出： 1userEmail=stringbug%40icloud.com&amp;userPassword=123456 浏览器页面内容： 参考文献 HttpServletRequest获取客户端所有参数 JavaEE-HttpServletRequest总结","link":"/p/311618202005/"},{"title":"Redis 的下载与安装（macOS系统）","text":"@Author: YiHua Lee @Address: Guangdong province, China 利用Homebrew安装Redis 搜索一下Redis安装包 1brew search redis 安装 Redis 4.0 版本 1brew install redis@4.0 配置 Redis configure文件：/usr/local/etc 下修改redis.config找到 daemonize no改成yes 以守护进程的方式启动 配置环境变量 1vim ~/.bash_profile 添加如下内容： 1export PATH=&quot;/usr/local/opt/redis@4.0/bin:$PATH&quot; 启动 Redis Server 1brew services start redis@4.0 或者 1redis-server /usr/local/etc/redis.conf 连接 Redis 客户端（Client）：redis-cli -h host -p port ip：host port：端口 1redis-cli -h 127.0.0.1 -p 6379 关闭 Redis 客户端 1redis-cli shutdown 安装包安装 Redis 下载Redis 5.08 ：http://download.redis.io/releases/redis-5.0.8.tar.gz?_ga=2.251273284.33659307.1594539057-1473159822.1594539057 把下载的压缩包解压并放置到 /usr/local/ 目录下 1sudo tar -zxvf redis-5.0.8.tar.gz -C /usr/local/ 进入 root 用户 1sudo -i 编译和安装 1cd /usr/local/redis-5.0.8 编译测试： 1make test 此处可能会报错：[exception]: Executing test client: couldn't execute &quot;src/redis-benchmark&quot;:make[1]: *** [test] Error 1 make: *** [test] Error 2 解决：执行如下命令 make distclean、make、make test 编译安装： 1make install Redis配置12sudo -icd /usr/local/redis-5.0.8 在redis目录下建立bin，etc，db三个目录 123mkdir binmkdir etcmkdir db 把 /usr/local/redis-5.0.8/src 目录下的 mkreleasehdr.sh、redis-benchmark、redis-check-rdb、redis-cli、redis-server 拷贝到 /usr/local/redis-5.0.8/bin 目录下 1234567cd /usr/local/redis-5.0.8/srccp mkreleasehdr.sh /usr/local/redis-5.0.8/bincp redis-benchmark /usr/local/redis-5.0.8/bincp redis-check-rdb /usr/local/redis-5.0.8/bincp redis-cli /usr/local/redis-5.0.8/bincp redis-server /usr/local/redis-5.0.8/bin 在 /usr/local/redis-5.0.8 目录下 新建日志文件： log-redis.log 12cd /usr/local/redis-5.0.8touch log-redis.log 修改 redis.conf 12cd /usr/local/redis-5.0.8vim redis.conf 修改的内容如下： 123456789101112131415161718192021222324252627282930313233343536#修改为守护模式daemonize yes#设置进程锁文件pidfile /usr/local/redis-5.0.8/redis.pid#端口port 6379#客户端超时时间timeout 300#日志级别loglevel debug#日志文件位置logfile /usr/local/redis-5.0.8/log-redis.log#设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库iddatabases 16##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save &lt;seconds&gt; &lt;changes&gt;#Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes#指定本地数据库文件名dbfilename dump.rdb#指定本地数据库路径dir /usr/local/redis-5.0.8/#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly yes#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec 12cd /usr/local/redis-5.0.8cp redis.conf ./etc Redis 服务端启动与关闭、客户端启动与关闭 启动服务，并制定配置文件 1cd /usr/local/redis-5.0.8 1./bin/redis-server ./etc/redis.conf 查看日志文件 1tail -f log-redis.log 打开redis客户端 1cd /usr/local/redis-5.0.8 1./bin/redis-cli 退出redis客户端命令行 1exit 查看一下redis进程 1ps -ef | grep -i redis 关闭redis 1cd /usr/local/redis-5.0.8 1./bin/redis-cli shutdown 强制关闭服务端 1sudo -i 1ps -ef | grep -i redis 1kill -9 PID 参考文献 【redis】mac 安装redis mac os 安装 redis Mac 下 Redis 5.0 的卸载与安装 mac 环境下安装 redis 及配置 mac redis启动与关闭 redis 服务器启动与关闭","link":"/p/421912202007/"},{"title":"Request和Response学习笔记4","text":"@Author: YiHua Lee @Address: Guangdong province, China Request 获取请求参数，中文乱码问题实例引入： 创建一个html文件：garbled.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;中文乱码问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/RequestResponseCharset_war_exploded/demo01\" method=\"get\"&gt; &lt;label&gt;&lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;/label&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"get提交\"&gt; &lt;/form&gt; &lt;br&gt; &lt;form action=\"/RequestResponseCharset_war_exploded/demo01\" method=\"post\"&gt; &lt;label&gt;&lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;/label&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"post提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建一个类：CharsetGarbled.java 123456789101112131415161718192021222324252627282930import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Author: YiHua Lee * @Version: 1.8.0_201 Java SE 8 * @Application: IntelliJ IDEA * @CreateTime: 2020/5/18 22:10 * @Description: */@WebServlet(\"/demo01\")public class CharsetGarbled extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取请求参数 String username = req.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); }} 启动服务器，浏览器访问：http://localhost:8080/RequestResponseCharset_war_exploded/garbled.html get提交 控制台输出： 1彩虹 浏览器页面跳转到：http://localhost:8080/RequestResponseCharset_war_exploded/demo01?username=%E5%BD%A9%E8%99%B9&amp;password=2018 post提交 控制台输出： 1å½©è¹ 浏览器页面跳转到：http://localhost:8080/RequestResponseCharset_war_exploded/demo01 解决中文乱码问题 只需要改动doGet()方法即可： 12345678910@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 设置流的编码 req.setCharacterEncoding(\"utf-8\"); // 获取请求参数 String username = req.getParameter(\"username\"); System.out.println(username);} 重启服务器，再次访问：http://localhost:8080/RequestResponseCharset_war_exploded/garbled.html 并用post提交，控制台输出： 1彩虹 浏览器页面跳转到：http://localhost:8080/RequestResponseCharset_war_exploded/demo01 参考文献 解决Tomcat请求中文乱码的问题 更改Tomcat字符编码设置及解决post请求中文字符乱码 Tomcat Http请求中文乱码","link":"/p/381019202005/"},{"title":"Request和Response学习笔记5","text":"@Author: YiHua Lee @Address: Guangdong province, China 服务器内部请求的转发这里请求传递所使用的方法： 12345// 通过request对象获取请求转发器对象RequestDispatcher getRequestDispatcher(String path)// 使用RequestDispatcher对象来进行转发forward(ServletRequest request, ServletResponse response) 实例引入 创建一个Web项目：RequestDelivery 创建两个类，在这两个类之间进行请求的传递： RequestDemo01.java 12345678910111213141516171819202122232425import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo01\")public class RequestDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo01被访问了！\"); // 获取请求发送对象 RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/demo02\"); // 发送请求 requestDispatcher.forward(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} RequestDemo02.java 1234567891011121314151617181920import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo02\")public class RequestDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"我是demo02，demo01的请求对象已经传递过来了！\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，访问：http://localhost:8080/RequestDelivery_war_exploded/demo01 控制台输出： 12demo01被访问了！我是demo02，demo01的请求对象已经传递过来了！ 页面不会跳转，还在在demo1页面。 特点 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中。不能转发到其他服务器。 用户的发送请求是一次，被转发的请求也是用户发送的请求对象。 Request共享数据 备注： 域对象：一个有作用范围的对象，可以在一定范围内共享数据。 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据。 方法： 12345678// 存储数据void setAttribute(String name,Object obj)// 通过键获取值Object getAttitude(String name)// 通过键移除键值对void removeAttribute(String name) 实例引入创建两类： RequestDemo03.java 12345678910111213141516171819202122232425import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo03\")public class RequestDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo03被访问了！\"); // 获取请求发送对象 RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/demo04\"); // 发送请求 requestDispatcher.forward(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} RequestDemo04.java 1234567891011121314151617181920import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo04\")public class RequestDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"我是demo04，demo03的请求对象已经传递过来了！\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 存储数据 修改RequestDemo03.java中的doGet()方法： 123456789101112@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo03被访问了！\"); // 存储数据到request域中 request.setAttribute(\"Set's Message\", \"Hello, setAttribute!\"); // 获取请求发送对象 RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/demo04\"); // 发送请求 requestDispatcher.forward(request, response);} 修改RequestDemo04.java中的doGet()方法： 1234567@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"我是demo04，demo03的请求对象已经传递过来了！\"); // 获取request域数据 System.out.println(request.getAttribute(\"Set's Message\"));} 启动服务器，访问：http://localhost:8080/RequestDelivery_war_exploded/demo03 控制台输出： 123demo03被访问了！我是demo04，demo03的请求对象已经传递过来了！Hello, setAttribute! 参考文献无","link":"/p/581219202005/"},{"title":"Response对象学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China Response 对象功能介绍功能：设置响应消息（响应头、响应行、响应体） 设置响应行： 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name, String value) 设置响应体： 使用步骤： 获取输出流 12PrintWriter getWriter() // 字符输出流ServletOutputStream getOutputStream() // 字节输出流 使用输出流，将数据输出到客户端浏览器 Response 对象的学习案例完成重定向 要求：用户通过浏览器访问 demo01 资源，重定向到 demo02 资源 实现： 创建一个 JavaEE - Tomcat项目（ResponseHttp） 定义两个类：demo01、demo02 12345678910111213141516171819202122232425262728293031323334import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo01\")public class ResponseDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo01 被访问啦！！！\"); // 要求：用户通过浏览器访问 /demo01 资源，会自动跳转到 /demo02 资源 // 实现如下： // 1. 设置状态码为 302 ———— 重定向状态码 response.setStatus(302); // 2. 设置响应头location，对应 demo02 的资源路径 response.setHeader(\"location\", \"/ResponseHttp_war_exploded/demo02\"); /* 简单的重定向方法 response.sendRedirect(\"/ResponseHttp_war_exploded/demo02\"); 这里的虚拟目录/ResponseHttp_war_exploded，推荐动态获取，因为一旦虚拟目录改变， 如果不是动态获取的虚拟目录，将于全部进行修改。 response.sendRedirect(request.getContextPath() + \"/demo02\"); */ } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 123456789101112131415161718192021import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo02\")public class ResponseDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo02 被访问啦！！！\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，用户访问：http://localhost:8080/ResponseHttp_war_exploded/demo01 服务器端输出（即编译器控制台输出） 1demo01 被访问啦！！！ 用户浏览器页面跳转到：http://localhost:8080/ResponseHttp_war_exploded/demo02 服务器端输出 1demo02 被访问啦！！！ 浏览器中检查Network如下： demo01 demo02 重定向的特点重定向（redirect）特点不同于 Request请求转发（forward）。 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 服务器输出字符数据到浏览器 实现代码： 1234567891011121314151617181920212223242526272829303132333435import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(\"/demo03\")public class ResponseDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 乱码问题的解决 // 解决方式1 // 获取流对象之前，将流对象默认的编码（ISO-8859-1）修改为 GBK request.setCharacterEncoding(\"GBK\"); response.setCharacterEncoding(\"GBK\"); // 解决方式2 // 告诉浏览器，服务器发送的消息体数据编码，建议浏览器使用该编码 // response.setHeader(\"content-type\", \"text/html;charset=utf-8\"); // 解决方式3 // response.setContentType(\"text/html;charset=utf-8\"); // 获取字符输出流 PrintWriter responseWriter = response.getWriter(); // 输出数据 responseWriter.write(\"&lt;h1&gt;你好，Response！&lt;/h1&gt;&lt;br&gt;&lt;h2&gt;你好，Response！&lt;/h2&gt;\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 浏览器访问：http://localhost:8080/ResponseHttp_war_exploded/demo03 乱码问题 获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码 12// 简单的形式，设置编码，是在获取流之前设置response.setContentType(\"text/html;charset=utf-8\"); 服务器输出字节数据到浏览器 实现代码： 12345678910111213141516171819202122232425262728import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(\"/demo04\")public class ResponseDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 告诉浏览器，服务器发送的消息体数据编码，建议浏览器使用该编码（设置响应头中的content-type值） response.setContentType(\"text/html;charset=utf-8\"); // 获取字节输出流 ServletOutputStream responseOutputStream = response.getOutputStream(); // 输出数据 responseOutputStream.write(\"你好，Response！\".getBytes(StandardCharsets.UTF_8)); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 开启服务器，浏览器访问：http://localhost:8080/ResponseHttp_war_exploded/demo04，浏览器页面输出 1你好，Response！ 验证码 Java 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 定义验证码方框长和宽 int width = 100, height = 50; // 创建一个对象，在内存中画图（验证码图片对象） BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR); // 美化图片 // 创建画笔对象 Graphics graphics = bufferedImage.getGraphics(); // 设置画笔的颜色 graphics.setColor(Color.PINK); // 用画笔，将制定的长方形区域，画满（画验证码图片背景 -&gt; 粉红色） graphics.fillRect(0, 0, width, height); // 画验证码图片边框 // 设置画笔的颜色 graphics.setColor(Color.BLACK); graphics.drawRect(0, 0, width - 1, height - 1); // 定义一个包含所有字幕和数字的字符串（验证码） String strings = \"QqWwEeRrTtYyUuIiOoPpAaSsDdFfGgHhJjKkLlZzXxCcVvBbNnMm1234567890\"; // 创建随机数对象，用来获取字符串中的一个字符 Random random = new Random(); // 写入四个字符在验证码方框中 int codeNumber = 4; for (int i = 1; i &lt;= codeNumber; i++) { // strings 索引 int index = random.nextInt(strings.length()); // 通过索引获取字符 char indexString = strings.charAt(index); // 写入一个验证符 graphics.drawString(indexString + \"\", width / 5 * i, height / 2); } // 在验证码方框中画干扰线 graphics.setColor(Color.GREEN); int lineNumber = 10; for (int i = 0; i &lt; lineNumber; i++) { // 生成随机坐标点 int x1 = random.nextInt(width); int x2 = random.nextInt(width); int y1 = random.nextInt(height); int y2 = random.nextInt(height); // 画线 graphics.drawLine(x1, y1, x2, y2); } // 将图片输出到页面展示 ImageIO.write(bufferedImage, \"png\", response.getOutputStream()); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器中访问：http://localhost:8080/ResponseHttp_war_exploded/checkCodeServlet 上面这需要刷新页面，才能更新验证码。 下面编写html页面，指定对应的CheckCodeServlet.java 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;验证码&lt;/title&gt; &lt;script&gt; /* 分析： 点击超链接或者图片，需要换一张 1.给超链接和图片绑定单击事件 2.重新设置图片的src属性值 */ window.onload = function(){ // 1.获取图片对象 const img = document.getElementById(\"checkCode\"); // 2.绑定单击事件 img.onclick = function(){ // 加时间戳（因为需要每次请求的url都不一样） const date = new Date().getTime(); img.src = \"/ResponseHttp_war_exploded/checkCodeServlet?\"+date; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;img id=\"checkCode\" src=\"/ResponseHttp_war_exploded/checkCodeServlet\" /&gt; &lt;a id=\"change\" href=\"\"&gt; 看不清换一张？&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 启动服务器，浏览器访问：http://localhost:8080/ResponseHttp_war_exploded/CheckCodeHtml.html 每次点击图片，都会直接更换验证码，请求的url都是随时间的变化而变化的，而点击 看不清换一张 则仅仅只是刷新了一次该页面。 参考文献无","link":"/p/040428202005/"},{"title":"Servlet 学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China Servlet 是什么？ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 简单的说：Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。Servlet 全称 server applet Servlet 架构下图显示了 Servlet 在 Web 应用程序中的位置。 Servlet 任务Servlet 执行以下主要任务： 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 包 Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。 Servlet 可以使用 javax.servlet和 javax.servlet.http包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。 Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。 快速入门创建JavaEE项目阶段 创建一个项目 创建的是JavaEE项目 项目创建之后 web目录下的WEB-INF文件夹中新建两个文件夹，起名分别为classes和lib 设置classes路径 选择刚才创建的文件夹classes的路径： 配置lib的路径 点击加号选择 -&gt; JARs or diretories -&gt; 选择lib文件夹 -&gt; Jar Diretory -&gt; OK，然后： 配置tomcat服务器 这里可以不选择After launch，选择这个，每次运行程序都会使用浏览器打开设置的URL Servlet的实现阶段 对项目导入servlet架包（架包在本地安装的tomcat/lib目录下） File -&gt; Project Structure -&gt; Libraries -&gt; 点击小加号 -&gt; Java -&gt; 选择servlet架包 编写Servlet源文件（在src文件夹中编写） 这里在 src 文件夹里创建了 my.servlet.study包，然后再编写Servlet源文件 12345678910111213141516171819package my.servlet.study;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ServletDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"请求已经收到！！！\"); } @Override public void destroy() { super.destroy(); }} 部署Servlet（在 web/WEB-INF/web.xml 文档中添加如下内容） 12345678910&lt;!-- 配置Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;!-- 自己继承Servlet类的类名称：自定义 --&gt; &lt;servlet-class&gt;my.servlet.study.ServletDemo01&lt;/servlet-class&gt; &lt;!-- 该类的全路径 --&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;!-- servlet 的映射名称 --&gt; &lt;url-pattern&gt;/my.servlet.study.ServletDemo01&lt;/url-pattern&gt; &lt;!-- servlet 的映射路径(url)，该路径与类全路径一样 --&gt;&lt;/servlet-mapping&gt; 启动成功后 在浏览器地址栏输入： 首页：http://localhost:8080/TomcatServletStudy_war_exploded/ 首页：http://localhost:8080/TomcatServletStudy_war_exploded/index.jsp 输入：http://localhost:8080/TomcatServletStudy_war_exploded/my.servlet.study.ServletDemo01 IDEA控制台输出：请求已经收到！！！ 到此一个简单的Servlet项目就配置好了。 Servlet的执行原理 单服务器服务器收到客户端浏览器的请求后，会解析客户端请求的URL，获取Servlet的资源路径。 查找web.xml文档，查看是否有对应的 &lt;url-pattern&gt; 标签体内容。 如果有对应的 &lt;url-pattern&gt; 标签体内容，则通过 &lt;servlet-mapping&gt; 标签中的 &lt;servlet-name&gt; 标签，找到相同名的 &lt;servlet&gt; 标签中的 &lt;servlet-name&gt; 标签。 然后通过 &lt;servlet-name&gt; 标签，找到 &lt;servlet-class&gt; 标签中的全类名。 tomcat会将对应类的字节码文件加载入内存，并创建其对象。 调用 doGet() 方法。 参考文献 Servlet菜鸟教程 Mac下IntelliJ IDEA 配置Servlet","link":"/p/042314202005/"},{"title":"Servlet学习笔记2","text":"@Author: YiHua Lee @Address: Guangdong province, China 简述Servlet接口中的抽象方法 Servlet接口中的抽象方法 1234567891011121314// 初始化方法void init(ServletConfig var1);// 获取Servlet配置对象ServletConfig getServletConfig();// 提供服务的方法void service(ServletRequest var1, ServletResponse var2);// 获取Servlet信息，如版本、作者...String getServletInfo();// 销毁方法void destroy(); 初始化方法 123456789/** * 初始化方法（只执行一次） * @param servletConfig servlet 配置 * @throws ServletException servlet 异常 */@Overridepublic void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"这是初始化方法！！！\");} 提供服务的方法 123456789101112/** * 提供服务的方法 * @param servletRequest servlet 请求 * @param servletResponse servlet 响应 * @throws ServletException servlet 异常 * @throws IOException io 异常 */@Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"这是一个提供服务的方法！！！\");} 销毁方法 12345678/** * 这是一个销毁方法，在服务器正常关闭，就如tomcat执行了 `shutdown.sh` 。 * 只执行一次。 */@Overridepublic void destroy() { System.out.println(\"这是一个销毁方法！！！\");} 实现 Servlet 接口代码 12345678910111213141516171819202122232425262728293031import javax.servlet.*;import java.io.IOException;public class ServletDemo02 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"这是初始化方法！！！\"); } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"这是一个提供服务的方法！！！\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { System.out.println(\"这是一个销毁方法！！！\"); }} 配置文件 web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;demo2&lt;/servlet-name&gt; &lt;servlet-class&gt;my.servlet.study.ServletDemo02&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;demo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/my.servlet.study.ServletDemo02&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet 接口实现类的使用 启动服务器，控制台输出： 1这是初始化方法！！！ 启动服务器后，访问：http://localhost:8080/TomcatServletStudy_war_exploded/my.servlet.study.ServletDemo02 ，控制台输出： 1这是一个提供服务的方法！！！ 每次访问该网址，都会执行一次 service 方法 关闭服务器，控制台输出： 1这是一个销毁方法！！！ 利用 web.xml 配置文件，修改 init方法的执行时机： 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;demo2&lt;/servlet-name&gt; &lt;servlet-class&gt;my.servlet.study.ServletDemo02&lt;/servlet-class&gt; &lt;!-- 指定Servlet的创建时机 1. 第一次被访问是创建 &lt;load-on-startup&gt; 的值为负数 2. 服务器启动时被创建 &lt;load-on-startup&gt; 的值为0或者正数 --&gt; &lt;load-on-startup&gt;-5&lt;/load-on-startup&gt;&lt;/servlet&gt; 备注： Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象， Servlet是单例的。 因此多个用户同时访问时，可能存在线程安全问题。 解决：尽不要在 Servlet中定义成员変。即使定义了成员变,也不要对修改值。 参考文献 Servlet 生命周期 Servlet 生命周期、工作原理","link":"/p/321515202005/"},{"title":"ServletContext 对象的学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China ServletContext对象概述ServletContext用来存放全局变量，每个Java虚拟机每个Web项目只有一个ServletContext，这个ServletContext是由Web服务器创建的，来保证它的唯一性。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象通讯。ServletContext对象通常也被称之为Context域对象。 获取方式 通过request对象获取 1request.getServletContext(); 通过HttpServlet获取 1this.getServletContext(); 获取ServletContext对象12345678910111213141516171819202122232425262728import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo01\")public class ServletContextDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 通过 Request 对象获取 ServletContext 对象 ServletContext requestServletContext = request.getServletContext(); // 通过 HttpServlet 获取 ServletContext 对象 ServletContext servletContext = this.getServletContext(); System.out.println(requestServletContext); System.out.println(servletContext); System.out.println(requestServletContext == servletContext); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器访问：http://localhost:8080/ServletContext_war_exploded/demo01 控制台输出： 123org.apache.catalina.core.ApplicationContextFacade@86cb2b8org.apache.catalina.core.ApplicationContextFacade@86cb2b8true ServletContext对象功能 获取MIME类型 MIME类型:在互联网通信过程中定义的一种文件数据类型 如：大类型/小类型 text/html image/jpeg 获取方法： 1String getMimeType(String file) 域对象：共享数据 123setAttribute(String name,Object value)getAttribute(String name)removeAttribute(String name) 获取文件的真实(服务器)路径 1String getRealPath(String path) 获取mime 类型12345678910111213141516171819202122232425262728293031import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo02\")public class ServletContextDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 通过 HttpServlet 获取 ServletContext 对象 ServletContext servletContext = this.getServletContext(); // 定义文件名称 String fileName01 = \"a.png\"; String fileName02 = \"b.jpeg\"; // 获取 MIME 类型 String mimeType01 = servletContext.getMimeType(fileName01); System.out.println(mimeType01); String mimeType02 = servletContext.getMimeType(fileName02); System.out.println(mimeType02); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器访问：http://localhost:8080/ServletContext_war_exploded/demo02 控制台输出： 12image/pngimage/jpeg 域对象：共享数据12345678910111213141516171819202122232425import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo03\")public class ServletContextDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 通过 HttpServlet 获取 ServletContext 对象 ServletContext servletContext = this.getServletContext(); // 设置数据 servletContext.setAttribute(\"demo03's data\", \"我是demo03这里设置的数据！！！\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 12345678910111213141516171819202122232425import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo04\")public class ServletContextDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 通过 HttpServlet 获取 ServletContext 对象 ServletContext servletContext = this.getServletContext(); // 获取demo03中设置的数据 System.out.println(servletContext.getAttribute(\"demo03's data\")); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器中访问：http://localhost:8080/ServletContext_war_exploded/demo03，目的是，访问demo03，设置数据。 然后，浏览器中访问：http://localhost:8080/ServletContext_war_exploded/demo04。控制台输出： 1我是demo03这里设置的数据！！！ 获取文件的真实(服务器)路径1234567891011121314151617181920212223242526import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo05\")public class ServletContextDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 通过 HttpServlet 获取 ServletContext 对象 ServletContext servletContext = this.getServletContext(); // 获取文件的服务器路径 System.out.println(servletContext.getRealPath(\"/file01.txt\")); System.out.println(servletContext.getRealPath(\"/WEB-INF/file02.txt\")); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器中访问：http://localhost:8080/ServletContext_war_exploded/demo05 控制台输出： 12/Users/liyihua/IdeaProjects/ServletContext/out/artifacts/ServletContext_war_exploded/file01.txt/Users/liyihua/IdeaProjects/ServletContext/out/artifacts/ServletContext_war_exploded/WEB-INF/file02.txt 案例 文件下载需求： 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析： 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 任何资源都必须弹出下载提示框 使用响应头设置资源的打开方式： content-disposition:attachment;filename=xxx 步骤： 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头： content-disposition:attachment;filename=xxx 将数据写出到response输出流 问题： 中文文件问题 解决思路： 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同 实现： java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;@WebServlet(\"/downloadServlet\")public class DownloadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取用户请求参数（文件名称） String fileName = request.getParameter(\"filename\"); // 获取 ServletContext 对象 ServletContext servletContext = request.getServletContext(); // 根据文件名称，找到服务器中文件的路径 String filePath = servletContext.getRealPath(\"/downloadFile/\" + fileName); // 根据文件名称，获取文件类型 String mimeType = servletContext.getMimeType(fileName); // 设置 response 的响应头 —————— 响应头类型：content-type response.setHeader(\"content-type\", mimeType); // 响应头的打开方式：content-disposition response.setHeader(\"content-disposition\", \"attachment;filename=\" + fileName); // 使用字节输入流加载文件进内存 FileInputStream fileInputStream = new FileInputStream(filePath); // 将字节输入流的数据写出到输出流中 ServletOutputStream responseOutputStream = response.getOutputStream(); byte[] bytes = new byte[1024 * 8]; int len = 0; while ((len = fileInputStream.read(bytes)) != -1) { responseOutputStream.write(bytes, 0, len); } fileInputStream.close(); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 虚拟路径：/ResponseDownload_war_exploded --&gt; &lt;!-- /downloadServlet 为Servlet的访问路径 --&gt; &lt;!-- 资源名称：image06.png、view.avi --&gt; &lt;a href=\"/ResponseDownload_war_exploded/downloadServlet?filename=image06.png\"&gt;下载图片&lt;/a&gt; &lt;a href=\"/ResponseDownload_war_exploded/downloadServlet?filename=view.avi\"&gt;下载视频&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器，浏览器中访问：http://localhost:8080/ResponseDownload_war_exploded/download.html 点击下载图片，会下载： image06.png 点击下载视频，会下载：view.avi ## 参考文献 ServletContext对象详解","link":"/p/141628202005/"},{"title":"Servlet学习笔记3","text":"@Author: YiHua Lee @Address: Guangdong province, China 在 Servlet 3.0 之前，我创建的每个Servlet的实现类，都需要配置 web.xml 文档，在 Servlet 3.0 以及后面的版本中，我们可以不用创建 web.xml ，通过注解的方式添加数据配置。 实例引入 创建JavaEE项目：ServletStudy 创建Servlet实现类： 123456789101112131415161718192021222324252627public class ServletDemo01 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Servlet 4.0 版本 ······\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { }} @WebServlet 属性列表 属性名 类型 描述 name String 指定Servlet 的 name 属性，等价于 &lt;servlet-name&gt; 如果没有显式指定，则该 Servlet 的取值即为类的全限定名 value String[] 该属性等价于 urlPatterns 属性。两个属性不能同时使用 urlPatterns String[] 指定一组 Servlet 的 URL 匹配模式。等价于 &lt;url-pattern&gt; 标签 loadOnStartup int 指定 Servlet 的加载顺序，等价于 &lt;load-on-startup&gt; 标签 initParams WebInitParam[] 指定一组 Servlet 初始化参数，等价于 &lt;init-param&gt; 标签 asyncSupported boolean 声明 Servlet 是否支持异步操作模式，等价于 &lt;async-supported&gt; 标签 description String Servlet 的描述信息，等价于 标签。 displayName String Servlet 的显示名，通常配合工具使用，等价于 &lt;display-name&gt; 标签 通过注解，配置数据： javax.servlet.annotation @WebServlet 1@WebServlet(urlPatterns=\"/demo01\") 启动服务器，访问 http://localhost:8080/ServletStudy_war_exploded/demo01 控制台输出： 1Servlet 4.0 版本 ······ 实例代码1234567891011121314151617181920212223242526272829303132333435363738394041package my.servlet.study;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/** * @Author: YiHua Lee * @Version: 1.8.0_201 Java SE 8 * @Application: IntelliJ IDEA * @CreateTime: 2020/5/15 16:21 * @Description: */@WebServlet(urlPatterns=\"/demo01\")public class ServletDemo01 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Servlet 4.0 版本 ······\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { }} 参考文献 Servlet 3.1 第一个应用 - 注解方式 Servlet3.0下@WebServlet注解配置Servlet","link":"/p/081716202005/"},{"title":"Servlet学习笔记4","text":"@Author: YiHua Lee @Address: Guangdong province, China 对于Servlet接口而言，实现该接口，都要覆盖重写该接口的所有抽象方法。GenericServlet 是 Servlet接口的实现类，它对Servlet的所有抽象方法都进行了覆盖重写（都做了默认的空实现），其中有一个方法是抽象方法，那就是提供服务的方法 service 方法。 GenericServlet 类的简单学习创建项目，直接继承GenericServlet类，并覆盖重写service方法： 123456789101112131415import javax.servlet.GenericServlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import java.io.IOException;@WebServlet(urlPatterns=\"/demo01\")public class ServletDemo01 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"覆盖重写GenericServlet抽象方法～～～\"); }} 启动服务器，访问 http://localhost:8080/HTTPServletAndGenericServlet_war_exploded/demo01 即可。 HttpServlet 类的简单学习HttpServlet 类是 GenericServlet 类的子类，该类对HTTP协议进行了简单的封装，用到Servlet，可以尽量选择该类。 快速入门： 创建一个类，继承HttpServlet类，覆盖重写doGet()方法、doPost()方法： 123456789101112131415161718192021import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/demo02\")public class ServletDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet() 方法！！！\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost() 方法！！！\"); }} 创建一个HTML文件，用于测试： HelloHttpServlet.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Servlet Demo02&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 路径指定为 demo02，请求方法为 post --&gt; &lt;form action=\"/HTTPServletAndGenericServlet_war_exploded/demo02\" method=\"post\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"post提交\"&gt; &lt;/form&gt; &lt;!-- 路径指定为 demo02，请求方法为 get --&gt; &lt;form action=\"/HTTPServletAndGenericServlet_war_exploded/demo02\" method=\"get\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"get提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器访问 访问 http://localhost:8080/HTTPServletAndGenericServlet_war_exploded/demo02 提交方式默认为 get 方式，控制台输出：“doGet() 方法！！！” 访问 http://localhost:8080/HTTPServletAndGenericServlet_war_exploded/HelloHttpServlet.html 效果如下： post提交，页面跳转到http://localhost:8080/HTTPServletAndGenericServlet_war_exploded/demo02，控制台输出：doPost() 方法！！！ get提交，页面跳转到http://localhost:8080/HTTPServletAndGenericServlet_war_exploded/demo02，控制台输出：doGet() 方法！！！ @WebServlet 的 urlpartten 参数说明 写法1：@WebServlet(&quot;/demo1&quot;) 该类的url路径为 /demo1 写法2：@WebServlet(&quot;/demo1&quot;, &quot;demo2&quot;, &quot;demo3&quot;, ... , &quot;demoN&quot;) 该类的url路径可是是：/demo1、/demo2、/demo3、 …… 、/demoN 写法3：@WebServlet(&quot;/*&quot;) 该类的url路径无论是什么都可以 参考文献 HttpServlet详解","link":"/p/492217202005/"},{"title":"Servlet学习笔记5","text":"@Author: YiHua Lee @Address: Guangdong province, China 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 特点： 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 请求消息数据格式 请求行请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1 请求方式： HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求头：客户端浏览器告诉服务器一些信息请求头名称: 请求头值 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost:8080/HTTPServletAndGenericServlet_war_exploded/HelloHttpServlet.html 告诉服务器，我(当前请求)从哪里来？ 作用： 防盗链： 统计工作： 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)： 封装POST请求消息的请求参数的","link":"/p/202317202005/"},{"title":"Spring JDBC 的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发。 使用步骤 导入架包：commons-logging-1.2.jar、spring-beans-5.0.0.RELEASE.jar、spring-core-5.0.0.RELEASE.jar、spring-jdbc-5.0.0.RELEASE.jar、spring-tx-5.0.0.RELEASE.jar 创建JdbcTemplate对象。 12JdbcTemplate template = new JdbcTemplate(new DataSource);// 创建JdbcTemplate对象，需要传入数据库连接池对象。 调用JdbcTemplate的方法，对数据库进行操作： 12update()// 执行insert into、delete、set语句（增、删、改） 1234queryForMap()// 查询结果将结果集封装为map集合，将列名作为key，将值作 value 将这条记录封装为一个map集合备注：这个方法查询的结果集长度只能是1 1234queryForList()// 查询结果将结果集封装为list集合备注：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 12query()// 查询结果，将结果封装为JavaBean对象 1234queryForObject()// 查询结果，将结果封装为对象备注：一般用于聚合函数的查询 实例1有如下一个数据库表格： 1234567CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(10), -- 名字 balance DOUBLE -- 余额);INSERT INTO account (NAME, balance) VALUES ('LeeHua', 1000), ('Tom', 1000), ('WanWu', 2000); 配置文件如下：druid-1.0.9.properties 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://MySQL地址/数据库名称username=登录mysql的用户名password=密码initialSize=初始化数据库连接池连接数量maxActive=最大数据库连接池连接数量maxWait=最大超时时间（/ms） Java代码操作数据库表：把id=3的用户的账户余额修改为5000 1234567891011121314151617181920212223242526272829303132333435363738394041package my.view.jdbctemplate;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.io.InputStream;import java.util.Properties;public class JdbcTemplateDemo01 { public static void main(String[] args) throws Exception { // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取类的类加载器 ClassLoader classLoader = JdbcTemplateDemo01.class.getClassLoader(); // 获取druid-1.0.9.properties配置文件资源输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid-1.0.9.properties\"); // 加载配置文件 properties.load(resourceAsStream); // 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); // 创建JdbcTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译SQL语句 String sql = \"UPDATE account SET balance = 5000 WHERE id = ?\"; // 调用JdbcTemplate对象的update()方法，给SQL语句的?赋值，并执行SQL语句。该方法返回值是一个int类型的数。 int update = jdbcTemplate.update(sql, 3); // 输出执行的SQL语句，影响表格中的行数。 System.out.println(update); }} 运行程序，控制台输出： 11 表中的数据如下： 案例2有如下一个表格：emp表格 需求 修改id = 1001数据的 salary 字段记录为 10000 添加一条记录 删除刚才添加的记录 查询id为1001的记录，将其封装为Map集合 查询所有记录，将其封装为List 查询所有记录，将其封装为Emp对象的List集合 查询总记录数 实现前，为了后续的实现方便：创建一个Emp类，封装Emp表数据的JavaBean。创建一个工具类，用来获取数据库连接池对象。 Emp.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package my.view.domain;import java.util.Date;public class Emp { /** 员工id */ private int id; /** 员工姓名 */ private String ename; /** 职务id */ private int job_id; /** 上级领导 */ private int mgr; /** 入职日期 */ private Date joindate; /** 工资 */ private double salary; /** 奖金 */ private double bonus; /** 所在部门编号 */ private int dept_id; public Emp() { } public Emp(int id, String ename, int job_id, int mgr, Date joindate, double salary, double bonus, int dept_id) { this.id = id; this.ename = ename; this.job_id = job_id; this.mgr = mgr; this.joindate = joindate; this.salary = salary; this.bonus = bonus; this.dept_id = dept_id; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public int getJob_id() { return job_id; } public void setJob_id(int job_id) { this.job_id = job_id; } public int getMgr() { return mgr; } public void setMgr(int mgr) { this.mgr = mgr; } public Date getJoindate() { return joindate; } public void setJoindate(Date joindate) { this.joindate = joindate; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } public int getDept_id() { return dept_id; } public void setDept_id(int dept_id) { this.dept_id = dept_id; } public double getBonus() { return bonus; } public void setBonus(double bonus) { this.bonus = bonus; } @Override public String toString() { return \"Emp{\" + \"id=\" + id + \", ename='\" + ename + '\\'' + \", job_id=\" + job_id + \", mgr=\" + mgr + \", joindate=\" + joindate + \", salary=\" + salary + \", bonus=\" + bonus + \", dept_id=\" + dept_id + '}'; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package my.view.utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Properties;public class JdbcUtils { /** * 数据库连接对象 */ private static DataSource dataSource; /* 获取数据库连接池对象 */ static { try { // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取类的类加载器 ClassLoader classLoader = JdbcUtils.class.getClassLoader(); // 获取druid-1.0.9.properties配置文件资源输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid-1.0.9.properties\"); // 加载配置文件 properties.load(resourceAsStream); // 获取连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource() { return dataSource; } /** * 获取数据库连接对象 */ public static Connection getConnection() throws Exception { return dataSource.getConnection(); } /** * 归还连接 或 释放资源 * @param t 要被归还到熟即可连接池对象的数据库连接对象 或 要被释放的资源 * @param &lt;T&gt; 数据库连接对象的类型 或 要被释放的资源对象的类型 */ public static &lt;T&gt; void releaseResources (T t){ if(t != null){ try { // 利用反射，获取class对象 Class&lt;?&gt; aClass = t.getClass(); // 获取class对象中的方法对象 Method close = aClass.getMethod(\"close\"); // 执行方法 close.invoke(t); } catch (Exception e) { e.printStackTrace(); } } }} 需求1的实现1234567891011121314151617181920212223242526272829303132package my.view.jdbctemplate;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;public class JdbcTemplateDemoTest { /** * 修改id = 1001数据的 salary 字段记录为 10000 */ @Test public void updateSetTest01() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"UPDATE emp SET salary = ? WHERE id = ?\"; // 执行SQL语句 int update = jdbcTemplate.update(sql, 10000, 1001); // 输出执行SQL语句后的返回值 System.out.println(update); }} 需求2的实现1234567891011121314151617181920212223242526272829303132package my.view.jdbctemplate;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;public class JdbcTemplateDemoTest { /** * 添加一条数据 */ @Test public void updateInsertTest01() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"INSERT INTO emp (id, ename, salary) VALUE (?, ?, ?)\"; // 执行SQL语句 int insert = jdbcTemplate.update(sql, 1015, \"LeeHua\", 8000); // 输出执行SQL语句后的返回值 System.out.println(insert); }} 需求3的实现1234567891011121314151617181920212223242526272829303132package my.view.jdbctemplate;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;public class JdbcTemplateDemoTest { /** * 删除刚才添加的记录 */ @Test public void updateDeleteTest03() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"DELETE FROM emp WHERE id = ?\"; // 执行SQL语句 int delete = jdbcTemplate.update(sql, 1015); // 输出执行SQL语句后的返回值 System.out.println(delete); }} 需求4的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546package my.view.jdbctemplate;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.util.Iterator;import java.util.Map;import java.util.Set;public class JdbcTemplateDemoTest { /** * 查询id为1001的记录，将其封装为Map集合 */ @Test public void queryForMapTest01() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp WHERE id = ?;\"; // 执行SQL语句 Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(sql, 1001); // 获取Key值，即列名称 Set&lt;String&gt; stringKey = stringObjectMap.keySet(); // 获取Set集合的迭代器对象，并遍历该迭代器对象 Iterator&lt;String&gt; ite = stringKey.iterator(); while (ite.hasNext()) { // 通过迭代器对象中的每一个值(Map集合中的键)，获取key-value String key = ite.next(); System.out.println( \"Key：\" + key + \" Value：\" + stringObjectMap.get(key) ); } } } 进行测试，控制台输出： 12345678Key：id Value：1001Key：ename Value：Sun WukongKey：job_id Value：4Key：mgr Value：1004Key：joindate Value：2000-12-17Key：salary Value：10000.00Key：bonus Value：nullKey：dept_id Value：20 需求5的实现123456789101112131415161718192021222324252627282930313233package my.view.jdbctemplate;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.util.List;import java.util.Map;public class JdbcTemplateDemoTest { /** * 查询所有记录，将其封装为List */ @Test public void queryForListTest01() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp;\"; // 执行SQL语句 List&lt;Map&lt;String, Object&gt;&gt; stringObjectList = jdbcTemplate.queryForList(sql); // 输出查询结果 stringObjectList.forEach(System.out::println); }} 进行测试，控制台输出： 1234567891011121314{id=1001, ename=Sun Wukong, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}{id=1002, ename=Lu Junyi, job_id=3, mgr=1006, joindate=2001-02-20, salary=16000.00, bonus=3000.00, dept_id=30}{id=1003, ename=Lin Chong, job_id=3, mgr=1006, joindate=2001-02-22, salary=12500.00, bonus=5000.00, dept_id=30}{id=1004, ename=Tang Monk, job_id=2, mgr=1009, joindate=2001-04-02, salary=29750.00, bonus=null, dept_id=20}{id=1005, ename=Li Yan, job_id=4, mgr=1006, joindate=2001-09-28, salary=12500.00, bonus=14000.00, dept_id=30}{id=1006, ename=Song Jiang, job_id=2, mgr=1009, joindate=2001-05-01, salary=28500.00, bonus=null, dept_id=30}{id=1007, ename=Liu Bei, job_id=2, mgr=1009, joindate=2001-09-01, salary=24500.00, bonus=null, dept_id=10}{id=1008, ename=Zhu Bajie, job_id=4, mgr=1004, joindate=2007-04-19, salary=30000.00, bonus=null, dept_id=20}{id=1009, ename=Luo Guanzhong, job_id=1, mgr=null, joindate=2001-11-17, salary=50000.00, bonus=null, dept_id=10}{id=1010, ename=Wu Yong, job_id=3, mgr=1006, joindate=2001-09-08, salary=15000.00, bonus=0.00, dept_id=30}{id=1011, ename=sand monk, job_id=4, mgr=1004, joindate=2007-05-23, salary=11000.00, bonus=null, dept_id=20}{id=1012, ename=Li Yan, job_id=4, mgr=1006, joindate=2001-12-03, salary=9500.00, bonus=null, dept_id=30}{id=1013, ename=Little White Dragon, job_id=4, mgr=1004, joindate=2001-12-03, salary=30000.00, bonus=null, dept_id=20}{id=1014, ename=Guan Yu, job_id=4, mgr=1007, joindate=2002-01-23, salary=13000.00, bonus=null, dept_id=10} 需求6的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package my.view.jdbctemplate;import my.view.domain.Emp;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import javax.sql.DataSource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;public class JdbcTemplateDemoTest { /** * 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void queryTest06() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp;\"; // 执行SQL语句，将其封装为Emp对象的List集合 List&lt;Emp&gt; empList = jdbcTemplate.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet resultSet, int i) throws SQLException { return new Emp( // 员工ID resultSet.getInt(\"id\"), // 员工姓名 resultSet.getString(\"ename\"), // 职务ID resultSet.getInt(\"job_id\"), // 上级领导 resultSet.getInt(\"mgr\"), // 入职日期 resultSet.getDate(\"joindate\"), // 工资 resultSet.getDouble(\"salary\"), // 奖金 resultSet.getDouble(\"bonus\"), // 所在部门编号 resultSet.getInt(\"dept_id\") ); } }); empList.forEach(System.out::println); }} query()方法，参数说明： 1234567query(String sql, RowMapper&lt;T&gt; rowMapper)参数：// String sql：SQL语句// rowMapper：一般我们使用BeanPropertyRowMapper实现类。可以完成数据到// JavaBean的自动封装，也可以覆盖重写RowMapper&lt;T&gt;函数式接口// 的方法。 运行测试，控制台输出： 1234567891011121314Emp{id=1001, ename='Sun Wukong', job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.0, bonus=0.0, dept_id=20}Emp{id=1002, ename='Lu Junyi', job_id=3, mgr=1006, joindate=2001-02-20, salary=16000.0, bonus=3000.0, dept_id=30}Emp{id=1003, ename='Lin Chong', job_id=3, mgr=1006, joindate=2001-02-22, salary=12500.0, bonus=5000.0, dept_id=30}Emp{id=1004, ename='Tang Monk', job_id=2, mgr=1009, joindate=2001-04-02, salary=29750.0, bonus=0.0, dept_id=20}Emp{id=1005, ename='Li Yan', job_id=4, mgr=1006, joindate=2001-09-28, salary=12500.0, bonus=14000.0, dept_id=30}Emp{id=1006, ename='Song Jiang', job_id=2, mgr=1009, joindate=2001-05-01, salary=28500.0, bonus=0.0, dept_id=30}Emp{id=1007, ename='Liu Bei', job_id=2, mgr=1009, joindate=2001-09-01, salary=24500.0, bonus=0.0, dept_id=10}Emp{id=1008, ename='Zhu Bajie', job_id=4, mgr=1004, joindate=2007-04-19, salary=30000.0, bonus=0.0, dept_id=20}Emp{id=1009, ename='Luo Guanzhong', job_id=1, mgr=0, joindate=2001-11-17, salary=50000.0, bonus=0.0, dept_id=10}Emp{id=1010, ename='Wu Yong', job_id=3, mgr=1006, joindate=2001-09-08, salary=15000.0, bonus=0.0, dept_id=30}Emp{id=1011, ename='sand monk', job_id=4, mgr=1004, joindate=2007-05-23, salary=11000.0, bonus=0.0, dept_id=20}Emp{id=1012, ename='Li Yan', job_id=4, mgr=1006, joindate=2001-12-03, salary=9500.0, bonus=0.0, dept_id=30}Emp{id=1013, ename='Little White Dragon', job_id=4, mgr=1004, joindate=2001-12-03, salary=30000.0, bonus=0.0, dept_id=20}Emp{id=1014, ename='Guan Yu', job_id=4, mgr=1007, joindate=2002-01-23, salary=13000.0, bonus=0.0, dept_id=10} 需求7的实现123456789101112131415161718192021222324252627282930313233343536373839package my.view.jdbctemplate;import my.view.domain.Emp;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import javax.sql.DataSource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;public class JdbcTemplateDemoTest { /** * 查询总记录数 */ @Test public void queryTest08() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT COUNT(*) FROM emp;\"; // 执行SQL语句，查询的结果是一个Long类型的数，该方法传入Long类作为参数 Long aLong = jdbcTemplate.queryForObject(sql, Long.class); // 输出查询结果 System.out.println(aLong); }} 运行测试，控制台输出： 114 1-7需求所有代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249package my.view.jdbctemplate;import my.view.domain.Emp;import my.view.utils.JdbcUtils;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import javax.sql.DataSource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;/** * @Author: YiHua Lee * @Version: 1.8.0_201 Java SE 8 * @Application: IntelliJ IDEA * @CreateTime: 2020/2/19 20:42 * @Description: */public class JdbcTemplateDemoTest { /** * 修改id = 1001数据的 salary 字段记录为 10000 */ @Test public void updateSetTest01() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"UPDATE emp SET salary = ? WHERE id = ?\"; // 执行SQL语句 int update = jdbcTemplate.update(sql, 10000, 1001); // 输出执行SQL语句后的返回值 System.out.println(update); } /** * 添加一条数据 */ @Test public void updateInsertTest02() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"INSERT INTO emp (id, ename, salary) VALUE (?, ?, ?)\"; // 执行SQL语句 int insert = jdbcTemplate.update(sql, 1015, \"LeeHua\", 8000); // 输出执行SQL语句后的返回值 System.out.println(insert); } /** * 删除刚才添加的记录 */ @Test public void updateDeleteTest03() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"DELETE FROM emp WHERE id = ?\"; // 执行SQL语句 int delete = jdbcTemplate.update(sql, 1015); // 输出执行SQL语句后的返回值 System.out.println(delete); } /** * 查询id为1001的记录，将其封装为Map集合 */ @Test public void queryForMapTest04() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp WHERE id = ?;\"; // 执行SQL语句 Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(sql, 1001); // 获取Key值，即列名称 Set&lt;String&gt; stringKey = stringObjectMap.keySet(); // 获取Set集合的迭代器对象，并遍历该迭代器对象 Iterator&lt;String&gt; ite = stringKey.iterator(); while (ite.hasNext()) { // 通过迭代器对象中的每一个值(Map集合中的键)，获取key-value String key = ite.next(); System.out.println( \"Key：\" + key + \" Value：\" + stringObjectMap.get(key) ); } } /** * 查询所有记录，将其封装为List */ @Test public void queryForListTest05() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp;\"; // 执行SQL语句 List&lt;Map&lt;String, Object&gt;&gt; stringObjectList = jdbcTemplate.queryForList(sql); // 输出查询结果 stringObjectList.forEach(System.out::println); } /** * 1、查询所有记录，将其封装为Emp对象的List集合 */ @Test public void queryTest06() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp;\"; // 执行SQL语句，将其封装为Emp对象的List集合 List&lt;Emp&gt; empList = jdbcTemplate.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet resultSet, int i) throws SQLException { return new Emp( // 员工ID resultSet.getInt(\"id\"), // 员工姓名 resultSet.getString(\"ename\"), // 职务ID resultSet.getInt(\"job_id\"), // 上级领导 resultSet.getInt(\"mgr\"), // 入职日期 resultSet.getDate(\"joindate\"), // 工资 resultSet.getDouble(\"salary\"), // 奖金 resultSet.getDouble(\"bonus\"), // 所在部门编号 resultSet.getInt(\"dept_id\") ); } });// List&lt;Emp&gt; empList1 = jdbcTemplate.query(sql, (ResultSet resultSet, int i) -&gt; new Emp(// // 员工ID// resultSet.getInt(\"id\"),// // 员工姓名// resultSet.getString(\"ename\"),// // 职务ID// resultSet.getInt(\"job_id\"),// // 上级领导// resultSet.getInt(\"mgr\"),// // 入职日期// resultSet.getDate(\"joindate\"),// // 工资// resultSet.getDouble(\"salary\"),// // 奖金// resultSet.getDouble(\"bonus\"),// // 所在部门编号// resultSet.getInt(\"dept_id\")// )); // 输出查询结果 empList.forEach(System.out::println); } /** * 2、查询所有记录，将其封装为Emp对象的List集合 * BeanPropertyRowMapper&lt;&gt;() 类，实现了RowMapper&lt;&gt;()接口 * * 使用BeanPropertyRowMapper&lt;&gt;() 类，将每一行数据存储到BeanPropertyRowMapper对象中， * 传入的类，用来存储数据的数据类型，必须都是包装类数据，如String、Integer */ @Test public void queryTest07() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT * FROM emp;\"; // 执行SQL语句，将其封装为Emp对象的List集合 List&lt;Emp&gt; empList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); // 输出查询结果 empList.forEach(System.out::println); } /** * 查询总记录数 */ @Test public void queryTest08() { // 调用自己定义的工具类JdbcUtils，获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 获取JDBCTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 定义预编译的SQL语句 String sql = \"SELECT COUNT(*) FROM emp;\"; // 执行SQL语句，查询的结果是一个Long类型的数，该方法传入Long类作为参数 Long aLong = jdbcTemplate.queryForObject(sql, Long.class); // 输出查询结果 System.out.println(aLong); }}","link":"/p/291506202005/"},{"title":"Splash的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China Splash Lua脚本http://localhost:8050，端口为8050 入口及返回值123456function main(splash, args) splash:go(\"http://www.baidu.com\") splash:wait(0.5) local title = splash:evaljs(\"document.title\") return {title=title}end 1通过 evaljs()方法传人 JavaSer刷脚本， 而 document.title 的执行结果就是返回网页标题，执行完毕后将其赋值给一个 title 变盘，随后将其 返回 。 异步处理按照不同步的程序处理问题 12345678910111213function main(splash, args) local example_urls = {\"www.baidu.com\", \"www.taobao.com\", \"www.zhihu.com\"} local urls = args.urls or example_urls local results = {} for index, url in ipairs(urls) do local ok, reason = splash:go(\"http://\" .. url) if ok then splash:wait(2) results[url] = splash:png() end end return resultsend 123wait(2) 等待2秒字符串拼接符使用的是..操作符go()方法 返回加载页面的结果状态 1运行结果：（如果页面州现 4xx 或5xx状态码， ok变量就为空，就不会返回加载后的图片。） Splash对象属性args属性获取加载时配置的参数 运行： 输出： js_enableb属性js_enabled属性是Splash的JavaScript执行开关可以将其配置为true或false来控制是否执行JavaScript代码，默认为true。 123456function main(splash, args) splash:go(\"https://www.baidu.com\") splash.js_enabled = false local title = splash:evaljs(\"document.title\") return {title=title}end 12go()方法，加载页面js_enabled = false，禁止执行JavaScript代码 运行情况： 1234567891011121314151617181920212223HTTP Error 400 (Bad Request)Type: ScriptError -&gt; JS_ERRORError happened while executing Lua script[string &quot;function main(splash, args)...&quot;]:4: unknown JS error: None{ &quot;type&quot;: &quot;ScriptError&quot;, &quot;info&quot;: { &quot;splash_method&quot;: &quot;evaljs&quot;, &quot;line_number&quot;: 4, &quot;js_error_message&quot;: null, &quot;type&quot;: &quot;JS_ERROR&quot;, &quot;error&quot;: &quot;unknown JS error: None&quot;, &quot;message&quot;: &quot;[string \\&quot;function main(splash, args)\\r...\\&quot;]:4: unknown JS error: None&quot;, &quot;source&quot;: &quot;[string \\&quot;function main(splash, args)\\r...\\&quot;]&quot; }, &quot;description&quot;: &quot;Error happened while executing Lua script&quot;, &quot;error&quot;: 400} resource_timeout属性resource_timeout属性设置加载的超时时间，单位是秒。 12345function main(splash) splash.resource_timeout = 0.1 assert(splash:go('https://www.taobao.com')) return splash:png()end 12png()方法，返回页面截图resource_timeout = 0.1 表示设置的加载超时时间为0.1s images_enabled属性images_enabled属性设置图片是否加载，默认情况下是加载的。不加载图片，加载的速度会快很多。 12345function main(splash, args) splash.images_enabled = false assert(splash:go('https://www.jd.com')) return {png=splash:png()}end 运行后请求加载的网页不加载图片 plugins_enabled属性plugins_enabled属性可以控制浏览器插件（如Flash插件）是否开启。默认情况下，此属性是false，表示不开启。 1splash.plugins_enabled = true/false scoll_position属性scroll_position属性可以控制页面上下或左右滚动 12345function main(splash, args) assert(splash:go('https://www.taobao.com')) splash.scroll_position = {y=400} return {png=splash:png()} end 1# 向下滚动400像素 Splash对象的方法go()方法：请求某个链接 go 方法参数 1234567ok, reason = splash:go{url, baseurl=nil, headers=nil, http_method=&quot;GET&quot;, body=nil, formdata=nil}baseurl----资源加载的相对路径headers----请求头http_method----请求方法，GET或POSTbody----发POST请求时的表单数据，使用的Content-type为application/json。formdata----POST请求时的表单数据，，使用的Content-type为application/x-www-form-urlencoded。 go 方法实例 123456function main(splash, args) local ok, reason = splash:go{\"http://httpbin.org/post\", http_method=\"POST\", body=\"name=Germey\"} if ok then return splash:html() endend 输出结果： 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;pre style=\"word-wrap: break-word; white-space: pre-wrap;\"&gt;{ \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"name\": \"Germey\" }, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"en,*\", \"Content-Length\": \"11\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"Origin\": \"null\", \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/602.1 (KHTML, like Gecko) splash Version/9.0 Safari/602.1\" }, \"json\": null, \"origin\": \"120.239.195.171, 120.239.195.171\", \"url\": \"https://httpbin.org/post\"}&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; wait()方法：控制页面的等待时间 wait 方法参数 123456ok, reason = splash:wait{time, cancel_on_redirect=false, cancel_on_error=true}time----等待时间/scancel_on_redirect----如果发生重定向就停止等待，并返回重定向结果cancel_on_error----如果发生了加载错我，就停止等待 wait 方法实例 12345function main(splash) splash:go(\"https://www.taobao.com\") splash:wait(2) return {html=splash:html()}end jsfunc()方法jsfunc()方法，直接调用JavaScript定义的方法，即实现JavaScript方法到Lua脚本的转换。 123456789101112function main(splash, args) local get_div_count = splash:jsfunc([[ function () { var body = document.body; var divs = body.getElementsByTagName('div'); return divs.length; } ]]) splash:go(\"https://www.baidu.com\") return (\"There are %s DIVs\"):format( get_div_count())end 12运行结果：&quot;There are 22 DIVs&quot; evaljs()方法执行JavaScript代码，并返回最后一条JavaScript语句的返回结果 1result = splash:evalijs(js) runjs()方法runjs()方法于evaljs()方法功能类似 123456function main(splash, args) splash:go(\"https://www.baidu.com\") splash:runjs(\"foo = function() { return 'bar' }\") local result = splash:evaljs(\"foo()\") return resultend 12输出：&quot;bar&quot; autoload()方法：sutoload()设置每个页面访问时自动加载的对象 autoload()方法参数 12345ok, reason = splash:autoload{source_or_url, source=nil, url=nil}source_or_url----JavaScript代码或者JavaScript库链接。source----JavaScript代码。url----JavaScript库链接。 autoload()方法例子 123456789function main(splash, args) splash:autoload([[ function get_document_title(){ return document.title; } ]]) splash:go(\"https://www.baidu.com\") return splash:evaljs(\"get_document_title()\")end 12结果Splash Response: &quot;百度一下，你就知道&quot; call_later()方法通过设置定时任务和延迟时间来实现任务延时执行，并且可以再执行前通过cancel()方法重新执行定时任务。 1234567891011function main(splash, args) local snapshots = {} local timer = splash:call_later(function() snapshots[\"a\"] = splash:png() splash:wait(1.0) snapshots[\"b\"] = splash:png() end, 0.2) splash:go(\"https://www.taobao.com\") splash:wait(3.0) return snapshotsend http_get()方法模拟发送HTTP的GET请求 http_get()方法参数 12345response = splash:http_get{url, headers=nil, follow_redirects=true}url----请求URL。headers----可选参数，默认为空，请求头。follow_redirects----可选参数，表示是否启动自动重定向，默认为true。 http_get()方法例子 123456789function main(splash, args) local treat = require(\"treat\") local response = splash:http_get(\"http://httpbin.org/get\") return { html=treat.as_string(response.body), url=response.url, status=response.status }end 123456789101112131415输出结果：html: String (length 347){ &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;en,*&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/602.1 (KHTML, like Gecko) splash Version/9.0 Safari/602.1&quot; }, &quot;origin&quot;: &quot;120.239.195.171, 120.239.195.171&quot;, &quot;url&quot;: &quot;https://httpbin.org/get&quot;}status: 200url: &quot;http://httpbin.org/get&quot; http_post()方法模拟发送HTTP的POST请求 http_post()方法参数 123456response = splash:http_post{url, headers=nil, follow_redirects=true, body=nil}url----请求URL。headers----可选参数，默认为空，请求头。follow_redirects----可选参数，表示是否启动自动重定向，默认为true。body----可选参数，即表单数据，默认为空。 http_post()方法例子 12345678910111213function main(splash, args) local treat = require(\"treat\") local json = require(\"json\") local response = splash:http_post{\"http://httpbin.org/post\", body=json.encode({name=\"Germey\"}), headers={[\"content-type\"]=\"application/json\"} } return { html=treat.as_string(response.body), url=response.url, status=response.status }end set_content()方法：设置页面的内容1234function main(splash) assert(splash:set_content(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\")) return splash:png()end html()方法：获取网页源代码获取https://httpbin.org/get的源代码 1234function main(splash, args) splash:go(\"https://httpbin.org/get\") return splash:html()end png()方法：获取png格式的网页截图1234function main(splash, args) splash:go(\"https://www.taobao.com\") return splash:png()end jpeg()方法：获取jpng格式的网页截图1234function main(splash, args) splash:go(\"https://www.taobao.com\") return splash:jpeg()end har()方法：获取页面的加载过程1234function main(splash, args) splash:go(\"https://www.baidu.com\") return splash:har()end url()方法：获取当前页面正在访问的URL1234function main(splash, args) splash:go(\"https://www.baidu.com\") return splash:url()end 12// 输出：https://www.baidu.com/ get_cookies()方法：获取当前页面的Cookies1234function main(splash, args) splash:go(\"https://www.baidu.com\") return splash:get_cookies()end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 输出：0: Objectdomain: &quot;.baidu.com&quot;expires: &quot;2087-08-08T12:53:28Z&quot;httpOnly: falsename: &quot;BAIDUID&quot;path: &quot;/&quot;secure: falsevalue: &quot;B556658F0EAB497638556503063F6AEE:FG=1&quot;1: Objectdomain: &quot;.baidu.com&quot;expires: &quot;2087-08-08T12:53:28Z&quot;httpOnly: falsename: &quot;BIDUPSID&quot;path: &quot;/&quot;secure: falsevalue: &quot;B556658F0EAB497638556503063F6AEE&quot;2: Objectdomain: &quot;.baidu.com&quot;expires: &quot;2087-08-08T12:53:28Z&quot;httpOnly: falsename: &quot;PSTM&quot;path: &quot;/&quot;secure: falsevalue: &quot;1563701961&quot;3: Objectdomain: &quot;.baidu.com&quot;httpOnly: falsename: &quot;delPer&quot;path: &quot;/&quot;secure: falsevalue: &quot;0&quot;4: Objectdomain: &quot;www.baidu.com&quot;httpOnly: falsename: &quot;BD_HOME&quot;path: &quot;/&quot;secure: falsevalue: &quot;0&quot;5: Objectdomain: &quot;.baidu.com&quot;httpOnly: falsename: &quot;H_PS_PSSID&quot;path: &quot;/&quot;secure: falsevalue: &quot;29547_1434_21089_18560_29522_29518_28518_29099_28833_29220_26350_29459&quot;6: Objectdomain: &quot;www.baidu.com&quot;expires: &quot;2019-07-31T09:39:21Z&quot;httpOnly: falsename: &quot;BD_UPN&quot;path: &quot;/&quot;secure: falsevalue: &quot;143354&quot; add_cookie()方法：为当前页面添加Cookie add_cookie()方法参数 1cookies = splash:add_cookie{name, value, path=nil, domain=nil, expires=nil, httpOnly=nil, secure=nil} add_cookie()方法例子 12345function main(splash) splash:add_cookie{\"sessionid\", \"237465ghgfsd\", \"/\", domain=\"http://example.com\"} splash:go(\"http://example.com/\") return splash:html()end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 输出：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example Domain&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style type=\"text/css\"&gt; body { background-color: #f0f0f2; margin: 0; padding: 0; font-family: \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif; } div { width: 600px; margin: 5em auto; padding: 50px; background-color: #fff; border-radius: 1em; } a:link, a:visited { color: #38488f; text-decoration: none; } @media (max-width: 700px) { body { background-color: #fff; } div { width: auto; margin: 0 auto; border-radius: 0; padding: 1em; } } &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;h1&gt;Example Domain&lt;/h1&gt; &lt;p&gt;This domain is established to be used for illustrative examples in documents. You may use this domain in examples without prior coordination or asking for permission.&lt;/p&gt; &lt;p&gt;&lt;a href=\"http://www.iana.org/domains/example\"&gt;More information...&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; clear_cookies()方法：清除所有Cookies12345function main(splash) splash:go(\"https://www.baidu.com/\") splash:clear_cookies() return splash:get_cookies()end 12// 输出：Array[0] get_viewport_size()方法：获取页面的宽高1234function main(splash) splash:go(\"https://www.baidu.com/\") return splash:get_viewport_size()end set_viewport_size()方法：设置页面的宽高 set_viewport_size()参数 1splash:set_viewport_size(width, height) set_viewport_size()方法例子 12345function main(splash) splash:set_viewport_size(400, 700) assert(splash:go(\"http://cuiqingcai.com\")) return splash:png()end set_viewport_full()方法：浏览器全频显示12345function main(splash) splash:set_viewport_full() assert(splash:go(\"http://cuiqingcai.com\")) return splash:png()end set_user_agent()方法：设置浏览器的User_agent12345function main(splash) splash:set_user_agent('Splash') splash:go(\"http://httpbin.org/get\") return splash:html()end 1// 这里我们将浏览器的User-Agent设置为Splash set_custom_headers()方法：设置请求头12345678function main(splash) splash:set_custom_headers({ [\"User-Agent\"] = \"Splash\", [\"Site\"] = \"Splash\", }) splash:go(\"http://httpbin.org/get\") return splash:html()end 123456789101112131415// 输出：&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;pre style=\"word-wrap: break-word; white-space: pre-wrap;\"&gt;{ \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"en,*\", \"Host\": \"httpbin.org\", \"Site\": \"Splash\", \"User-Agent\": \"Splash\" }, \"origin\": \"120.239.195.171, 120.239.195.171\", \"url\": \"https://httpbin.org/get\"}&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; select()方法：选中符合条件的第一个节点—-参数为CSS选择器1234567function main(splash) splash:go(\"https://www.baidu.com/\") input = splash:select(\"#kw\") input:send_text('Splash') splash:wait(3) return splash:png()end 1// 首先访问了百度，然后选中了搜索框，随后调用了send_text()方法填写了文本，然后返回网页截图。 select_all()方法选中符合条件的所有节点（参数为CSS选择器） 1234567891011function main(splash) local treat = require('treat') assert(splash:go(\"http://quotes.toscrape.com/\")) assert(splash:wait(0.5)) local texts = splash:select_all('.quote .text') local results = {} for index, text in ipairs(texts) do results[index] = text.node.innerHTML end return treat.as_array(results)end 123456789101112// 输出：Array[10]0: &quot;“The world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.”&quot;1: &quot;“It is our choices, Harry, that show what we truly are, far more than our abilities.”&quot;2: “There are only two ways to live your life. One is as though nothing is a miracle. The other is as though everything is a miracle.”3: &quot;“The person, be it gentleman or lady, who has not pleasure in a good novel, must be intolerably stupid.”&quot;4: &quot;“Imperfection is beauty, madness is genius and it's better to be absolutely ridiculous than absolutely boring.”&quot;5: &quot;“Try not to become a man of success. Rather become a man of value.”&quot;6: &quot;“It is better to be hated for what you are than to be loved for what you are not.”&quot;7: &quot;“I have not failed. I've just found 10,000 ways that won't work.”&quot;8: &quot;“A woman is like a tea bag; you never know how strong it is until it's in hot water.”&quot;9: &quot;“A day without sunshine is like, you know, night.”&quot; mouse_click()方法模拟鼠标点击操作，传入的参数为坐标值x和y。此外，也可以直接选中某个节点，然后调用此方法 123456789function main(splash) splash:go(\"https://www.baidu.com/\") input = splash:select(\"#kw\") input:send_text('Splash') submit = splash:select('#su') submit:mouse_click() splash:wait(3) return splash:png()end 1首先选中页面的输入框，输入了文本，然后选中“提交”按钮，调用了mouse_click()方法提交查询，然后页面等待三秒，返回截图。","link":"/p/191630202004/"},{"title":"Session 对象学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China session对象 在web开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象（默认情况下）。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 session和cookie的主要区别在于：cookie是把用户的数据写给用户的浏览器(保存在客户机)；session技术把用户的数据写到用户独占的session中（保存在服务器）。 session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。 session实现原理 浏览器A第一次访问Servlet1，服务器会创建一个session，每个session都有一个id号，创建好了后，服务器将id号以cookie的形式回送给客户机（这些是服务器自动完成的）。 当浏览器未关闭前再次发请求访问Servlet2时，就会带着这个id号去访问服务器，这时候服务器检索下内存中有没有与之对应的session，有就用这个session为其服务。 如果想要关掉浏览器再打开还可以使用同一个session，则需要给服务器回送的cookie设置有效时间（服务器自动回送的时候是没有有效期的）。具体做法是通过session对象的getId方法获得该session的id,然后创建一个cookie，该cookie的名字为”JSESSIONID”，值就是刚刚获得的id，再将该cookie设置下有效期，（也可以设置下Path），并添加到cookie中即可。但是有效期不得超过30分钟，因为浏览器关掉后，session只保存30分钟。 案例1要求：通过三个servlet来实现简单的购物功能。 创建一个保存书籍信息的类，以及数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Book { private String id; private String name; private String author; private String description; public Book() { } public Book(String id, String name, String author, String description) { this.id = id; this.name = name; this.author = author; this.description = description; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; }} 123456789101112131415161718public class Dao { private static Map&lt;String, Book&gt; map = new LinkedHashMap(); // 静态代码块中的内容只执行一次,该类在加载时，往map集合中put一系列书,map也需要设置为静态的 static { map.put(\"1\", new Book(\"1\", \"JavaWeb开发\", \"老张\", \"一本好书\")); map.put(\"2\", new Book(\"2\", \"Spring开发\", \"老倪\", \"一本好书\")); map.put(\"3\", new Book(\"3\", \"Hibernate开发\", \"老童\", \"一本好书\")); map.put(\"4\", new Book(\"4\", \"Struts开发\", \"老毕\", \"一本好书\")); map.put(\"5\", new Book(\"5\", \"Ajax开发\", \"老张\", \"一本好书\")); map.put(\"6\", new Book(\"6\", \"Java基础\", \"老孙\", \"一本好书\")); } public static Map getAll() { return map; }} IndexServlet显示首页，并列出所有书 12345678910111213141516171819202122232425262728293031323334@WebServlet(\"/indexServlet\")public class IndexServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=UTF-8\"); // 定义 response.getWriter() 对象 PrintWriter out = response.getWriter(); out.write(\"本网站有如下书：&lt;br/&gt;\"); // 获取每一本书对应的键值 Set&lt;Map.Entry&lt;String,Book&gt;&gt; keySet = Dao.getAll().keySet(); for (Map.Entry&lt;String, Book&gt; stringBookEntry : keySet) { Book book = stringBookEntry.getValue(); // 定义标签体内容，指定购买的书：用户点击购买，指定给BuyServlet类去处理 out.write( book.getName() + \"&lt;a href='/SessionTest_war_exploded/buyServlet?id=\" + book.getId() + \"'&gt;购买&lt;/a&gt;&lt;br/&gt;\" ); System.out.println(book.getName() + \":\" + book.getId()); } } @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 当用户点击购买时，将书的id号带上，并跳转到BuyServlet去处理 123456789101112131415161718192021222324252627282930313233343536@WebServlet(\"/buyServlet\")public class BuyServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获得url中带过来的参数id String id = request.getParameter(\"id\"); // 在Dao中获得该id号的book Book book = (Book)Dao.getAll().get(id); // 获得当前session对象 HttpSession session = request.getSession(); // 设置新的cookie，注意cookie名必须为JSESSIONID,值为该session的id Cookie cookie = new Cookie(\"JSESSIONID\", session.getId()); // 设置cookie的有效期 cookie.setMaxAge(30 * 60); // 设置cookie的路径 cookie.setPath(\"/SessionTest_war_exploded\"); // 将cookie添加到cookies中带给浏览器，下次浏览器访问，就会将此cookie带过来了 response.addCookie(cookie); // 先把书加到容器里，再把容器加到session中。一般先检查用户的session中有没有保存书的容器，没有就创建，有就加 List list = (List)session.getAttribute(\"list\"); if(list == null) { list = new ArrayList(); session.setAttribute(\"list\", list); } list.add(book); // 跳转到显示用户买过哪些商品 response.sendRedirect(\"/SessionTest_war_exploded/listCartServlet\"); } @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 从上面的程序可以看出，当用户点击购买后，会将书的id号带过来，我们拿到id号后就可以找到相应的书，同时我们将当前session的id保存到cookie中，再带给浏览器，这样下次浏览器访问的时候就会将当前session的id带过来了。拿到相应的书后，放到list中，再把list放到session中，这样下次跳转的时候，浏览器带来的cookie中有当前session的id，我们可以通过getSession()获得当前的session，再把session中保存的list拿出来，就知道用户买了哪些书了。这就是购物车的原理。 123456789101112131415161718192021222324252627282930@WebServlet(\"/listCartServlet\")public class ListCartServlet extends HttpServlet { @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=UTF-8\"); // 定义 response.getWriter() 对象 PrintWriter out = response.getWriter(); // 获得当前的session HttpSession session = request.getSession(); // 从session中拿出list List&lt;Book&gt; list = (List)session.getAttribute(\"list\"); // 判断用户是否购买过书籍 if(list == null || list.size() == 0) { out.write(\"对不起，您还没有购买任何商品！\"); return; } out.write(\"您买过如下商品：&lt;br/&gt;\"); for(Book book : list) { out.write(book.getName() + \"&lt;br/&gt;\"); } } @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 启动服务器，浏览器访问：http://localhost:8080/SessionTest_war_exploded/indexServlet 没有购买过书籍，访问：http://localhost:8080/SessionTest_war_exploded/buyServlet 点击购买一本书，页面跳转到：http://localhost:8080/SessionTest_war_exploded/indexServlet/buyServlet，然后跳转到：http://localhost:8080/SessionTest_war_exploded/listCartServlet 由于session是保存在服务器端的，cookie是保存在浏览器端的。这里的session和cookie只是保存在内存中，并没有因为设置cookie的保存时间问题二长期存储到硬盘中，如果关闭某一端，购买的物品都会失效。（不知是否正确，待证明） 细节说明 当客户端关闭后，服务器不关闭，两次获取session，默认情况下不是同一个session。如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 123Cookie cookie = new Cookie(\"JSESSIONID\",session.getId());cookie.setMaxAge(60 * 60);response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session，不是同一个，但是要确保数据不丢失： session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上。 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 IDEA 不能实现session的活化： 从tomcat的文件目录中可以知道，word 目录是用来存储程序运行中动态生成的数据（JSP转换的Java文件、Session被序列化之后的文件 …… ） 。 将项目打包成wer包，放到tomcat中，在终端中运行tomcat服务器，之后正常关闭tomcat服务器，会在word/Catalina/locathout/项目名称/目录中生成SESSIONS.ser文件， 该文件放的就是session对象，重新启动服务器，再次访问该项目，该SESSIONS.ser文件就会被自动读取进内容，且会将SESSIONS.ser文件从硬盘中删除 。 IDEA 虽然可以进行钝化，但是不能进行活化。在IDEA中启动tomcat，找到对应该项目的目录，可以发现会生成一个word目录，这里和终端中启动tomcat，也是一样的（即生成一个word目录）。同理后面在IDEA中关闭tomcat，对应的项目目录下的 word/Catalina/locathout/项目名称/ 目录也会生成SESSIONS.ser文件。不过再次从IDEA中启动tomcat服务器，那么这里就不一样了，之前word目录会被删除，然后创建一个新的word目录。那之前生成的SESSIONS.ser文件也会被删除，就不能读取到那个 SESSIONS.ser 文件了，也就不能实现session的活化了。 Session的失效时间 服务器关闭 session对象调用invalidate() session默认失效时间 30分钟，也可以修改对应的web.xml文件中的如下内容，来自定义失效时间： 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; Session的特点 session用于存储一次会话的多次请求的数据，存在服务器端。 session可以存储任意类型，任意大小的数据。 session与Cookie的区别 session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有大小限制 session数据安全，Cookie相对于不安全 案例2案例需求 访问带有验证码的登录页面login.jsp 用户输入用户名，密码以及验证码。 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 案例分析 用户访问login.jsp登录页面，输入用户名、密码和验证码，点击登录 用户点击登录后，将请求提交给 LoginServlet.java 处理 设置request编码 获取参数Map集合 获取验证码 将用户信息封装到User对象 判断Java程序生成的验证码和用户输入的验证码是否一致 从session中获取Java程序生成的验证码。 如果生成的验证码和用户输入的验证码一致，再判断用户名和密码是否正确 如果用户名和密码正确，用户登录成功，页面跳转到success.jsp，存储用户登录的数据（采用重定向）。 如果用户名和密码不正确，login.jsp页面给用户提示信息：用户名或密码错误。 如果生成的验证码和用户输入的验证码不一致，login.jsp页面给用户提示信息，验证码输入错误，并刷新验证码 查询用户名和密码是否正确的时候，将从 LoginServlet 中获取到的用户名和密码与 UserDao.java 中存储到的用户名和密码对比，判断是否正确。 案例的实现 验证码的实现：CheckCodeServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 定义验证码方框长和宽 int width = 100, height = 50; // 创建一个对象，在内存中画图（验证码图片对象） BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR); // 美化图片 // 创建画笔对象 Graphics graphics = bufferedImage.getGraphics(); // 设置画笔的颜色 graphics.setColor(Color.PINK); // 用画笔，将制定的长方形区域，画满（画验证码图片背景 -&gt; 粉红色） graphics.fillRect(0, 0, width, height); // 画验证码图片边框 // 设置画笔的颜色 graphics.setColor(Color.BLACK); graphics.drawRect(0, 0, width - 1, height - 1); // 定义一个包含所有字母和数字的字符串（验证码） String strings = \"QqWwEeRrTtYyUuIiOoPpAaSsDdFfGgHhJjKkLlZzXxCcVvBbNnMm1234567890\"; // 创建随机数对象，用来获取字符串中的一个字符 Random random = new Random(); // 写入四个字符在验证码方框中 int codeNumber = 4; // 创建字符缓冲区对象，存储验证码 StringBuilder stringBuilder = new StringBuilder(); for (int i = 1; i &lt;= codeNumber; i++) { // strings 索引 int index = random.nextInt(strings.length()); // 通过索引获取字符 char indexString = strings.charAt(index); // 将一个验证码字符存储到字符缓冲区 stringBuilder.append(indexString); // 写入一个验证符 graphics.drawString(indexString + \"\", width / 5 * i, height / 2); } // 验证码 String checkCodeSession = stringBuilder.toString(); // 将验证码存入Session request.getSession().setAttribute(\"checkCodeSession\", checkCodeSession); // 在验证码方框中画干扰线 graphics.setColor(Color.GREEN); int lineNumber = 10; for (int i = 0; i &lt; lineNumber; i++) { // 生成随机坐标点 int x1 = random.nextInt(width); int x2 = random.nextInt(width); int y1 = random.nextInt(height); int y2 = random.nextInt(height); // 画线 graphics.drawLine(x1, y1, x2, y2); } // 将图片输出到页面展示 ImageIO.write(bufferedImage, \"png\", response.getOutputStream()); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 创建并编写一个登录页面：Login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"LoginScript.js\"&gt;&lt;/script&gt; &lt;style&gt; div { color: pink } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建一个表单，指向 LoginServlet.java --&gt; &lt;form action=\"/SessionMaster_war_exploded/loginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"checkCode\" placeholder=\"请输入验证码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 验证码图片，指向CheckCodeServlet.java，该验证码图片占两个单元格 且绑定单击事件，交给LoginScript.js中的ClickImage()方法处理 --&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;img id=\"clickCheckCodeImage\" onclick=\"ClickImage()\" src=\"/SessionMaster_war_exploded/checkCodeServlet\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;%-- 获取错误信息 --%&gt; &lt;div&gt;&lt;%= request.getAttribute(\"usernameOrPasswordError\") == null ? \"\" : request.getAttribute(\"usernameOrPasswordError\") %&gt;&lt;/div&gt; &lt;div&gt;&lt;%= request.getAttribute(\"checkCodeError\") == null ? \"\" : request.getAttribute(\"checkCodeError\")%&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从上面的 Login.jsp 可以看出，验证码是由 CheckCodeServlet.java 生成的，且绑定了单击事件，交给 LoginScript.js 处理。表单提交后，交给 LoginServlet.java 处理。 编写 LoginScript.js 123456function ClickImage() { // 验证码，绑定鼠标单击事件，用户点击验证码图片，验证码自动更新 document.getElementById(\"clickCheckCodeImage\").onclick = function code() { this.src = \"/SessionMaster_war_exploded/checkCodeServlet?time=\"+new Date().getTime(); }} 编写 LoginServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置request编码 request.setCharacterEncoding(\"utf-8\"); // 获取参数，保存在Map集合中 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); // 获取 Map 集合中的所有键值 Set&lt;String&gt; strings = parameterMap.keySet(); // 获取username、password、checkCode String username = null, password = null, checkCode = null; // 获取Set集合的迭代器对象，并遍历该迭代器对象 Iterator&lt;String&gt; ite = strings.iterator(); while (ite.hasNext()) { // 通过迭代器对象中的每一个值(Map集合中的键)，获取value String next = ite.next(); if (\"username\".equals(next)) { username = parameterMap.get(next)[0]; } else if (\"password\".equals(next)) { password = parameterMap.get(next)[0]; } else if (\"checkCode\".equals(next)) { checkCode = parameterMap.get(next)[0]; } } // 通过session对象获取生成的验证码 HttpSession session = request.getSession(); String checkCodeSession = (String) session.getAttribute(\"checkCodeSession\"); // 获取完验证码后，将原有的验证码从session中删除（保证验证码只能被使用一次） session.removeAttribute(\"checkCodeSession\"); // 判断用户输入的验证码是否和生成的验证码一致（不区分大小写） if (checkCodeSession != null &amp;&amp; checkCodeSession.equalsIgnoreCase(checkCode)) { // 验证码一致，判断用户名和密码是否正确 boolean flag = false; String[] userInfoArrayList = UserDao.getNamePassword(); for (String userInfo : userInfoArrayList) { if ((username + password).equals(userInfo)) { flag = true; } } if (flag == true) { // 用户名和密码正确 // 存储用户名信息到session session.setAttribute(\"username\", username); // 重定向到 Success.jsp response.sendRedirect(request.getContextPath()+\"/Success.jsp\"); } else { // 用户名和密码不正确，存储提示信息到request request.setAttribute(\"usernameOrPasswordError\", \"用户名或密码错误，请检查后修改！\"); // 将该信息转发到登录页面 request.getRequestDispatcher(\"/Login.jsp\").forward(request, response); } } else { if (checkCodeSession == null) { // 验证码只能使用一次，假如登陆成功后，返回前一个页面，验证码图片是没有更新的。 // 要保证验证码只能使用一次。存储提示信息到request request.setAttribute(\"checkCodeError\", \"验证码已经失效，请刷新验证码！\"); } else { // 验证码不一致，存储提示信息到request request.setAttribute(\"checkCodeError\", \"验证码输入错误，请重新输入验证码\"); } // 将该信息转发到登录页面 request.getRequestDispatcher(\"/Login.jsp\").forward(request, response); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 从 LoginServlet.java 可以知道，该类中的判断使用了 UserDao.java 中的信息。如果用户登录成功，页面将挑战到 Success.jsp 。 编写 UserDao.java 类 编写自定义用户信息数据类型：UserInfo.java 12345678910111213141516171819202122232425public class UserInfo { private String username; private String password; private String gender; public UserInfo() { } public UserInfo(String username, String password, String gender) { this.username = username; this.password = password; this.gender = gender; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; }} 编写UserDao.java 类 12345678910111213141516171819202122232425public class UserDao { private static Map&lt;Integer, UserInfo&gt; userInfoArrayList = new LinkedHashMap(); static { userInfoArrayList.put(0, new UserInfo(\"LeeHua\", \"2020520\", \"male\")); userInfoArrayList.put(1, new UserInfo(\"Rainbow\", \"20181314\", \"female\")); } public static String[] getNamePassword() { String[] namesAndPasswords = new String[2]; // 获取 Map 集合中的所有键值 Set&lt;Integer&gt; strings = userInfoArrayList.keySet(); // 获取Set集合的迭代器对象，并遍历该迭代器对象 Iterator&lt;Integer&gt; ite = strings.iterator(); while (ite.hasNext()) { // 通过迭代器对象中的每一个值(Map集合中的键)，获取value Integer next = ite.next(); String username = userInfoArrayList.get(next).getUsername(); String password = userInfoArrayList.get(next).getPassword(); namesAndPasswords[next] = username + password; } return namesAndPasswords; }} 该案例的代码部分已经基本完成，下面进行测试。 案例测试 启动浏览器，访问：http://localhost:8080/SessionMaster_war_exploded/Login.jsp 用户名和密码信息，在 UserDao.java 类中，如下： 12UserInfo(\"LeeHua\", \"2020520\", \"male\")UserInfo(\"Rainbow\", \"20181314\", \"female\") 输入正确的用户名和验证码：如LeeHua、2020520 页面跳转到：http://localhost:8080/SessionMaster_war_exploded/Success.jsp 返回前一个页面，会发现，验证码是没有发生改变的，假如没有点击验证码图片来刷新验证码，而继续选择登录，无论用户名或者密码是否正确，都会出现以下情况： 页面跳转到：http://localhost:8080/SessionMaster_war_exploded/loginServlet 页面显示内容如下： 无论用户名是否正确，都会先判断验证码的正确性，验证码正确的情况下才会继续判断用户名和密码是否正确。 验证码错误的情况： 输入： 页面跳转到：http://localhost:8080/SessionMaster_war_exploded/loginServlet 页面显示情况： 密码或用户名错误的情况： 输入： 页面跳转到：http://localhost:8080/SessionMaster_war_exploded/loginServlet 页面显示情况： 参考文献 会话管理之session技术","link":"/p/390204202006/"},{"title":"Spring 中事务控制的 API 介绍","text":"@Author: YiHua Lee @Address: Guangdong province, China PlatformTransactionManager 此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法 12345678// 获取食物状态信息TransactionStatus getTransaction(TransactionDefinition definition)// 提交事务void commit(TransactionStatus status)// 回滚事务void rollback(TransactionStatus status) PlatformTransactionManager 的常用实现类 12org.springframework.jdbc.datasource.DataSourceTransactionManager// 使用 Spring JDBC 或 iBatis 进行持久化数据时使用 12org.springframework.orm.hibernate5.HibernateTransactionManager// 使用 Hibernate 版本进行持久化数据时使用 TransactionDefinition TransactionDefinition 是事务的定义信息对象 1234567891011121314// 获取事务对象名称String getName()// 获取事务隔离级int getlsolationLevel()// 获取事务传播行为int getPropagationBehavior()// 获取事务超时时间int getTimeout()// 获取事务是否只读boolean isReadOnly() 事务的隔离级别 事务隔离级反映事务提交并发访问时的处理态度 1234567891011121314ISOLATION_DEFAULT// 默认级别，归属下列某一-种ISOLATION_READ_UNCOMMITTED// 可以读取未提交数据ISOLATION_READ_COMMITTED// 只能读取已提交数据，解决脏读问题(Oracle默认级别)ISOLATION_REPEATABLE_READ// 是否读取其他事务提交修改后的数据，解决不可重复读问题(MySQL默认级别)ISOLATION_SERIALIZABLE// 是否读取其他事务提交添加后的数据，解决幻影读问题 事务的传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。 超时时间 默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 是否是只读事务 建议查询时设置为只读。 TransactionStatus TransactionStatus 接口提供的是事务具体的运行状态 1234567891011121314151617// 刷新事务void flush()// 获取是否是否存在存储点boolean hasSavepoint()// 获取事务是否完成boolean isCompleted()// 获取事务是否为新的事务boolean isNewTransaction()// 获取事务是否回滚boolean isRollbackOnly()// 设置事务回滚void setRollbackOnly() 基于 XML 的声明式事务控制（配置方式）spring 的配置文件约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring -beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring -aop.xsd\"&gt;&lt;/beans&gt; 配置事务管理器1&lt;bean id=\"事务管理器唯一标识\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" /&gt; 配置事务的通知引用事务管理器1&lt;tx:advice id=\"事务通知唯一标识\" transaction-manager=\"事务管理器\"&gt; 配置事务的属性 在 &lt;tx:advice&gt; 标签内部配置事务的属性 &lt;tx:attributes&gt; 配置事务的属性 &lt;tx:method&gt; 指定方法名称：是业务核心方法 属性值 read-only：是否是只读事务。默认 false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for ：用于指定一个异常， 当产生该异常时， 事务不回滚， 产生其他异常时， 事务回滚。没有默认值，任何异常都回滚。 基于注解的配置方式spring 的配置文件约束12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring -beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring -aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring -context.xsd\"&gt;&lt;/beans&gt; 在业务层使用 @Transactional 注解 @Transactional 注解 类似于&lt;tx:method&gt;，指定类，配置事务的属性 1234567@Service(\"serviceDemo\")@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)// propagation 属性指定事务的传播行为。// readOnly 属性说明是否是只读事务public class ServiceDemo() { ... ...} 参考文献 黑马 Java","link":"/p/072215202008/"},{"title":"Spring XML配置和注解配置","text":"@Author: YiHua Lee @Address: Guangdong province, China XML 文件的配置1234&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot; scope=&quot;&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;&quot; ref=&quot;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; id：被创建的对象的 id class：要被创建的类对象的类全名 init-method：初始化方法 destroy-method：销毁方法 scope：对象的作用域 name：要被注入的数据的名称 value：注入数据的值 ref：当注入的数据是其他 bean 类型时，其他 bean 类型的名称 常用注解配置用于创建对象的注解 注解的作用和 xml 配置文件中编写 &lt;bean&gt;&lt;/bean&gt; 标签的功能是一样的，即将当前类对象存入 Spring 容器中 @Componcnt 注解：该注解用于把当前类对象存入 Spring 容器中 该注解的属性： value： 指定 bean 的 id。假如我们没有指定 value 的值，默认为当前类名的首字母改小写，其余不变的名称。 其中 Spring 还为我们提供了三个作用和 @Component 一样的注解（使得我们的三层对象更加清晰）： @Controller 一般用在表现层 @Service 一般用在业务层 @Repository 一般用在持久层 用于改变创建的对象的注入数据的注解 @Autowritred 注解：该注解可以自动按照类型注入数据到 bean 中 注入条件： 如果 ioc 容器中用唯一的一个 bean 对象类型和要被注入的变量类型匹配 如果 ioc 容器中没有对应的 bean 对象类型和要被注入的变量类型匹配，那么会抛出异常。 如果 ioc 容器中有多个 bean 对象类型和要被注入的变量类型匹配，首先会根据 id 来匹配，如果 id 都一样，则会根据要被注入的变量的名称匹配，如果变量的名称都一样，那么就会抛出异常。 @Qualifier 注解：该注解，在 @Autowritred 的基础之上，可以添加 value 属性值，指定注入的 bean id（需要和 @Autowritred 一起使用） @Resource 该注解和 @Qualifier 类似，可以指定注入的 bean id，但不需要和 @Autowritred 一起使用。@Resource 单独使用。 @Value 注解：该注解用于注入基本数据类型和 String 数据类型 该注解的属性： value：用于指定数据的值。可以是 Spring 中的 el 表达式（SpEL） SpEL 书写格式：${EL 表达式} 说明： @Autowritred @Qualifier @Resource 只能注入其他 bean 类型的数据，不能注入基本数据类型和 String 类型的数据。 集合类型的数据只能通过 XML 文件进行注入。 用于改变创建的对象的作用范围的注解 @Scope 注解：该注解用于指定 Bean 的作用范围 该注解的属性： value：指定范围的取值。吃常用的取值有：singleton（单例的）、prototype（多例的） 默认为单例的（对象只创建一次） 生命周期相关的注解 @PreDestroy 销毁方法的注解 @PostConstruct 初始化方法的注解 Spring 中的新注解@Configuration 注解 用于指定当前类是一个 Spring 配置类，当创建容器时 会从该类上加载注解。 获取容器时需要使用AnnotationApplicationContext(有@Configuration 注解的类.class)。 12345/** * @Description: Spring 的配置类，相当于 bean.xml 文件 */@Configurationpublic class SpringConfiguration { } @ComponentScan 注解 用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的： &lt;context:component-scan base-package=&quot;pers.stringbug&quot;/&gt; 是一样的 @ComponentScan 注解的属性： basePackages：用于指定要扫描的包。 value：用于指定要扫描的包。功能和 basePackages 属性功能一样。 123@Configuration@ComponentScan(basePackages=\"pers.stringbug\")public class SpringConfiguration { } @Bean 注解 该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。 属性： name：给当前 @Bean 注解方法创建的对象指定一个名称 (即 bean 的 id）。 123456789101112131415161718192021@Configuration@ComponentScan(basePackages=\"pers.stringbug\")public class SpringConfiguration { /** 创建 QueryRunner 对象，并存入 Spring 容器中 */ @Bean(name=\"runner\") public QueryRunner createQueryRunner(DataSource dataSource) { return new QueryRunner(dataSource); } /** 创建数据源对象，并存入 spring 容器中 */ @Bean(name=\"dataSource\") public DataSource createDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/Study\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"123456\"); return dataSource; }} @PropertySource 注解 用于加载 .properties 文件中的配置 。 例如我们配置数据源时， 可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。 属性： value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath: 123456789101112131415161718192021@PropertySource(value={\"classpath:jdbc.properties\"})public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Bean(name=\"dataSource\") public DataSource createDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; }} @Import 注解此时我们已经有了两个配置类（SpringConfiguration、JdbcConfig），但是他们还没有关系。下面我们可以使用 @Import 注解，为这两个配置类建立关系链接。 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码。 1234567891011121314@Configuration@ComponentScan(basePackages=\"pers.stringbug\")@PropertySource(value={\"classpath:jdbc.properties\"})@Import(value={JdbcConfig.class})public class SpringConfiguration { /** * 创建 QueryRunner 对象，并存入 Spring 容器中 * 其中 @Qualifier(value=\"dataSource\") 指定 bean 参数 id */ @Bean(name=\"runner\") public QueryRunner createQueryRunner(@Qualifier(value=\"dataSource\") DataSource dataSource) { return new QueryRunner(dataSource); }} 该例子类似于 @Bean 注解 中的 SpringConfiguration.java 参考文献 无","link":"/p/491704202008/"},{"title":"Spring 中的 AOP","text":"@Author: YiHua Lee @Address: Guangdong province, China AOP 概述 AOP（Aspect-Oriented Programming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP 相关术语 Joinpoint(连接点 ) 所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。 Pointcut(切入点 ) 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。 Advice(通知 /增强 ) 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 Introduction(引介 ) 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。 Target(目标对象 ) 代理的目标对象。 Weaving(织入 ) 是指把增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 Proxy（代理） 一个类被 AOP 织入增强后，就产生一个结果代理类。 Aspect(切面 ) 是切入点和通知（引介）的结合。 AOP maven依赖123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;${aspectj.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;${aspectj.version}&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基于 XML 的 AOP 配置配置文件中的 AOP 约束123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 使用 aop:config 声明 aop 配置 作用： 用于声明开始 aop 的配置 123&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt;&lt;/aop:config&gt; 使用 aop:aspect 配置切面 作用：用于配置切面 属性： ​ id：给切面提供一个唯一标识。 ​ ref：引用配置好的通知类 bean 的 id。 123&lt;aop:aspect id=\"XXX\" ref=\"XXXXX\"&gt; &lt;!-- 配置通知的类型要写在此处 --&gt;&lt;/aop:aspect&gt; 使用 aop:pointcut 配置切入点表达式 作用：用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。 属性： ​ expression：用于定义切入点表达式。 ​ id：用于给切入点表达式提供一个唯一标识 123&lt;aop:before method=\"printLog\" pointcut=\"execution( 访问修饰符 返回值 第1层包.第2层包.第3层包.类名称.方法名称(参数列表) )\"&gt;&lt;/aop:before&gt; 使用 aop:xxx 配置 对应的通知类型aop:before 作用：用于配置前置通知。指定增强的方法在切入点方法之前执行 属性： ​ method: 用于指定通知类中的增强方法名称 ​ ponitcut-ref：用于指定切入点的表达式的引用 ​ poinitcut：用于指定切入点表达式 执行时间点：切入点方法执行之前执行 1&lt;aop:before method=\"增强方法\" pointcut-ref=\"切入点的表达式的引用\"/&gt; 1&lt;aop:before method=\"增强方法\" pointcut=\"切入点表达式\"/&gt; aop:after-returning 作用：用于配置后置通知 属性： ​ method： 指定通知中方法的名称。 ​ pointct： 定义切入点表达式 ​ pointcut-ref： 指定切入点表达式的引用 执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 1&lt;aop:after-returning method=\"增强方法\" pointcut-ref=\"切入点的表达式的引用\"/&gt; 1&lt;aop:after-returning method=\"增强方法\" pointcut=\"切入点表达式\"/&gt; aop:after-throwing 作用：用于配置异常通知 属性： ​ method： 指定通知中方法的名称。 ​ pointct： 定义切入点表达式 ​ pointcut-ref： 指定切入点表达式的引用 执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个 1&lt;aop:after-throwing method=\"增强方法\" pointcut-ref=\"切入点的表达式的引用\"/&gt; 1&lt;aop:after-throwing method=\"增强方法\" pointcut=\"切入点表达式\"/&gt; aop:after 作用：用于配置最终通知 属性： ​ method： 指定通知中方法的名称。 ​ pointct： 定义切入点表达式 ​ pointcut-ref： 指定切入点表达式的引用 执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 1&lt;aop:after method=\"增强方法\" pointcut-ref=\"切入点的表达式的引用\"/&gt; 1&lt;aop:after method=\"增强方法\" pointcut=\"切入点表达式\"/&gt; aop:around 作用：用于配置环绕通知 属性： ​ method：指定通知中方法的名称。 ​ pointct：定义切入点表达式 ​ pointcut-ref：指定切入点表达式的引用 说明：它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意：通常情况下，环绕通知都是独立使用的 12&lt;aop:around method=\"增强方法\" pointcut-ref=\"切入点的表达式的引用\" /&gt;&lt;aop:pointcut id=\"切入点表达式唯一标识\" expression=\"execution(切入点的表达式)\"/&gt; 切入点表达式说明 表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 表达式标准格式 1访问修饰符 返回值 包名称.类名称.方法名称(参数列表) 123&lt;aop:before method=\"printLog\" pointcut=\"execution( public void pers.stringbug.service.impl.AccountServiceImpl.saveAccount() )\"&gt;&lt;/aop:before&gt; 省略访问修饰符 1返回值 包名称.类名称.方法名称(参数列表) 123&lt;aop:before method=\"printLog\" pointcut=\"execution( void pers.stringbug.service.impl.AccountServiceImpl.saveAccount() )\"&gt;&lt;/aop:before&gt; 返回值使用通配符 1访问修饰符 * 包名称.类名称.方法名称(参数列表) 123&lt;aop:before method=\"printLog\" pointcut=\"execution( * pers.stringbug.service.impl.AccountServiceImpl.saveAccount() )\"&gt;&lt;/aop:before&gt; 包名使用通配符：包名可以使用通配符 * 表示任意包，但是有多少级包，就要对应多少哥通配符 1访问修饰符 返回值 第1层包.第2层包.第3层包.类名称.方法名称(参数列表) 写法1 1访问修饰符 返回值 *.*.*.类名称.方法名称(参数列表) 写法2：有的时候包的层数很多，可以用 .. 表示多层子包 1访问修饰符 返回值 *..类名称.方法名称(参数列表) 123&lt;aop:before method=\"printLog\" pointcut=\"execution( * *..AccountServiceImpl.saveAccount() )\"&gt;&lt;/aop:before&gt; 类名使用通配符 1访问修饰符 返回值 包名称.*.方法名称(参数列表) 1234&lt;!-- 返回值使用通配符、包名使用通配符、类名使用通配符 --&gt;&lt;aop:before method=\"printLog\" pointcut=\"execution( * *..*.saveAccount() )\"&gt;&lt;/aop:before&gt; 方法名使用通配符 1访问修饰符 返回值 包名称.类名称.*(参数列表) 1234&lt;!-- 返回值使用通配符、包名使用通配符、类名使用通配符、方法名使用通配符 --&gt;&lt;aop:before method=\"printLog\" pointcut=\"execution( * *..*.*(int, String) )\"&gt;&lt;/aop:before&gt; 参数列表使用通配符 只有一个参数时 1访问修饰符 返回值 包名称.类名称.方法名称(*) 有多个参数时 1访问修饰符 返回值 包名称.类名称.方法名称(*, *, *) 有 0 或多个参数时：可以使用 .. 表示参数列表 1访问修饰符 返回值 包名称.类名称.方法名称(..) 1234&lt;!-- 返回值使用通配符、包名使用通配符、类名使用通配符、方法名使用通配符、参数使用通配符 --&gt;&lt;aop:before method=\"printLog\" pointcut=\"execution( * *..*.*(..) )\"&gt;&lt;/aop:before&gt; 全通配写法 返回值使用通配符、包名使用通配符、类名使用通配符、方法名使用通配符、参数使用通配符 1* *..*.*(..) 基于注解的 AOP 配置配置文件夹中的 AOP 约束和 Context 约束123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; @Aspect 注解 注解 @Aspect 表示当前类是一个切面类 如： 123@Component(value=\"logger\")@Aspectpublic class Logger { } @Pointcut 注解 注解 @Pointcut 配置切入点表达式 属性值： ​ value：切入点表达式 如： 1234public class Logger { @Pointcut(value=\"execution(* pers.stringbug.service.*.*(..))\") private void loggerExpression() { }} @Before 注解 注解 @Before 指定前置通知 属性值： ​ value：用于指定切入点表达式，还可以指定切入点表达式的引用 如： 12345678910public class Logger { @Pointcut(value=\"execution(* pers.stringbug.service.*.*(..))\") private void loggerExpression() { } @Before(value=\"loggerExpression()\") public void beforePrintLog() { System.out.println( \"前置通知：Logger 类中的 beforePrintLog 方法开始记录日记信息了\"); }} @AfterReturning 注解 注解 @AfterReturning 指定后置通知 属性值： ​ value：用于指定切入点表达式，还可以指定切入点表达式的引用 如： 12345678910public class Logger { @Pointcut(value=\"execution(* pers.stringbug.service.*.*(..))\") private void loggerExpression() { } @AfterReturning(value=\"loggerExpression()\") public void afterReturningPrintLog() { System.out.println( \"后置通知：Logger 类中的 afterReturningPrintLog 方法开始记录日记信息了\"); }} @AfterThrowing 注解 注解 @AfterThrowing 指定异常通知 属性值： ​ value：用于指定切入点表达式，还可以指定切入点表达式的引用 如： 12345678910public class Logger { @Pointcut(value=\"execution(* pers.stringbug.service.*.*(..))\") private void loggerExpression() { } @AfterThrowing(value=\"loggerExpression()\") public void afterThrowingPrintLog() { System.out.println( \"异常通知：Logger 类中的 afterThrowingPrintLog 方法开始记录日记信息了\"); }} @After 注解 注解 @After 指定最终通知 属性值： ​ value：用于指定切入点表达式，还可以指定切入点表达式的引用 如： 12345678910public class Logger { @Pointcut(value=\"execution(* pers.stringbug.service.*.*(..))\") private void loggerExpression() { } @After(value=\"loggerExpression()\") public void afterPrintLog() { System.out.println( \"最终通知：Logger 类中的 afterPrintLog 方法开始记录日记信息了\"); }} @Around 注解 注解 @Around 指定环绕通知 属性值： ​ value：用于指定切入点表达式，还可以指定切入点表达式的引用 Spring 框架为我们提供了一个接口（ProceedingJoinPoint），该接口有一个 Proceed 方法，可以明确切入点方法。 **ProceedingJoinPoint** 接口可作为环绕通知的方法参数，在执行程序的时候，Spring 框架会为我们提供该接口的实现类来使用。 如： 1234567891011121314151617181920212223242526public class Logger { @Pointcut(value=\"execution(* pers.stringbug.service.*.*(..))\") private void loggerExpression() { } @Around(value=\"loggerExpression()\") public Object aroundPrintLog(ProceedingJoinPoint joinPoint) { try { // 获取方法执行所需的参数 Object[] args = joinPoint.getArgs(); System.out.println( \"前置通知：Logger 类中的 beforePrintLog 方法开始记录日记信息了\"); // 明确要调用的业务层方法（即切入点方法） Object returnValue = joinPoint.proceed(args); System.out.println( \"后置通知：Logger 类中的 afterReturningPrintLog 方法开始记录日记信息了\"); return returnValue; } catch (Throwable e) { System.out.println( \"异常通知：Logger 类中的 afterThrowingPrintLog 方法开始记录日记信息了\"); throw new RuntimeException(e); } finally { System.out.println( \"最终通知：Logger 类中的 afterPrintLog 方法开始记录日记信息了\"); } }} 开启注解 AOP 的支持XML 方式aspectj-autoproxy 1&lt;aop:aspectj-autoproxy /&gt; 注解方式@EnableAspectJAutoProxy 1234@Configuration@ComponentScan(basePackages=\"pers.stringbug\")@EnableAspectJAutoProxypublic class SpringConfiguration { } 参考文献 十分钟全面理解Spring AOP","link":"/p/341510202008/"},{"title":"SpringMVC 入门案例","text":"@Author: YiHua Lee @Address: Guangdong province, China 工程的创建、配置 创建 WEB 工程：SpringMvcStart 引入 jar 包（pom.xml） 1234567891011121314151617181920212223242526272829303132333435363738&lt;properties&gt; &lt;!-- 版本锁定 --&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置核心的控制器（web.xml）：DispatcherServlet 12345678910111213141516171819202122&lt;!-- SpringMVC 核心控制器 --&gt;&lt;servlet&gt; &lt;!-- DispatcherServlet —— 核心控制器 --&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置 Servlet 的初始化参数，读取 springmvc 的配置文件，创建 spring 容器 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置 servlet 启动时加载对象 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- Servlet 映射：SpringMVC 核心控制器 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- 映射路径 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写springmvc.xml的配置文件 配置文件约束： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 配置： 1234567891011121314&lt;!-- 配置 Spring 创建容器是要扫描的包 --&gt;&lt;context:component-scan base-package=\"pers.stringbug\" /&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean id=\"internalResourceView\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 前缀：页面 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!-- 后缀：文件后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;&lt;!-- 配置 SpringMVC 框架注解支持 --&gt;&lt;mvc:annotation-driven /&gt; 编写工程功能 编写index.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello, World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门程序&lt;/h3&gt; &lt;a href=\"hello\"&gt;入门程序&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 编写 HelloController.java 1234567891011/** 控制器 */@Controller // 控制类public class HelloController { /** 接收请求 */ @RequestMapping(path = \"/hello\") // 请求映射路径 public String sayHello() { System.out.println(\"Hello, SpringMVC!\"); return \"success\"; // 接收请求后，返回的数据 }} 在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;访问成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门成功&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 工程的启动 启动Tomcat服务器 访问：http://localhost:8080/SpringMvcStart_war/index.jsp 点击 入门程序 跳转链接：（发送请求到HelloController.java） idea 控制台输出： 1Hello, SpringMVC! 页面跳转到：http://localhost:8080/SpringMvcStart_war/hello 项目完成，关闭 Tomcat 入门案例的执行过程分析 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件 加载 springmvc.xml 开启了注解扫描，那么HelloController对象就会被创建 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解 找到执行的具体方法 DispatcherServlet对象会根据要被扫描的包中，存在 @RequestMapping 注解的对象，将请求发送给对应的对象： 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 返回 HelloController 对象中的 sayHello 方法给 DispatcherServlet 对象，然后执行方法，控制台输出 Hello, SpringMVC!，返回数据 success，DispatcherServlet 对象再将该数据提交给 InternalResourceViewResolver 对象 扫描 springmvc.xml 文件的时候，就已经创建了 InternalResourceViewResolver 对象了： 12345678&lt;!-- 配置视图解析器 --&gt;&lt;bean id=\"internalResourceView\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; Tomcat服务器渲染页面，做出响应 InternalResourceViewResolver 对象根据 success 数据，以及前缀和后缀，指定 success.jsp 页面，返回给 DispatcherServlet 对象，然后 DispatcherServlet 对象将 success.jsp 页面响应给用户。 流程总结 参考文献 黑马 Java","link":"/p/491116202008/"},{"title":"SpringBoot 学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China 了解SpringBoot什么是SpringBoot SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 为什么要学习SpringBootjava 一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能 Python 程序员已经把功能写好了，究其原因注意是两点： 复杂的配置： 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 混乱的依赖管理： 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 SpringBoot的特点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 快速入门创建工程 新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 添加依赖添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 项目中多出了大量的依赖： 都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 完整pom123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 编写controller编写一个controller： 代码： 12345678@RestControllerpublic class HelloController { @GetMapping(\"hello\") public String hello(){ return \"hello, spring boot!\"; }} 启动测试接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 监听的端口是8080 SpringMVC的映射路径是：/ /hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;property name=\"url\" value=\"${jdbc.url}\" /&gt; &lt;property name=\"username\" value=\"${jdbc.username}\" /&gt; &lt;property name=\"password\" value=\"${jdbc.password}\" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 回顾历史 Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 尝试java配置java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件 接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource(\"classpath:jdbc.properties\")public class JdbcConfig { @Value(\"${jdbc.url}\") String url; @Value(\"${jdbc.driverClassName}\") String driverClassName; @Value(\"${jdbc.username}\") String username; @Value(\"${jdbc.password}\") String password; @Bean public DataSource dataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; }} 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController { @Autowired private DataSource dataSource; @GetMapping(\"hello\") public String hello() { return \"hello, spring boot!\" + dataSource; }} 然后Debug运行并查看： 属性注入成功了！ SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 我们新建一个类，用来进行属性注入： 12345678@ConfigurationProperties(prefix = \"jdbc\")@Datapublic class JdbcProperties { private String url; private String driverClassName; private String username; private String password;} 在类上通过 @ConfigurationProperties 注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 把上例中的 jdbc.properties 名称改为 application.properties，这是SpringBoot默认读取的属性文件名： 在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig { @Bean public DataSource dataSource(JdbcProperties jdbc) { DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; }} 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要用JdbcProperties这个类的对象 然后可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop){ this.prop = prop;} 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop){ // ...} 这里采用第三种方式进行注入。 测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是 user 对象中的 friend 属性中的 name 属性，显然 friend 也是对象。 @value 注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig { @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = \"jdbc\") public DataSource dataSource() { DruidDataSource dataSource = new DruidDataSource(); return dataSource; }} 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 再次测试： 自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 123456@SpringBootApplicationpublic class BootDemoApplication { public static void main(String[] args) { SpringApplication.run(BootDemoApplication.class, args); }} 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 了解@SpringBootApplication点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootConfiguration我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 @EnableAutoConfiguration关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 @ComponentScan源码： 查看这个注解的注释，大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 默认配置原理默认配置类通过刚才的学习，我们知道 @EnableAutoConfiguration 会开启 SpringBoot 的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如：redis、jms、amqp、jdbc、jackson、mongodb、jpa、solr、elasticsearch、… 等等 例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 等等 …… 默认配置属性另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 启动器 如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器。 全局配置 SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多。 SpringBoot实践整合SpringMVC修改端口查看SpringBoot的全局属性可知，端口通过以下方式配置：创建 SpringBoot 默认配置文件 —— application.yaml 12server: port: 80 也可以使用 application.properties 默认配置文件来配置端口： 12# 映射端口server.port=80 重启服务后测试： 修改映射路径修改配置文件：application.yaml 1234server: port: 80 servlet: path: \"*.abc\" 修改映射路径以后，获取映射路径的方法，也要修改为对应的映射，如： 12345@GetMapping(value = \"hello.abc\")@ResponseBodypublic String hello() { return \"Hello, SpringBoot!\";} 重启服务后测试： 修改日记级别修改配置文件：application.yaml 12345678server: port: 80 servlet: path: \"*.abc\"logging: level: pers.stringbug: debug org.springframework: debug 重启服务后测试：控制台这个时候输出的日记信息就会很详细 访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 有一个叫做 ResourceProperties 的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 在 static 中放如下动态图片： 重启项目后测试： 添加拦截器 如果我们想要保持 SpringBoot 的一些默认 MVC 特征，同时又想自定义一些 MVC 配置（包括：拦截器、格式化器、 视图控制器、消息转换器 等等）。这个时候，我们可以通过编写一个类，让这个类实现WebMvcConfigurer 接口，并且添加@Configuration注解，来实现自定义部分SpringMvc配置（不要添加@EnableWebMvc注解。）。 如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 注意：如果想要保留SpringBoot提供的一切特征，那么就不要添加@EnableWebMvc注解。 定义一个拦截器： 1234567891011121314151617181920212223public class MyInterceptor implements HandlerInterceptor { private Logger logger = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { logger.debug(\"preHandle method is now running!\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { logger.debug(\"postHandle method is now running!\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { logger.debug(\"afterCompletion method is now running!\"); }} 定义配置类，注册拦截器： 12345678@Configurationpublic class MvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { // 添加一个拦截器，该拦截器拦截一切路径 registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\"); }} applacation.yaml 配置如下： 12345678server: port: 80 servlet: path: /logging: level: pers.stringbug: debug org.springframework: debug 重启项目后测试： 此外拦截器还可以这样写： 123456789public class MyInterceptor implements HandlerInterceptor { private Logger logger = LoggerFactory.getLogger(MyInterceptor.class);}// 改成@Slf4jpublic class MyInterceptor implements HandlerInterceptor {} @Slf4j 可以帮我们为这个类创建 Logger 对象。 整合jdbc和事务spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 其中，需要在 application.yaml 中添加如下配置： 123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/Test username: root password: 123456 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 12345678910111213141516@Servicepublic class UserService { @Autowired private UserMapper userMapper; public User queryById(Long id){ return this.userMapper.selectByPrimaryKey(id); } @Transactional public void deleteById(Long id){ this.userMapper.deleteByPrimaryKey(id); }} 整合连接池其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 使用 HikariCP，只需要指定连接池参数即可：application.yaml 12345678910spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/Test username: root password: 123456 hikari: idle-timeout: 60000 maximum-pool-size: 30 minimum-idle: 10 application.properties 文件中可以这样配置： 12345678spring.datasource.url=jdbc:mysql://127.0.0.1:3306/Testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/Test username: root password: 123456 druid: initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true stat-view-servlet.allow: true application.properties 文件中可以这样配置： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 整合mybatismybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的：application.yaml 12345mybatis: configuration: map-underscore-to-camel-case: true mapper-locations: mappers/*.xml type-aliases-package: pers.stringbug.pojo application.properties 文件中可以这样配置： 12345mybatis.configuration.map-underscore-to-camel-case=true# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper {} 通用mapper通用Mapper 的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 注意：一但引入通用 Mapper 的启动器，会覆盖 Mybatis 官方启动器的功能。因此，需要移除对官方 Mybatis 启动器的依赖。 不需要做任何配置就可以使用了。如果还有其他需要，可以查看官网：https://github.com/abel533/Mapper/wiki 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;{} 另外，还需要在启动类上的 @MapperScan 注解修改为 通用Mapper 中自带的： 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@SpringBootApplication@MapperScan(\"pers.stringbug.mapper\")public class BootDemoApplication { public static void main(String[] args) { SpringApplication.run(BootDemoApplication.class, args); }} 启动测试将controller进行简单改造： 123456789101112@RestControllerpublic class HelloController { @Autowired private UserService userService; @GetMapping(\"/hello\") public User hello() { User user = this.userService.queryById(8L); return user; }} 我们启动项目，查看： 参考文献 黑马 Java","link":"/p/450018202008/"},{"title":"Tomcat 学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China 部署项目的方式直接将项目放到webapps目录举例如： 创建一个文件夹，用该文件夹来存放项目 在该文件夹下创建一个html文件，并输入部分内容 123&lt;font color='blue'&gt; Hello Tomcat!&lt;/font&gt; 将该文件夹放到 tomcat/webapps/ 目录下，这个时候我们终端通过 startup.sh 命令启动tomcat，然后访问 http://localhost:8080/hello/hello.html 就可以看到效果了： 将项目打包成 war 包放到webapps目录下假如我们的项目文件相当多的时候，我们可以将项目打包成 war 包，然后再放到 webapps 目录下，我们在开启 tomcat 的情况下，war 会自动解压 拿上面的 Hello Tomcat! 为例 将项目打包成 war 包 然后再将 war 包放到 tomcat/webapps/ 目录下 这个时候就会自动解压这个war包了 ![WarToFile.png](https://raw.githubusercontent.com/LeeYiua/FigureBed/master/img/May 2020/20200511150957.png) 通过浏览器访问 http://localhost:8080/hello/hello/hello.html ![浏览器访问.png](https://raw.githubusercontent.com/LeeYiua/FigureBed/master/img/May 2020/20200511151443.png) 配置 conf/server.xml 文件来部署 在标签体中配置，添加如下内容（要先关闭tomcat）： 1&lt;Context docBase=\"项目存放的路径\" path=\"浏览器访问时的路径\" /&gt; docBase：项目存放路径 path：虚拟路径 打开tomcat，浏览器访问 http://localhost:8080/hello/hello.html 在tomcat/conf/Catalina/localhost目录下创建xml文件来配置 在conf/Catalina/localhost目录下创建一个xml文件，如hello.xml，添加如下内容： 1&lt;Context docBase=\"项目存放的路径\" /&gt; 浏览器访问的时候，虚拟路径就是该 xml 文件的名称 浏览器中访问 http://localhost:8080/hello/hello.html 参考资料 MAC下tomcat的使用教程","link":"/p/171611202005/"},{"title":"Tomcat-学习笔记2","text":"@Author: YiHua Lee @Address: Guangdong province, China 将Tomcat集成到IDEA中 第一步 第二步 创建JavaEE的项目 第一步 第二步 第三步 部署项目 IDEA上运行部署好的项目 访问默认首页（web目录下的index.jsp） 也可以在web目录下创建一个html文件如：（热部署） 这时候可以通过 http://localhost:8080/hello.html 访问。 注意：","link":"/p/301512202005/"},{"title":"SpringMVC 常用注解","text":"@Author: YiHua Lee @Address: Guangdong province, China RequestMapping 注解 作用：是建立请求URL和处理方法之间的对应关系 RequestMapping注解可以作用在方法和类上 作用在类上：第一级的访问目录 作用在方法上：第二级的访问目录 细节：路径可以不编写 / 表示应用的根目录开始 细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 / RequestMapping的属性 path：指定请求路径的url value：value属性和path属性是一样的 mthod：指定该方法的请求方式 params：指定限制请求参数的条件 headers：发送的请求中必须包含的请求头 RequestParam注解 作用：把请求中的指定名称的参数传递给控制器中的形参赋值 属性 value：请求参数中的名称 required：请求参数中是否必须提供此参数，默认值是true，必须提供 123456789/** * 接收请求 */@RequestMapping(path=\"/hello\") public String sayHello(@RequestParam(value=\"username\",required=false) String name) { System.out.println(\"aaaa\"); System.out.println(name); return \"success\";} RequestBody注解 作用：用于获取请求体的内容（注意：get方法不可以） 属性 required：是否必须有请求体，默认值是true 123456789/** * 接收请求 */@RequestMapping(path=\"/hello\") public String sayHello(@RequestBody String body) { System.out.println(\"aaaa\"); System.out.println(body); return \"success\";} PathVariable注解 作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 属性 value：指定url中的占位符名称 Restful风格的URL 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 restful风格的URL优点 结构清晰 符合标准 易于理解 扩展方便 12345678/** * 接收请求 */@RequestMapping(path=\"/hello/{id}\")public String sayHello(@PathVariable(value=\"id\") String id) { System.out.println(id); return \"success\";} RequestHeader注解 作用：获取指定请求头的值 属性 value：请求头的名称 12345@RequestMapping(path=\"/hello/{id}\")public String sayHello(@RequestHeader(value=\"Accept\") String header) { System.out.println(header); return \"success\";} CookieValue注解 作用：用于获取指定cookie的名称的值 属性 value：cookie的名称 12345@RequestMapping(path=\"/hello/{id}\")public String sayHello(@CookieValue(value=\"JSESSIONID\") String cookieValue) { System.out.println(cookieValue); return \"success\";} ModelAttribute注解 作用： 1. 出现在方法上：表示当前方法会在控制器方法执行前线执行。 2. 出现在参数上：获取指定的数据给参数赋值。 应用场景：当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。 修饰的方法有返回值 12345678910111213141516171819202122/** * 作用在方法，先执行 */@ModelAttributepublic User showUser(String name) { System.out.println(\"showUser执行了...\"); // 模拟从数据库中查询对象 User user = new User(); user.setName(\"哈哈\"); user.setPassword(\"123\"); user.setMoney(100d); return user;}/** * 修改用户的方法 */@RequestMapping(path=\"/updateUser\")public String updateUser(User user) { System.out.println(user); return \"success\";} 修饰的方法没有返回值 12345678910111213141516171819202122/** * 作用在方法，先执行 */@ModelAttributepublic void showUser(String name,Map&lt;String, User&gt; map) { System.out.println(\"showUser执行了...\"); // 模拟从数据库中查询对象 User user = new User(); user.setName(\"哈哈\"); user.setPassword(\"123\"); user.setMoney(100d); map.put(\"abc\", user);}/** * 修改用户的方法 */@RequestMapping(path=\"/updateUser\")public String updateUser(@ModelAttribute(value=\"abc\") User user) { System.out.println(user); return \"success\";} SessionAttributes注解 作用：用于多次执行控制器方法间的参数共享 属性 value：指定存入属性的名称 12345678910111213141516171819202122232425262728293031323334@Controller@RequestMapping(path=\"/user\")// 把数据存入到session域对象中@SessionAttributes(value= {\"username\",\"password\",\"age\"},types={String.class,Integer.class})public class HelloController { /** 向session中存入值 */ @RequestMapping(path=\"/save\") public String save(Model model) { System.out.println(\"向session域中保存数据\"); model.addAttribute(\"username\", \"root\"); model.addAttribute(\"password\", \"123\"); model.addAttribute(\"age\", 20); return \"success\"; } /** 从session中获取值 */ @RequestMapping(path=\"/find\") public String find(ModelMap modelMap) { String username = (String) modelMap.get(\"username\"); String password = (String) modelMap.get(\"password\"); Integer age = (Integer) modelMap.get(\"age\"); System.out.println(username + \" : \"+password +\" : \"+age); return \"success\"; } /** 清除值 */ @RequestMapping(path=\"/delete\") public String delete(SessionStatus status) { status.setComplete(); return \"success\"; }} 参考文献 黑马 Java","link":"/p/551916202008/"},{"title":"Tomcat、Servlet、Request案例","text":"@Author: YiHua Lee @Address: Guangdong province, China 案例：用户登录用户登录案例需求 编写login.html登录页面 使用Druid数据库连接池技术,操作mysql，数据库名为Study，数据表名为users 使用JdbcTemplate技术封装JDBC 登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 下载架包 commons-logging-1.2.jar 下载。说明：用来记录程序运行时的活动的日志记录。 druid-1.0.9.jar下载地址。说明：Druid是一个数据库连接池，可以用来创建数据库连接池对象。 mchange-commons-java-0.2.12.jar下载。说明：C3P0数据库连接池依赖架包 mysql-connector-java-5.1.37.jar下载。说明：MySQL驱动架包 Spring 框架部分架包： spring-beans-5.0.0.RELEASE.jar下载 spring-core-5.0.0.RELEASE.jar下载 spring-jdbc-5.0.0.RELEASE.jar下载 spring-tx-5.0.0.RELEASE.jar下载 spring-core和spring-beans模块提供了框架的基础结构部分，包含控制反转和依赖注入功能。 spring-jdbc模块提供了JDBC抽象层，不需要再编写单调的JDBC代码，解析数据库提供商指定的错误编码。 spring-tx模块为实现指定接口和所有的简单Java对象的类提供编程式和声明式的业务管理。 实现 创建项目（RequestExample），导入架包到web/WEB-INF/lib目录下 创建html页面：login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\" method=\"post\"&gt; 用户名:&lt;label&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/label&gt;&lt;br&gt; 密码:&lt;label&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/label&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建数据库连接池的配置文件：driud.properties 1234567891011121314# 数据库连接池类全名称driverClassName=com.mysql.jdbc.Driver# 连接数据库的URL——jdbc:mysql://MySQL地址/数据库名url=jdbc:mysql://127.0.0.1:3306/Study# 数据库用户名username=用户名# 数据库密码password=密码# 数据库连接池初始化连接数initialSize=5# 数据库连接池最大连接数maxActive=10# 最大等待时间（毫秒为单位）maxWait=3000 创建数据表： 12345678910USE Study;CREATE TABLE users( -- 用户id为主键，主键值自增。 id INT PRIMARY KEY AUTO_INCREMENT, -- 用户名唯一，且非空。 username VARCHAR(32) UNIQUE NOT NULL, -- 用户密码非空 userPassword VARCHAR(32) NOT NULL);INSERT INTO users(username, userPassword) VALUES(LeeHua, 2018520), (Rainbow, 20201314); 创建一个用户实体类，用该实体类数据类型来存储用户信息：user.domain.User.java 1234567891011121314151617181920212223242526272829303132333435363738394041package user.domain;/** @Description: 用户实体类 */public class User { private int id; private String username; private String userPassword; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getUserPassword() { return userPassword; } public void setUserPassword(String userPassword) { this.userPassword = userPassword; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", userPassword='\" + userPassword + '\\'' + '}'; }} 创建一个Jdbc工具类，用来获取数据库连接池对象：JdbcUtil.java 1234567891011121314151617181920212223242526272829303132package user.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.util.Properties;public class JdbcUtil { private static DataSource dataSource; static { try { // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取类的类加载器 ClassLoader classLoader = JdbcUtil.class.getClassLoader(); // 获取druid-1.0.9.properties配置文件资源输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid.properties\"); // 加载配置文件 properties.load(resourceAsStream); // 获取连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static DataSource getDataSource() { return dataSource; }} 创建操作数据库users表中的类：UserDao.java 123456789101112131415161718192021222324252627282930313233343536373839package user.dao;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import user.domain.User;import user.util.JdbcUtil;public class UserDao { /** 创建JdbcTemplate对象，需要传入数据库连接池对象。 */ private JdbcTemplate template = new JdbcTemplate(JdbcUtil.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名的密码 * @return 用户全部数据 */ public User login(User loginUser) { try { // 定义预编译SQL语句 String sql = \"SELECT * FROM users WHERE username = ? AND userPassword = ?\"; // 查询结果，将结果封装为对象 User user = template. queryForObject( sql, // 将查询到的结果封装为 User 自定义数据结构 new BeanPropertyRowMapper&lt;User&gt;(User.class), // 传入预编译sql语句的参数 loginUser.getUsername(), loginUser.getUserPassword() ); return user; // 查询到有对应的用户数据，返回数据 } catch (DataAccessException e) { e.printStackTrace(); return null; // 查询不到对应的用户数据，返回null } }} 创建三个servlet类：获取用户请求信息是否正确类、用户登录成功类、用户登录失败类 用户登录成功类：SuccessServlet.java 123456789101112131415161718192021222324252627282930313233package web.servlet;import user.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/web/servlet/successServlet\")public class SuccessServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取request域中共享的user对象 User user = (User) request.getAttribute(\"username\"); if (user != null) { // 设置编码 response.setContentType(\"text/html;charset=utf-8\"); // 输出 response.getWriter().write(\"登录成功。\"+ user.getUsername() +\"，欢迎您！\"); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 用户登录失败类：FailServlet.java 1234567891011121314151617181920212223242526package web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/web/servlet/failServlet\")public class FailServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置编码 response.setContentType(\"text/html;charset=utf-8\"); // 输出 response.getWriter().write(\"登录失败，用户名或密码错误！\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 获取用户请求信息是否正确类：LoginServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package web.servlet;import user.dao.UserDao;import user.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/web/servlet/loginServlet\")public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置编码 request.setCharacterEncoding(\"utf-8\"); // 获取请求参数 String username = request.getParameter(\"username\"); String userPassword = request.getParameter(\"userPassword\"); // 封装User对象（将获取到的请求参数封装到自定义数据类型中） User loginUser = new User(); loginUser.setUsername(username); loginUser.setUserPassword(userPassword); // 创建UserDao，来操作数据库users表 UserDao userDao = new UserDao(); // 查询users表中是否存在请求的username和userPassword的一组数据 User user = userDao.login(loginUser); if (user == null) { // 不存在这组数据，登录失败。 // 将 request, response 传给 FailServlet.java request.getRequestDispatcher(\"/web/servlet/failServlet\").forward(request, response); } else { // 存在这组数据，登录成功 // 设置请求属性 'user':user request.setAttribute(\"username\", loginUser); // 将 request, response 传给 SuccessServlet.java request.getRequestDispatcher(\"/web/servlet/successServlet\").forward(request, response); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 编写login.html文件指定的servlet文件路径： 1&lt;form action=\"/RequestExample_war_exploded/web/servlet/loginServlet\" method=\"post\"&gt; 修改该行即可。 上面基本的实现已经完成，下面进行测试 测试 启动服务器，浏览器访问：http://localhost:8080/RequestExample_war_exploded/login.html 输入正确的用户名和密码： 数据表中的数据如下： 登录，跳转到页面：http://localhost:8080/RequestExample_war_exploded/web/servlet/loginServlet 如果输入的账号密码，在数据库中没有一组与之对应的用户数据，那么会跑出错误，且页面也会跳转到：http://localhost:8080/RequestExample_war_exploded/web/servlet/loginServlet 跳转后的页面： 参考文献 commons-logging.jar的作用 C3P0基本使用教程 Spring 5.0.0框架介绍_中文版_第二章 Spring JDBC 的简单使用","link":"/p/440223202005/"},{"title":"Vue 学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China 前言 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于事件循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台代码，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 认识VueVue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 ​ 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 尤雨溪，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。 node 和 npmNPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。 下载Node.js下载地址：https://nodejs.org/zh-cn/ 下载并安装，完成以后，在终端输入： 1node -v 看到版本信息： npmNode自带了NPM了，在控制台输入npm -v查看： npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 首先安装nrm 1) 配置淘宝镜像： 1npm config set registry https://registry.npm.taobao.org 2)配置完成后检验是否成功： 1npm config get registry 3)安装nrm，这里-g代表全局安装 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带 * 的就是当前选中的镜像仓库： 通过nrm use XXXXX来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 注意： 有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！","link":"/p/181501202009/"},{"title":"Vue 学习笔记2","text":"@Author: YiHua Lee @Address: Guangdong province, China 快速入门创建工程创建一个新的空工程： 然后新建一个module： 选中JavaScript，静态web项目： 位置信息： 安装vue下载安装下载地址：https://github.com/vuejs/vue 可以下载2.6.11版本 https://github.com/vuejs/vue/archive/v2.6.11.zip 下载解压，得到vue.js文件。 使用CDN或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 推荐npm安装在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录，先输入：npm init -y 进行初始化 安装Vue，输入命令：npm install vue --save --save 只争对当前目录下进行安装，即只有该项目可以使用。 然后就会在 HelloVue 目录发现一个 node_modules 目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 vue入门案例HTML模板 在HelloVue目录新建一个HTML： 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：XXX is a handsome boy!。前面的 XXX 是要渲染的数据。 vue声明式渲染通过Vue进行渲染： 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过的方式，来渲染刚刚定义的name属性。 打开页面查看效果： 更神奇的在于，当你在控制台（浏览器审查console）修改name属性时，页面会跟着变化： 双向绑定和事件处理对刚才的案例进行简单修改： 我们在data添加了新的属性：number 在页面中有一个input元素，通过v-model与number进行绑定。 同时通过在页面输出 用@click指令绑定点击事件，而不是普通的onclick，然后直接操作number 普通click是无法直接操作number的。 我们可以观察到，输入框的变化引起了data中的number的变化，同时页面输出也跟着变化。 input与number绑定，input的value值变化，影响到了data中的number值 页面与数据number绑定，因此number值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定和事件处理的魅力。 Vue实例创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue({ // 选项}) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el、data、methods 等等 模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过 el 属性来指定。 例如一段html模板： 123&lt;div id=\"app\"&gt; ......&lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue({ el:\"#app\"}) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"name\"/&gt;&lt;/div&gt; js: 123456var vm = new Vue({ el:\"#app\", data:{ name:\"Lee Hua\" }}) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。 html: 1234&lt;div id=\"app\"&gt; {{num}} &lt;button @click=\"add\"&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue({ el:\"#app\", data:{ num: 0 }, methods:{ add:function(){ // this代表的当前vue实例 this.num++; } }}) 生命周期钩子生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 钩子函数beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化时调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 created：在创建实例之后进行调用。 beforeMount：页面加载完成，没有渲染。 mounted：我们可以将他理解为原生 js 中的 window.onload=function({.,.})，或许大家也在用jquery，所以也可以理解为jquery中的 $(document).ready(function(){….})，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面已被渲染。 beforeDestroy：该函数将在销毁实例前进行调用 。 destroyed：该函数将在销毁实例时进行调用。 beforeUpdate：组件更新之前。 updated：组件更新之后。 例如：created代表在vue实例创建后： 我们可以在Vue中定义一个created函数，代表这个时期的钩子函数： 结果： this我们可以看下在vue内部的this变量是该 Vue 实例，下面我们在created的时候，打印this 这里打印出来的是当前vue对象 app 中的 number 数据，在初始化的时候 number 被 created 方法修改为 100，在 add 方法中，将该对象中的 number 数据自减 1 后输出。","link":"/p/201501202009/"},{"title":"Vue 学习笔记3","text":"@Author: YiHua Lee @Address: Guangdong province, China 指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 v-model刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型 &lt;input&gt; 和&lt;textarea&gt; 默认对应的model是字符串 &lt;select&gt;单选对应字符串，多选对应也是数组 效果： v-on基本用法v-on指令用于给页面元素绑定事件。 语法： 1234v-on:事件名=&quot;js片段或函数名&quot;缩写：@事件名=&quot;js片段或函数名&quot; 示例： 效果： 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡到父元素 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执行一次 阻止默认事件： 效果： 鼠标右击，增加一个 按钮阻止了默认事件（鼠标右击）。 鼠标右击，减少一个 没有阻止默认事件。 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 组合按钮可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; v-for遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 遍历数组 语法： 1v-for=\"item in items\" items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例 效果： 数组角标在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for=&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 对上一个例子进行简单修改： 效果： 遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for=\"value in object\"v-for=\"(value, key) in object\"v-for=\"(value, key, index) in object\" 1个参数时，得到的是对象的属性 2个参数时，第一个是属性，第二个是键 3个参数时，第三个是索引，从0开始 示例： 效果： key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 结果： 修改 2 和 3 的顺序： 结果： 使用了一个特殊语法：:key=&quot;&quot; ，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 v-if和v-show基本使用v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法 1v-if=\"布尔表达式\" 示例 效果 与v-for结合当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 v-for中添加v-if 效果 v-else 可以使用 v-else 指令来表示 v-if 的“else 块”： v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 效果 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 效果 v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例 效果 v-bindhtml属性不能使用双大括号形式绑定，只能使用v-bind指令。 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 示例 效果 绑定class样式 1) 数组语法 我们可以借助于v-bind指令来实现： 示例 渲染后的效果：（具有active和hasError的样式） 2) 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class=\"{ active: isActive }\"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。如下模板: 123&lt;div class=\"static\" v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"&gt;&lt;/div&gt; 和如下 data： 1234data: { isActive: true, hasError: false} 结果渲染为： 1&lt;div class=\"static active\"&gt;&lt;/div&gt; active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。 通常情况下，绑定的数据对象不必内联定义在模板里： 1&lt;div class=\"static\" v-bind:class=\"classObject\"&gt;&lt;/div&gt; 数据： 123456data: { classObject: { active: true, 'text-danger': false }} 效果和之前一样： 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 绑定style样式 1) 数组语法 数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 数据 1234data: { baseStyles: {'background-color': 'red'}, overridingStyles: {border: '1px solid black'}} 渲染后的结果： 1&lt;div style=\"background-color: red; border: 1px solid black;\"&gt;&lt;/div&gt; 2) 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt; 数据： 1234data: { activeColor: 'red', fontSize: 30} 效果： 1&lt;div style=\"color: red; font-size: 30px;\"&gt;&lt;/div&gt; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; 123456data: { styleObject: { color: 'red', fontSize: '13px' }} 效果同上。 简写v-bind:class可以简写为:class 计算属性在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:{ birthday:1529032123201 // 毫秒值} 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：{{ new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay() }}&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性，来替代复杂的表达式： 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 效果： 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要birthday还没有发生改变，多次访问 birthday 计算属性会立即返回之前的计算结果，而不必再次执行函数。 watch watch可以让我们监控一个值的变化。从而做出相应的反应。 示例 效果","link":"/p/551501202009/"},{"title":"Vue 学习笔记4","text":"@Author: YiHua Lee @Address: Guangdong province, China 组件化在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 全局组件我们通过Vue的component方法来定义一个全局组件。 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。 效果 组件的复用定义好的组件，可以任意复用多次： 123456&lt;div id=\"app\"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像这样直接提供一个对象： 123data: { count: 0} 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () { return { count: 0 }} 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 局部注册一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： 12345678const counter = { template: '&lt;button v-on:click=\"count++\"&gt;你点了我 &lt;span v-html=\"count\"&gt;&lt;/span&gt; 次，我记住了.&lt;/button&gt;', data() { return { count: 0 } }}; 然后在Vue中使用它： 1234567let app = new Vue({ el: \"#app\", components: { // 将定义的对象注册为组件 counter: counter }}) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象的属性 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 组件通信通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 props（父向子传递） 父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据） 子组件通过props接收父组件属性 父组件使用子组件，并自定义了title属性： 效果 props验证我们定义一个子组件，并接受复杂数据： 这个子组件可以对 items 进行迭代，并输出到页面。 props：定义需要从父组件中接收的属性 items：是要接收的属性名称 type：限定父组件传递来的必须是数组 default：默认值 required：是否必须 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 在父组件中使用它： 效果 type类型，可以有： 动态静态传递给 prop 传入一个静态的值： 1&lt;introduce title=\"大家好，我是Lee Hua\"&gt;&lt;/introduce&gt; 给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值） 1&lt;introduce :title=\"title\"&gt;&lt;/introduce&gt; 静态传递时，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 props。 123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=\"42\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=\"post.likes\"&gt;&lt;/blog-post&gt; 子向父的通信来看这样的一个案例： 子组件接收父组件的number属性 子组件定义点击按钮，点击后对number进行加或减操作 我们尝试运行，好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ 我们可以通过v-on指令将父组件的函数绑定到子组件上： 在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数： vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数 效果","link":"/p/571501202009/"},{"title":"Vue 学习笔记5","text":"@Author: YiHua Lee @Address: Guangdong province, China 路由vue-router场景模拟现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换。 编写父组件为了让接下来的功能比较清晰，我们先新建一个文件夹：src 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 样式： 编写登录及注册组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中，我们新建一个user目录以及 login.js 及 register.js ： 编写组件，这里我们只写模板，不写功能。 login.js内容如下： register.js内容如下： 在父组件中引用 效果 问题我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src=\"../node_modules/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 快速入门新建vue-router对象，并且指定路由规则： 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 页面跳转控制： 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html","link":"/p/591501202009/"},{"title":"Vue 学习笔记7","text":"@Author: YiHua Lee @Address: Guangdong province, China vue-cli介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令：sudo npm install -g vue-cli 快速上手1）创建一个module 2）切换到该目录 3）用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 开始初始化项目，并安装依赖 安装成功！可以使用npm run dev命令启动。 项目结构安装好的项目结构： 入口文件：main.js 单文件组件需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 运行先看看生成的package.json： 这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 执行npm run dev 或者 npm start 都可以启动项目： 页面： 参考文献 黑马 Java","link":"/p/021601202009/"},{"title":"Web服务器软件学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China web服务器软件 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 web服务器软件：接收用户的请求，处理请求，做出响应。 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 web容器 常见的java相关的web服务器软件： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范","link":"/p/241209202005/"},{"title":"Vue 学习笔记6","text":"@Author: YiHua Lee @Address: Guangdong province, China webpackWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 安装webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 安装最新版本webpack，输入命令：npm install --save-dev webpack webpack 4+ 版本，你还需要安装 cli ，输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 核心概念学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打 包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 编写webpack配置接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 入口entrywebpack打包的起点，可以有一个或多个，一般是js文件。 上面例子中新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js。 然后把原来index.html中的js代码全部移动到index.js中 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter) 这样，index.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports = { entry: './src/index.js' // 指定打包的入口文件} output 出口出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports = { entry: './src/index.js', // 指定打包的入口文件 output: { // path: 输出的目录 path : __dirname + '/dist', filename: 'build.js' // 输出的js文件名 }} 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 执行打包在控制台输入以下命令： 1npx webpack --config webpack.config.js 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 测试运行在index.html中引入刚刚生成的build.js文件， 然后运行： 打包CSS我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a{ display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;}#app a:hover{ background-color: whitesmoke; color: dodgerblue;}#app div{ width: 300px; height: 150px;}#app{ width: 305px; border: 1px solid dodgerblue;} 安装加载器前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 1npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： index.js引入css文件因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 配置加载器在webpack.config.js配置文件中配置css的加载器 12345678910111213141516171819module.exports = { entry: './src/index.js', // 指定打包的入口文件 output: { // path: 输出的目录 path : __dirname+ '/dist', filename: 'build.js' // 输出的js文件名 }, module: { rules: [ { test: /\\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] } ] }} 重新打包再次输入打包指令：npx webpack --config webpack.config.js 效果： script脚本我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是配置脚本的名称build 打包HTML之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 2）在webpack.config.js中添加插件： 3）将原来HTML中的引入js代码删除： 4）再次打包：npm run build 5）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 热更新的web服务刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件：npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123\"scripts\": { \"dev\": \"webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1\"}, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3） 运行脚本 npm run dev 4）效果","link":"/p/011601202009/"},{"title":"SpringCloud 学习笔记1","text":"@Author: YiHua Lee @Address: Guangdong province, China 系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务 服务治理（SOA） 能拆分的就拆分 是整体的,服务能放一起的都放一起 纵向业务划分 是水平分多层 由单一组织负责 按层级划分不同部门的组织负责 细粒度 粗粒度 两句话可以解释明白 儿百字只相当于SOA的目录 独立的子公司 类似大公司里面划分了一些业务单元(BU) 组件小 存在较复杂的组件 业务逻辑存在于每一个服务中 业务逻辑横跨多个业务领域 使用轻量级的通信方式,如HTTP 企业服务产总线(ESB)充当了服务之间通信的角色 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC ：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http ：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 认识RPC通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 1）采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 2）数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC 认识HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection HttpClient介绍 HttpClient是Apache公司的产品，是Http Components下的一个组件。 特点： 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） 支持HTTPS协议。 通过Http代理建立透明的连接。 自动处理Set-Cookie中的Cookie。 使用创建一个工程，名字为：http-demo 配置 pom.xml 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 编写 SpringBoot 启动类： 12345678@SpringBootApplicationpublic class HttpDemoApplication { public static void main(String[] args) { SpringApplication.run(HttpDemoApplication.class, args); }} 发起get请求： 123456@Testpublic void testGet() throws IOException { HttpGet request = new HttpGet(\"http://www.baidu.com\"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);} 发起Post请求： 12345678@Testpublic void testPost() throws IOException { HttpGet request = new HttpGet(\"http://www.oschina.net/\"); request.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);} 假如有如下一个链接 http://localhost/hello，即自己的另外一个项目，我们能否通过该链接获取另一个项目的响应结果呢？答案是可以的。如： http://localhost/hello 返回的是一个 User 对象 123456@Testpublic void testGetPojo() throws IOException { HttpGet request = new HttpGet(\"http://localhost/hello\"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);} 我们实际得到的是一个json字符串： 123456789101112{ \"id\":13, \"userName\":\"LeeHua\", \"password\":\"123456\", \"name\":\"李华\", \"age\":21, \"sex\":1, \"birthday\":\"1998-10-24T16:00:00.000+0000\", \"created\":\"2018-08-30T16:00:00.000+0000\", \"updated\":\"2020-09-03T16:00:00.000+0000\", \"note\":\"测试\"} 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 Json转换工具HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理。 对象转json将 User 对象 转化为 Json 字符串 123456789101112131415// json处理工具private ObjectMapper mapper = new ObjectMapper();// User 对象private User user = new User();@Testpublic void testJson() throws JsonProcessingException { User user = new User(); user.setId(13L); user.setAge(21); user.setName(\"李华\"); user.setUserName(\"LeeHua\"); // 序列化 String json = mapper.writeValueAsString(user); System.out.println(\"json = \" + json);} 结果： 1json = {\"id\":13,\"userName\":\"LeeHua\",\"password\":null,\"name\":\"李华\",\"age\":21,\"sex\":null,\"birthday\":null,\"created\":null,\"updated\":null,\"note\":null} json转普通对象将 Json 字符串 转化为 User 对象 12345678910111213141516// json处理工具private ObjectMapper mapper = new ObjectMapper();// User 对象private User user = new User();@Testpublic void testJsonToObject() throws IOException { user.setId(13L); user.setAge(21); user.setName(\"李华\"); user.setUserName(\"LeeHua\"); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 User result = mapper.readValue(json, User.class); System.out.println(\"Object = \" + result);} 结果： 1Object = User [id=13, userName=LeeHua, password=null, name=李华, age=21, sex=null, birthday=null, created=null, updated=null, note=null] json转集合json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： 123456789101112131415161718192021// json处理工具private ObjectMapper mapper = new ObjectMapper();// User 对象private User user = new User();@Testpublic void testJson() throws IOException { user.setId(13L); user.setAge(21); user.setName(\"李华\"); user.setUserName(\"LeeHua\"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class)); for (User u : users) { System.out.println(\"u = \" + u); } System.out.println(users);} 结果： json转任意复杂类型当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 12345678910111213141516@Testpublic void testJsonToType() throws IOException { user.setId(13L); user.setAge(21); user.setName(\"李华\"); user.setUserName(\"LeeHua\"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;(){}); for (User u : users) { System.out.println(\"u = \" + u); }} 结果： Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication { public static void main(String[] args) { SpringApplication.run(HttpDemoApplication.class, args); } @Bean public RestTemplate restTemplate() { // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); }} 在测试类中直接@Autowired注入： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests { @Autowired private RestTemplate restTemplate; @Test public void httpGet() { User user = this.restTemplate.getForObject(\"http://localhost/hello\", User.class); System.out.println(user); }} 通过 RestTemplate 的 getForObject() 方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 初始SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 SpringCloud 简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 以上只是其中一部分，架构图： SpringCloud 版本SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 以Finchley版本为例： 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 微服务场景模拟首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 服务提供者我们新建一个项目，对外提供查询用户的服务。 创建父工程 父工程中引入依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;packaging&gt;pom&lt;/packaging&gt;&lt;name&gt;SpringCloudDemo&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR1&lt;/spring-cloud.version&gt; &lt;mapper.starter.version&gt;2.0.3&lt;/mapper.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.5&lt;/pageHelper.starter.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mapper.starter.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 创建一个 Module进入父工程，创建一个子工程： 选择 Maven 工程： 填写 Module 信息： 注意：子工程目录在父工程的目录下 这个时候父工程 pom.xml 配置文件会自动引入如下内容： 123&lt;modules&gt; &lt;module&gt;UserService&lt;/module&gt;&lt;/modules&gt; 子工程依赖： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;SpringCloudDemo&lt;/artifactId&gt; &lt;groupId&gt;pers.stringbug&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;UserService&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写代码属性文件，采用 yaml 语法，而不是 properties： 123456789101112server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/Test username: root password: 123456 hikari: maximum-pool-size: 20 minimum-idle: 10mybatis: type-aliases-package: pers.stringbug.userservice.pojo 启动类： 1234567@SpringBootApplication@MapperScan(value = \"pers.stringbug.userservice.mapper\")public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class); }} User 实体类： 12345678910111213141516171819202122232425262728@Table(name = \"tb_user\")@Datapublic class User implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; /** 用户名 */ private String userName; /** 密码 */ private String password; /** 姓名 */ private String name; /** 年龄 */ private Integer age; /** 性别，1男性，2女性 */ private Integer sex; /** 出生日期 */ private Date birthday; /** 创建时间 */ private Date created; /** 更新时间 */ private Date updated; /** 备注 */ private String note;} mapper： 123456import org.apache.ibatis.annotations.Mapper;import pers.stringbug.userservice.pojo.User;@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;{} 添加一个对外查询的接口： 123456789101112@RestController@RequestMapping(\"user\")public class UserController { @Autowired private UserService userService; @GetMapping(\"/{id}\") public User queryById(@PathVariable(\"id\") Long id) { return userService.queryById(id); }} 项目结构： 启动并测试启动项目，访问接口：http://localhost:8081/user/13 服务器调用者创建工程与上面创建子工程类似，这里也创建一个 Maven 工程，名字为 ConsumerDemo 子工程 ConsumerDemo 引入依赖： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写代码创建启动类，并在启动类中注册 RestTemplate ： 123456789101112@SpringBootApplicationpublic class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class); } @Bean public RestTemplate restTemplate() { return new RestTemplate(); }} User 实体类： 12345678910111213141516171819202122@Datapublic class User implements Serializable { private Long id; /** 用户名 */ private String userName; /** 密码 */ private String password; /** 姓名 */ private String name; /** 年龄 */ private Integer age; /** 性别，1男性，2女性 */ private Integer sex; /** 出生日期 */ private Date birthday; /** 创建时间 */ private Date created; /** 更新时间 */ private Date updated; /** 备注 */ private String note;} 编写 controller，直接在 controller 中调用 RestTemplate，远程访问 UserService 的服务接口： 123456789101112131415/** 对外查询的接口 */@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; @GetMapping(\"{id}\") public User queryById(@PathVariable(value = \"id\") Long id) { String url = \"http://localhost:8081/user/\" + id; User user = restTemplate.getForObject(url, User.class); return user; }} 启动测试因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume/13 一个简单的远程服务调用案例就实现了。 项目目录该子项目的目录结构如下： 有没有问题？简单回顾一下，刚才我们写了什么： UseService：一个提供根据id查询用户的微服务 ConsumerDemo：一个服务调用者，通过RestTemplate远程调用UseService 流程如下： ![1525595012668](/Users/liyihua/Desktop/09 黑马乐优商城/乐优商城《项目笔记》/day02笔记/assets/1525595012668.png) 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer 需要记忆 UseService 的地址，如果出现变更，可能得不到通知，地址将失效 consumer 不清楚 UseService 的状态，服务宕机也不知道 UseService 只有1台服务，不具备高可用性 即便 UseService 形成集群，consumer 还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 Eureka注册中心认识Eureka首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，UserService对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务。 Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 原理图 Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 入门案例创建工程在上面创建的父项目 SpringCloudDemo 的基础上，再创建一个子项目：EurekaServer 引入依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这里本来可以不用配置版本的，因为父工程已经指定了版本信息了，不过这里因为找不到，所以就制定了版本信息。 编写代码该子工程的相关配置：application.yaml 12345678910111213141516server: port: 8082spring: application: # 应用名称，会在Eureka中显示 name: eureka-servereureka: client: service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:8082/eureka instance: # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 prefer-ip-address: true # 指定自己的ip信息，不指定的话会自己寻找。假如开启了网络，实例地址会变成外网地址（如：192.168.0.102） ip-address: 127.0.0.1 创建启动类，并启动 Eureka 服务： 1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaServer { public static void main(String[] args) { SpringApplication.run(EurekaServer.class); }} 启动并测试启动服务，访问 http://127.0.0.1:8082 ，查看 Eureka 相关信息： 将 UserService 注册到 Eureka注册服务，就是在服务上添加 Eureka 的客户端依赖，客户端代码会自动把服务注册到 EurekaServer 中。 在 UserService 中添加Eureka客户端： 123456&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在 UserService 启动类上开启Eureka客户端功能： 通过添加 @EnableEurekaClient 来开启 Eureka 客户端功能 12345678@EnableEurekaClient@SpringBootApplication@MapperScan(value = \"pers.stringbug.userservice.mapper\")public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class); }} 不过建议使用 @EnableDiscoveryClient 来开启 Eureka 客户端功能，因为 @EnableEurekaClient 只支持开启 Eureka 客户端功能，假如我们以后更换了其他注册中心呢？这个 @EnableEurekaClient 就失效了，所以推荐使用 @EnableDiscoveryClient ，它支持的注册中心比较多。 12345678@EnableDiscoveryClient@SpringBootApplication@MapperScan(value = \"pers.stringbug.userservice.mapper\")public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class); }} 编写 UserService 的配置：application.yaml 123456789101112131415161718192021server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/Test username: root password: 123456 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: pers.stringbug.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:8082/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问 Eureka监控页面(http://127.0.0.1:8082/) 查看 将 ConsumerDemo 注册到 Eureka接下来我们修改ConsumerDemo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 在 ConsumerDemo 中添加Eureka客户端： 123456&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在 ConsumerDemo 启动类开启Eureka客户端 1234567891011@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class); } @Bean public RestTemplate restTemplate() { return new RestTemplate(); }} 编写 ConsumerDemo 的配置：application.yaml 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:8082/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 修改代码，用 DiscoveryClient类 的方法，根据服务名称，获取服务实例： 1234567891011121314151617181920212223/** 对外查询的接口 */@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; @GetMapping(\"{id}\") public User queryById(@PathVariable(value = \"id\") Long id) { // 根据服务 ID 获取实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"user-service\"); // 从实例中取出 IP 和端口 ServiceInstance serviceInstance = instances.get(0); String hostAndPort = serviceInstance.getHost() + \":\" + serviceInstance.getPort(); String url = \"http://\" + hostAndPort + \"/user/\" + id; User user = restTemplate.getForObject(url, User.class); return user; }} 重新启动 UserService、Consumer、EurekaServer，访问结果： Eureka详解Eureka的原理及配置。 基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能。 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。 高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 假设要搭建两条EurekaServer的集群，端口分别为： 8082 和 8083 1) 修改原来的EurekaServer配置： 1234567891011121314151617server: port: 8082spring: application: # 应用名称，会在Eureka中显示 name: eureka-servereureka: client: service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 # 配置其他Eureka服务的地址，而不是自己，比如8083 defaultZone: http://127.0.0.1:8083/eureka instance: # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 prefer-ip-address: true # 指定自己的ip信息，不指定的话会自己寻找。假如开启了网络，实例地址会变成外网地址（如：192.168.0.102） ip-address: 127.0.0.1 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会把自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2) 另外一台配置恰好相反： 1234567891011121314151617server: port: 8083spring: application: # 应用名称，会在Eureka中显示 name: eureka-servereureka: client: service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 # 配置其他Eureka服务的地址，而不是自己，比如8082 defaultZone: http://127.0.0.1:8082/eureka instance: # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 prefer-ip-address: true # 指定自己的ip信息，不指定的话会自己寻找。假如开启了网络，实例地址会变成外网地址（如：192.168.0.102） ip-address: 127.0.0.1 idea中一个应用不能启动两次，我们需要重新配置一个启动器： 复制 EurekaServer 启动器，复制出的 Eureka 命名为 EurekaServer2 ： 说明：启动 EurekaServer 的时候，application.yaml 配置如 1) 中的所示，等 EurekaServer 启动完成后，再将 application.yaml 中的配置修改为 2) 中所示的，然后再启动 EurekaServer2 。 3）启动测试： 4) 客户端注册服务到 Eureka 集群 上面已经完成了 Eureka 集群的启动，EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 服务提供者（如：UserService）、服务调用者（如：ConsumerDemo）都需要修改 eureka 配置： 1234eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:8082/eureka, http://127.0.0.1:8083/eureka 服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： UP(1)：代表现在是启动了1个示例，没有集群 192.168.0.101:user-service:8081 是示例的名称（instance-id） 默认格式是：${hostname} + ${spring.application.name} + ${server.port} instance-id 是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： 123eureka: instance: instance-id: ${spring.application.name}:${server.port} 重启服务再试试看： 服务消费者 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 失效剔除和自我保护 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 负载均衡Robbin在上面的案例中，我们启动了一个 UserService，启动了一个 ConsumerDemo，然后通过ConsumerDemo使用DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个 UserService 的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 下面，使用Ribbon实现负载均衡。 启动两个服务实例首先我们启动两个 UserService 实例，一个8081，一个8084。 复制 UserApplication 启动实例，命名为 UserApplication2，端口号设置为 8084： 1-Dserver.port=8084 Eureka监控面板： 开启负载均衡器在服务消费者（ConsumerDemo）中添加 Robbin 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 方式1编写 ConsumerDemo 对外查询的接口： 12345678910111213141516171819@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; @Autowired private RibbonLoadBalancerClient balancerClient; @GetMapping(\"{id}\") public User queryById(@PathVariable(value = \"id\") Long id) { ServiceInstance serviceInstance = balancerClient.choose(\"user-service\"); String hostAndPort = serviceInstance.getHost() + \":\" + serviceInstance.getPort(); String url = \"http://\" + hostAndPort + \"/user/\" + id; User user = restTemplate.getForObject(url, User.class); return user; }} RibbonLoadBalancerClient 可以帮我们自动的实现负载均衡。 方式2在启动类注册的 RestTemplate 中添加 @LoadBalanced 注解： 1234567891011121314@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class); } @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); }} 编写 ConsumerDemo 对外查询的接口，修改请求路径： 1234567891011121314@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; @GetMapping(\"{id}\") public User queryById(@PathVariable(value = \"id\") Long id) { String url = \"http://user-service/user/\" + id; User user = restTemplate.getForObject(url, User.class); return user; }} 启动启动 EurekaServer、UserService、UserService2、ConsumerDemo，访问页面，查询结果： 方式 2 源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有类帮我们实现了根据service名称，获服务实例的ip和端口。它就是LoadBalancerInterceptor 进行源码跟踪： 继续跟入 this.loadBalancer.execute 方法：发现获取了8081端口的服务 实质上，该方法获取了我们启动的所有服务，这里启动了 8081、8084 两个端口的服务，只是上面取的是 8081 端口的服务，下次再次获取服务，可能会获取到 8084 端口的服务。 下面为部分获取信息： LoadBaLancer: &quot;DynamicServerL istLoadBalancer: {NFLoadBalancer: name=user-service, current list of Servers=[127.0.0.1:8081， 127.0.0.1:8084] 负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest { @Autowired RibbonLoadBalancerClient client; @Test public void test(){ for (int i = 0; i &lt; 100; i++) { ServiceInstance instance = this.client.choose(\"user-service\"); System.out.println(instance.getHost() + \":\" + instance.getPort()); } }} 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： 123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： 重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个UserService实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： 123456789101112spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启 ConsumerDemo，测试，发现即使 UserService2 宕机，也能通过另一台服务实例获取到结果！ 参考文献 黑马 Java","link":"/p/211319202008/"},{"title":"XPath 的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China XPathXPath是一门在XML文档中查找信息的语言，它提供了非常简洁明了的路径选择表达式。| 表达式 | 描 述 || ——– | ———————— || nodename | 选取此节点的所有子节点 || / | 从当前节点选取直接子节点 || // | 从当前节点选取子孙节点 || . | 选取当前节点 || .. | 选取当前节点的父节点 || @ | 选取属性 | 举例1： 1//title[@lang='eng'] 它代表选择所有名称为title，同时属性lang的值为eng的节点 举例2：处理HTML文本 12345678910111213141516171819from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser()) # 直接对html文本进行解析result = etree.tostring(html)print(result.decode('utf-8'))# 输出：&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\"&gt;&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 举例3：获取子结点 用 // 开头的XPath规则来选取所有符合要求的节点 1234567from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//*')print(result)# 输出：[&lt;Element html at 0x112829bc8&gt;, &lt;Element body at 0x112829d08&gt;, &lt;Element div at 0x112829d48&gt;, &lt;Element ul at 0x112829d88&gt;, &lt;Element li at 0x112829dc8&gt;, &lt;Element a at 0x112829e48&gt;, &lt;Element li at 0x112829e88&gt;, &lt;Element a at 0x112829ec8&gt;, &lt;Element li at 0x112829f08&gt;, &lt;Element a at 0x112829e08&gt;, &lt;Element li at 0x112fc21c8&gt;, &lt;Element a at 0x112fc2208&gt;, &lt;Element li at 0x112fc2248&gt;, &lt;Element a at 0x112fc2288&gt;] XPath 获取父结点12345678from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//a[@href=\"link4.html\"]/../@class')# result = html.xpath('//a[@href=\"link4.html\"]/parent::*/@class)print(result)# 输出：['item-1'] XPath 属性匹配1234567from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class=\"item-0\"]')print(result)# 输出：[&lt;Element li at 0x115357d08&gt;] XPath 文本获取 方式一 1234567from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class=\"item-0\"]/a/text()')print(result)# 输出：['fifth item'] 方式二 1234567from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class=\"item-0\"]//text()')print(result)# 输出：['fifth item', '\\n'] XPath 属性获取12345678from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())# 用@可以获取属性result = html.xpath('//li/a/@href')print(result)# 输出：['linkl.html', 'link2.html', 'link3.html', 'link4.html', 'link5.html'] XPath 属性多值匹配有些属性可能有多个值，那么要匹配这些属性，则需要用到contains()函数 12345678910111213from lxml import etree# 这里的HTML文本中的li节点的class属性有两个值li和li-firsttext = '''&lt;li class=\"li li-first\"&gt;&lt;a href=\"link.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)# 获取text中的所有li节点中class属性是li的文本result = html.xpath('//li[contains(@class, \"li\")]/a/text()')print(result)# 输出：['first item'] XPath 多属性值匹配12345678910from lxml import etreetext = '''&lt;li class=\"li li-first\" name=\"item\"&gt;&lt;a href=\"link.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class, \"li\") and @name=\"item\"]/a/text()')print(result)# 输出：['first item'] XPath 顺序选择1234567891011121314151617181920212223242526from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=&quot;item-O&quot;&gt;&lt;a href=&quot;linkl.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result1 = html.xpath('//li[1]/a/text()') # 选取第一个li节点result2 = html.xpath('//li[last()]/a/text()') # 选取最后一个li节点result3 = html.xpath('//li[position()&lt;3]/a/text()') # 选取位置小于3的li节点result4 = html.xpath('//li[last()-2]/a/text()') # 选取倒数第3个li节点print(result1, result2, result3, result4, sep='\\n')# 输出：['first item']['fifth item']['first item', 'second item']['third item'] XPath 结点轴选择结点轴有：ancestor轴、attribute轴、child轴、descendant轴、following轴、following-sibling轴 等 123456789101112131415161718192021222324252627282930313233from lxml import etreetext = '''&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;&lt;span&gt;first item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/ul&gt;&lt;/div&gt;'''14 html = etree.HTML(text)15 result1 = html.xpath('//li[1]/ancestor::*') # 获取第1个li节点的所有祖先节点result2 = html.xpath('//li[1]/ancestor::div') # 获取第1个li节点的这个祖先节点result3 = html.xpath('//li[1]/attribute::*') # 获取第1个li节点的所有属性值result4 = html.xpath('//li[1]/child::a[@href=\"link.html\"]') # 获取所有（href属性值为link.html的a节点）直接子节点result5 = html.xpath('//li[1]/descendant::span') # 获取所有子孙节点（获取span节点）result6 = html.xpath('//li[1]/following::*[2]') # 获取当前节点之后的第2个捷点result7 = html.xpath('//li[1]/following-sibling::*') # 获取当前节点之后的所有同级节点print(result1, result2, result3, result4, result5, result6, result7, sep='\\n')# 输出：[&lt;Element html at 0x102e9f088&gt;, &lt;Element body at 0x10350fe08&gt;, &lt;Element div at 0x10350fd88&gt;, &lt;Element ul at 0x10350fd08&gt;][&lt;Element div at 0x10350fd88&gt;]['item-O'][][&lt;Element span at 0x10350fec8&gt;][&lt;Element a at 0x10350fe88&gt;][&lt;Element li at 0x10350ff48&gt;, &lt;Element li at 0x10350ff88&gt;, &lt;Element li at 0x10350ffc8&gt;, &lt;Element li at 0x111ba0048&gt;] 运算符及其介绍 运算符 描 述 实。例 返回值 or 或 price=9.80 or price=9.70 如果 price 是 9.80，则返回 true。如果 price 是 9.50，则返回 false。 and 与 price&gt;9.00 and price&lt;9.90 如果 price 是 9.80，则返回 true。如果 price 是 8.50，则返回 false。 mod 计算除法的余数 5 mod 2 1 | 计算两个节点集 //book | //cd 返回所有拥有 book 和 cd 元素的节点集 + 加法 6 + 6 12 - 减法 6 - 6 0 * 乘法 6 * 6 36 div 除法 6 div 6 1 = 等于 price=9.80 如果 price 是 9.80，则返回 true。如果 price 不是 9.90，则返回 false。 != 不等于 price!=9.80 如果 price 不是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &lt; 小于 age&lt;20 如果 age 小于 20，则返回 true。如果 age 不小于 20，则返回 false。 &lt;= 小于等于 age&lt;=20 如果 age 小于等于 20，则返回 true。如果 age 大于 20，则返回 false &gt; 大于 age&gt;20 如果 age 大于 20，则返回 true。如果 age 不大于 20，则返回 false &gt;= 大于等于 age&gt;=20 如果 age 大于等于 20，则返回 true。如果 age 小于 20，则返回 false","link":"/p/301030202004/"},{"title":"YouTube 详细统计信息详解","text":"@Author: YiHua Lee @Address: Guangdong province, China Video ID / sCPN ：每个视频独特的、独有的ID / 用于识别问题的字符串（开发人员适用） Viewport / Frames：当前播放窗口的分辨率 / 视频帧数的变化情况（由于主机性能的原因导致的丢帧数） Current / Optimal Res：视频的解析度 / 最佳解析度 Volume / Normalized：当前音量百分比 / 实际输出音量百分比（与YouTube标准音量的响度差距） Codecs：视频类型 / 格式 Color：视频色域 Host：为您推播流媒体的YouTube服务器主机名 Connection Speed：视频的加载速度，也就是大家常参考的数字，这个数字并不是很准确，由于YouTube使用的是小数据包、高频发送次数的调度方案，所以在延迟服务器上这个数字会很大。高延迟速率的链接速率是明显偏小的。（状态条为蓝色，加载无压力） Network Activity：网络连接速度（状态条为蓝色，连接无压力。已经缓存完全后，为黑色） Buffer Health：已缓存的视频时长（假如断开网络，我们还能观看的时长） Mystery Text：字母“ s”后的数字代表播放器的状态代码（例如：s:4 –&gt; video paused） 最后说一下Kpbs单位的转换： Mbps —-&gt; Milionbit pro second(百万位每秒) Kbps —-&gt; Kilobit pro second（千位每秒） bps —-&gt; bit pro second（位每秒） bit —-&gt; 通常用 b 表示 MB —-&gt; 百万字节（兆字节） KB —-&gt; 千字节 B —-&gt; 字节 1 Mbps = 1000 Kbps 1 Kbps = 1000 bps 1 MB = 1024 KB 1 KB = 1024 B 1 B = 8 b —-&gt; B表示字节、b表示位每秒 例如： 70000 Kbps = (70000 * 1000) bps = 70000000 bps 70000000 bps = (70000000 / 8) B = 8750000 B 8750000 B = (8750000 / 1024) KB = 8545 KB 8545 KB = 8.345 MB 也就是说，70000 Kbps 约等于 8.345 MB","link":"/p/480819202006/"},{"title":"Hello World","text":"@Author: YiHua Lee @Address: Guangdong province, China Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/p/401230202004/"},{"title":"java.util.stream.Stream 接口中的常用方法","text":"@Author: YiHua Lee @Address: Guangdong province, China 流模型的操作很丰富，下面介绍一些常用的API。这些方法可以被分成两种： 延迟方法 返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。(除了终结方法外，其余方 法均为延迟方法。) 终结方法 返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。在这里介绍的终结方法包括 count 和 forEach 方法。 逐一处理：forEach虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。 1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 12java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。 基本使用： 12345678910import java.util.stream.Stream;public class Demo06ForEach { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(\"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); stream.forEach(name-&gt; System.out.println(name)); }} 这里调用的of()方法，方法签名： 1234@SafeVarargspublic static&lt;T&gt; Stream&lt;T&gt; of(T... values) { return Arrays.stream(values);} 过滤：filter可以通过 filter 方法将一个流转换成另一个子集流。方法签名： 1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个 Predicate 函数式接口参数(可以是一个Lambda或方法引用)作为筛选条件。 java.util.stream.Predicate 接口是一个函数式接口，其中唯一的抽象方法为： 1boolean test(T t); 该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法将会留用元素;如果结果为false，那么 filter 方法将会舍弃元素。 基本使用Stream流中的 filter 方法基本使用的代码如： 123456789import java.util.stream.Stream;public class Demo07StreamFilter { public static void main(String[] args) { Stream&lt;String&gt; original = Stream.of(\"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); Stream&lt;String&gt; result = original.filter(s -&gt; s.length() &gt;= 5); result.forEach(System.out::println); }} 运行程序，控制台输出： 123PythonHadoopSpark 这个例子中，通过Lambda表达式来指定了筛选的条件：字符串的长度要大于等于5。 映射：map如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名： 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 java.util.stream.Function 接口是一个函数式接口，其中唯一的抽象方法为： 1R apply(T t); 这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 基本使用Stream流中的 map 方法基本使用的代码如： 123456789import java.util.stream.Stream;public class Demo08StreamMap { public static void main(String[] args) { Stream&lt;String&gt; original = Stream.of(\"100\", \"200\", \"300\"); Stream&lt;Integer&gt; result = original.map(str -&gt; Integer.parseInt(str)); result.forEach(System.out::println); }} 运行程序，控制台输出： 123100200300 这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型(并自动装箱为 Integer 类对象)。然后调用Stream接口中的forEach方法，逐一输出结果。 统计个数：count正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数： 1long count(); 该方法返回一个long值代表元素个数(不再像旧集合那样是int值)。 基本使用123456789import java.util.stream.Stream;public class Demo09StreamCount { public static void main(String[] args) { Stream&lt;String&gt; original = Stream.of(\"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); Stream&lt;String&gt; result = original.filter(s -&gt; s.length() &gt;= 5); System.out.println(result.count()); }} 运行程序，控制台输出： 13 取用前几个：limitlimit 方法可以对流进行截取，只取用前n个。方法签名： 1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取;否则不进行操作。 基本使用123456789import java.util.stream.Stream;public class Demo10StreamLimit { public static void main(String[] args) { Stream&lt;String&gt; original = Stream.of(\"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); Stream&lt;String&gt; result = original.limit(3); result.forEach(System.out::println); }} 运行程序，控制台输出： 123JavaCPython 跳过前几个：skip如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流： 1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个;否则将会得到一个长度为0的空流。 基本使用123456789import java.util.stream.Stream;public class Demo11StreamSkip { public static void main(String[] args) { Stream&lt;String&gt; original = Stream.of(\"Java\", \"C\", \"Python\", \"Hadoop\", \"Spark\"); Stream&lt;String&gt; result = original.skip(3); result.forEach(System.out::println); }} 运行程序，控制台输出： 12HadoopSpark 组合：concat如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat： 12static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。 基本使用12345678910import java.util.stream.Stream;public class Demo12StreamConcat { public static void main(String[] args) { Stream&lt;String&gt; original1 = Stream.of(\"Java\", \"C\", \"Python\"); Stream&lt;String&gt; original2 = Stream.of(\"Hadoop\", \"Spark\"); Stream&lt;String&gt; result = Stream.concat(original1, original2); result.forEach(System.out::println); }} 运行程序，控制台输出： 12345JavaCPythonHadoopSpark Stream 接口中的常用方法就介绍到这里，为了加深理解，可以看一下使用Stream方式完成的简单练习。","link":"/p/311404202005/"},{"title":"SpringCloud 学习笔记2","text":"@Author: YiHua Lee @Address: Guangdong province, China 续：SpringCloud 学习笔记1 Hystrix简介Hystix，即熔断器。主页：https://github.com/Netflix/Hystrix/ ， 已经停更两年多了。 Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 熔断器的工作机制 正常工作的情况下，客户端请求调用服务API接口： 当有服务出现异常时，直接进行失败回滚，服务降级处理： 当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 动手实践改造服务消费者引入依赖首先在服务消费者 ConsumerDemo 中引入Hystix依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 开启熔断在 ConsumerDemo 的启动类上面，添加 @EnableCircuitBreaker 注释，开启熔断： 123456789101112131415@EnableCircuitBreaker@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class); } @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); }} 也可以使用 @SpringCloudApplication 注解，来代替 @EnableCircuitBreaker、@SpringBootApplication 和 @EnableDiscoveryClient 注解，下面是 `` 注解的源码： 编写降级逻辑当目标服务的调用出现故障，我们需要快速解决，给用户一个友好提示。因此需要提前编写好，失败时的降级处理逻辑，要使用 @HystixCommond 注解来完成。 改造 ConsumerController ，在用来访问的 User 服务的方法中声明一个失败时的回滚处理函数： 1234567891011121314151617181920212223@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(ConsumerController.class); @HystrixCommand(fallbackMethod = \"queryByIdFallback\") @GetMapping(\"{id}\") public String queryById(@PathVariable(value = \"id\") Long id) { String url = \"http://user-service/user/\" + id; User user = restTemplate.getForObject(url, User.class); assert user != null; return user.toString(); } public String queryByIdFallback(Long id) { logger.error(\"查询用户信息失败，id: {}\", id); return \"不好意思，服务器正忙！\"; }} 注意：因为熔断的降级逻辑方法必须和正常逻辑方法的有相同的参数列表和返回值声明。如这里的熔断降级逻辑方法和政策逻辑方法的参数列表都只有一个 Long 类型的数据，返回值都是 String 类型的数据。 说明： @HystrixCommand ：该注释用于指定一些方法，这些方法作为 hystrix 命令进行处理。 fallbackMethod ：该成员变量用于指定一个降级逻辑的方法。 超时时间默认是1000毫秒。 改造服务提供者改造服务提供者，随机休眠一段时间，以触发熔断： 123456789101112131415@Servicepublic class UserService { @Autowired private UserMapper userMapper; public User queryById(Long id) { // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 try { Thread.sleep(new Random().nextInt(2000)); } catch (InterruptedException e) { e.printStackTrace(); } return userMapper.selectByPrimaryKey(id); }} 启动测试启动 EurekaServer（注册服务）、UserService、ConsumerDemo，通过服务消费者 ConsumerDemo 调用服务提供者 UserService，UserService 提供的服务随机休眠0-2000毫秒： 调用服务： 查询失败： 查询成功： 优化虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: ​ 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 配置文件中设置： 1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms 方法中的设置： 123456789101112@HystrixCommand(commandProperties = @HystrixProperty( name = \"hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds\", value = \"6000\"))@GetMapping(\"{id}\")public String queryById(@PathVariable(value = \"id\") Long id) { String url = \"http://user-service/user/\" + id; User user = restTemplate.getForObject(url, User.class); assert user != null; return user.toString();} 在编写降级逻辑的时候，我们也可以使用 @DefaultProperties 注解，来指定降级逻辑的方法，该注解和 @HystrixCommand 注解不同，@DefaultProperties 注解在类上使用，类中所有的方法都可以开启剪辑逻辑（用@HystrixCommand 注解开启），@HystrixCommand 注解在方法上使用，只能是对应的某个方法使用降级逻辑： 1234567891011121314151617181920212223@DefaultProperties(fallbackMethod = \"defaultFallback\")@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(ConsumerController.class); @HystrixCommand // 该方法开启降级逻辑 @GetMapping(\"{id}\") public String queryById(@PathVariable(value = \"id\") Long id) { String url = \"http://user-service/user/\" + id; User user = restTemplate.getForObject(url, User.class); assert user != null; return user.toString(); } public String defaultFallback() { return \"不好意思，服务器正忙！\"; }} 熔断服务熔断原理熔断器也叫断路器，其英文名为 Circuit Breaker 状态机有三个状态： Closed：关闭状态（断路器关闭），所有请求都正常访问。 Open：打开状态（断路器打开），所有请求都会被降级。Hystrix 会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，默认失败比例的阈值是 50% ，请求次数最少不低于20次。 Half Open：半开状态，Closed 状态不是永久的，关闭后会进入休眠时间（默认是5秒），随后熔断器后自动进入半开状态。此时释放部分请求通过，若这些请求都是健康的，则会完全打开断路器，否则继续保持关闭，再次进入休眠计时。 动手实践为了能够精准的控制请求的成功或失败，服务消费者的调用业务中添加一段逻辑： 在 ConsumerDemo 例子中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestController@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; private static final Logger logger = LoggerFactory.getLogger(ConsumerController.class); @HystrixCommand( commandProperties = { @HystrixProperty( // 熔断器请求阈值次数 10 次。 name = \"circuitBreaker.requestVolumeThreshold\", value = \"10\" ), @HystrixProperty( // 熔断器关闭状态时，休眠计时时间（毫秒为单位）。 name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\" ), @HystrixProperty( // 失败请求百分比，单失败请求百分比达到60%时，熔断器打开。 name = \"circuitBreaker.errorThresholdPercentage\", value = \"60\" ) }, fallbackMethod = \"queryByIdFallback\" ) @GetMapping(\"{id}\") public String queryById(@PathVariable(value = \"id\") Long id) { /* 这个方法中可以添加一些逻辑，来判断访问 */ // 例如，随便写个逻辑 // if (id == 1) { // throw new RuntimeException(\"不好意思，服务器正忙！\") // } String url = \"http://user-service/user/\" + id; User user = restTemplate.getForObject(url, User.class); assert user != null; return user.toString(); } public String queryByIdFallback(Long id) { logger.error(\"查询用户信息失败，id: {}\", id); return \"不好意思，服务器正忙！\"; }} 说明： commandProperties 参数：对于注解 @HystrixCommand 中指定的方法，配置一些数据。 @HystrixProperty 注解：指定要被修改的变量。 requestVolumeThreshold ： 触发熔断的最小次数（默认是20次） sleepWindowInMilliseconds ： 触发熔断的失败请求最小占比（默认为 50%） errorThresholdPercentage ： 休眠时常（默认是 5000 毫秒） 这样，如果参数 id 为 1，一定失败，其他情况可能会成功，也可能会跳转到失败逻辑方法中。 当我们疯狂访问 id = 1 的请求时，超过我们设定的请求阈值次数 10 次，就会触发熔断。断路器开启，一切请求都会被降级处理。此时如果访问 id != 1 的请求，会发现返回的也是失败，而且失败时间相对于正常访问出错的时间短的很多倍。 Feign在前面的学习中（SpringCloud 学习笔记1），使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： 12String baseUrl = \"http://user-service/user/\";User user = this.restTemplate.getForObject(baseUrl + id, User.class) 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 简介 Feign是从Netflix中分离出来的轻量级项目，能够在类接口上添加注释，成为一个REST API 客户端。 Feign中对 Hystrix 有依赖关系。Feign只是一个便利的rest框架，简化调用，最后还是通过Ribbon（负载均衡）在注册服务器（如Eureka）中找到服务实例，然后对请求进行分配。 Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 快速入门导入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; Feign 的客户端1234567891011// 服务名称：user-service@FeignClient(\"user-service\")public interface UserClient { /** * 请求参数 id、请求路径 user、返回对象 * @param id 请求参数 * @return User */ @GetMapping(\"/user/{id}\") User queryById(@PathVariable(\"id\") Long id);} 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑： 123456789101112131415161718192021@RestController@DefaultProperties@RequestMapping(value = \"consumer\")public class ConsumerController { @Autowrited private UserClient userClient; private static final Logger logger = LoggerFactory.getLogger(ConsumerController.class); @HystrixCommand(fallbackMethod = \"queryByIdFallback\") @GetMapping(\"{id}\") public String queryById(@PathVariable(value = \"id\") Long id) { return userClient.queryById(id).toString(); } public String queryByIdFallback(Long id) { logger.error(\"查询用户信息失败，id: {}\", id); return \"不好意思，服务器正忙！\"; }} 开启Feign功能在启动类上，添加注解，开启Feign功能： 123456789@EnableCircuitBreaker@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端@EnableFeignClients // 开启 Feign 功能public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class); }} Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了。 启动测试：访问接口：http://localhost:8080/consumer/13 1{\"id\":13,\"userName\":\"LeeHua\",\"password\":\"123456\",\"name\":\"李华\",\"age\":21,\"sex\":1,\"birthday\":\"1998-10-24T16:00:00.000+0000\",\"created\":\"2018-08-30T16:00:00.000+0000\",\"updated\":\"2020-09-03T16:00:00.000+0000\",\"note\":\"测试\"} 负载均衡Feign中本身已经集成了Ribbon依赖和自动配置： 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以这样样来配置Ribbon 可以通过ribbon.xx来进行全局配置。 也可以通过服务名.ribbon.xx来对指定服务配置： 1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 Hystix支持Feign默认也有对Hystix的集成： 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启： 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 1）首先，我们要定义一个类，实现刚才编写的UserClient，作为fallback的处理类 123456789@Componentpublic class UserClientFallback implements UserClient { @Override public User queryById(Long id) { User user = new User(); user.setName(\"未知用户！！！\"); return user; }} 2）然后在UserFeignClient中，指定刚才编写的实现类 123456789101112// 服务名称：user-service// fallback：UserClientFallback@FeignClient(value = \"user-service\", fallback = UserClientFallback.class)public interface UserClient { /** * 请求参数 id、请求路径 user、返回对象 * @param id 请求参数 * @return User */ @GetMapping(\"/user/{id}\") User queryById(@PathVariable(\"id\") Long id);} 3）重启测试： 我们关闭user-service服务，然后在页面访问：http://localhost:8080/consumer/13 1{\"id\":13,\"userName\":null,\"password\":null,\"name\":\"未知用户\",\"age\":null,\"sex\":null,\"birthday\":null,\"created\":null,\"updated\":null,\"note\":null} 请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 日志级别(了解)前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置pres.stringbug包下的日志级别都为debug 123logging: level: com.leyou: debug 2）编写配置类，定义日志级别 1234567@Configurationpublic class FeignConfig { @Bean Logger.Level feignLoggerLevel(){ return Logger.Level.FULL; }} 这里指定的Level级别是FULL，Feign支持4种级别： NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = \"user-service\", fallback = UserClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient { @GetMapping(\"/user/{id}\") User queryUserById(@PathVariable(\"id\") Long id);} 4）重启项目，即可看到每次访问的日志： Zuul网关前言使用Spring Cloud实现微服务的架构，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 其次，无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 简介官网：https://github.com/Netflix/zuul Zuul：维基百科： 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 快速入门新建工程新建一个子工程： 引入Zuul依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写启动类通过@EnableZuulProxy注解开启Zuul的功能： 1234567@SpringCloudApplication@EnableZuulProxy // 开启Zuul的网关功能public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class); }} 编写配置12345server: port: 8085 #服务端口spring: application: name: api-gateway #指定服务名 编写路由规则映射规则： 12345zuul: routes: routename1: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 这里的配置，是将 /user-service/**开头的请求，代理到http://127.0.0.1:8081 启动测试访问的路径中需要加上配置规则的映射路径，访问：http://127.0.0.1:8085/user-service/user/13 面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 添加Eureka客户端依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 开启Eureka客户端发现功能12345678@SpringCloudApplication@EnableZuulProxy@EnableEurekaClientpublic class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class); }} 添加Eureka配置，获取服务信息12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:8082/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: routename1: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：http://127.0.0.1:8085/user-service/user/13 其中，8085 为 Zuul 代理的端口，/user-service/user 为映射路径，13 为用户 ID 日志中可以看到使用了负载均衡器： 简化的路由配置在上面的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=/user-service：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于user-service的配置可以简化为一条： 1234zuul: routes: # 服务名 : 映射路径 user-service: /user-service/** # 这里是映射路径 省去了对服务名称的配置。 默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是可以的。 路由前缀配置示例1： 123456zuul: prefix: /api # 添加路由前缀 routes: routename1: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 service-id: user-service # 指定服务名称 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 配置示例2： 123456zuul: routes: routename1: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 service-id: user-service # 指定服务名称 strip-prefix: false # 去除映射前缀 我们通过zuul.routes.&lt;route&gt;.strip-prefix 来去除映射的前缀，请求在发起时，路径就不用添加/user-service 前缀了。路径 /user/1 将会被代理到 /user-service/user/1 其中 &lt;route&gt; 是自定义的路由名 说明：strip-prefix 在 &lt;route&gt; 内，只去除该 &lt;route&gt; 的映射前缀。strip-prefix 和&lt;route&gt; 在同一级，则去除所有 &lt;route&gt; 的映射前缀 过滤器Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter{ abstract public String filterType(); // 过滤器类型 abstract public int filterOrder(); // 过滤器顺序 boolean shouldFilter();// 来自IZuulFilter，要不要过滤 Object run() throws ZuulException;// IZuulFilter，过滤逻辑} shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 过滤器执行生命周期这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 正常流程： 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 所有内置过滤器列表： 使用场景场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 自定义过滤器自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 定义过滤器类1234567891011121314151617181920212223242526272829303132333435363738public class LoginFilter extends ZuulFilter { @Override public String filterType() { // 登录校验，肯定是在前置拦截 // return \"pre\" return FilterConstants.PRE_TYPE; } @Override public int filterOrder() { // 过滤器顺序设置 return FilterConstants.PRE_DECORATION_FILTER_ORDER - 1; } @Override public boolean shouldFilter() { // 返回true，代表过滤器生效。 return true; } @Override public Object run() throws ZuulException { // 获取请求上下文 RequestContext currentContext = RequestContext.getCurrentContext(); // 获取 Request HttpServletRequest request = currentContext.getRequest(); // 获取请求参数 access-token String accessToken = request.getParameter(\"access-token\"); // 判断是否存在 token if (accessToken == null || accessToken.trim().isEmpty()) { // 没有token，登录校验失败，拦截 currentContext.setSendZuulResponse(false); // 返回401状态码。未授权的。 currentContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); } return null; }} 测试没有token参数时，访问失败：（访问 http://127.0.0.1:8085/user-service/user/13） 页面显示：401 Unauthorized 添加token参数后，访问成功：（访问 http://127.0.0.1:8085/user-service/user/13?access-token=XXXXXX） 负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 123456789101112131415zuul: retryable: trueribbon: # 负载均衡 ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: # 熔断器 command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms Ribbon（负载均衡） 的超时时长，真实值是 (ConnectTimeout + ReadTimeout) * 2，这个值必须要小于 Hystrix （熔断器）的超时时长。 参考文献 黑马 Java","link":"/p/360222202008/"},{"title":"pyquery 的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China pyquery 的初步了解（实例引入）简单举例12345678910111213141516171819202122232425262728from pyquery import PyQuery as pqhtml = '''&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/ul&gt;&lt;/div&gt;'''doc = pq(html)print(doc)# 输出：&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; 字符串123456789101112131415from pyquery import PyQuery as pqimport requests# doc1 与 doc2 功能相同doc1 = pq(url='https://www.cnblogs.com/liyihua/')print(doc1('title'))doc2 = pq(requests.get('https://www.cnblogs.com/liyihua/').text)print(doc1('title'))1# 输出：&lt;title&gt;李亦华 - 博客园&lt;/title&gt;&amp;#13; &lt;title&gt;李亦华 - 博客园&lt;/title&gt;&amp;#13; URL12345678910111213141516171819202122232425from pyquery import PyQuery as pqdoc = pq(filename='test.html')print(doc('li'))# 输出：&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt;# 文件内容：&lt;div&gt;&lt;ul&gt;&lt;li class=\"item-O\"&gt;&lt;a href=\"linkl.html\"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/ul&gt;&lt;/div&gt; pyquery 中的基本CSS选择器 实例切入： 1234567891011121314151617181920212223242526272829303132from pyquery import PyQuery as pqhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = pq(html)print(doc('#container .list li'))print( type( doc('#container .list li') ))# 输出：&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt; 查找节点获取子孙节点说明：find()方法查找的是所有子孙节点，如果只查找子节点，可以使用children()方法。 12345678910111213141516171819202122232425262728from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)items = doc('.list')print( type(items), items, sep='\\n')print( type(items.find('li')), items.find('li'), sep='\\n') 12345678910111213141516# 输出：&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; 获取父节点123456789101112131415161718192021222324from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;1&lt;/div&gt;13 '''doc = PyQuery(html)items = doc('.list')print(items, '\\n')print( type(items.parent()), items.parent(), sep='\\n') 1234567891011121314151617181920# 输出：&lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 兄弟节点1234567891011121314151617181920212223242526from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)# 选择class为list的节点内部class为item-0和active的节点items = doc('.list .item-0.active')print( type(items.siblings()), items.siblings(), sep='\\n')print(\"\\n\", items.siblings('.active')) 123456789# 输出：&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; 遍历节点12345678910111213141516171819202122from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)lis = doc('li').items() # 调用items()方法，得到一个生成器for li in lis: print( li, type(li) ) 1234567891011# 输出：&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt; 获取信息 attr()方法获取属性 12345678910111213141516171819202122from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)a = doc('.item-0.active a')print( a, type(a), a.attr('href'), # 也可以用a.attr.href，两者作用相同 sep='\\n') 1234# 输出：&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;link3.html text()方法获取文本 1234567891011121314151617181920212223from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)li = doc('li')print( li.html(), # 获取节点的内部文本 li.text(), # 获取节点文本，返回结果是纯文字内容 type(li.text()), sep='\\n') 1234# 输出：first itemfirst item second item third item fourth item fifth item&lt;class 'str'&gt; 节点操作添加和移除class1add_class() 和 remove_class() ---- 添加class、移除class 1234567891011121314151617181920from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)li = doc('.item-0.active')print(li)print(li.remove_class('active'))print(li.add_class('active')) 123456# 输出：&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; attr、text 和 html 方法123456789101112131415161718192021222324252627282930313233from pyquery import PyQueryhtml = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)li = doc('.item-0.active')print(li)li.attr('name', 'link') # 添加属性name，属性值为linkprint(li)li.text('change item') # 将节点内部的内容改为'change item'print(li)li.html('&lt;span&gt;change item&lt;/span&gt;') # 将节点内部的内容改为'&lt;span&gt;change item&lt;/span&gt;'print(li)# 输出：&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;change item&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;&lt;span&gt;change item&lt;/span&gt;&lt;/li&gt; 12345678# 输出：&lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;change item&lt;/li&gt; &lt;li class=\"item-0 active\" name=\"link\"&gt;&lt;span&gt;change item&lt;/span&gt;&lt;/li&gt; 删除节点123456789101112131415from pyquery import PyQueryhtml = '''&lt;div class=\"LeeHua\"&gt;LiYihua&lt;ul class=\"201802004731\"&gt;liyihua&lt;/ul&gt;&lt;/div&gt;'''doc = PyQuery(html)Leehua = doc('.LeeHua')print(\"移除节点ul前的输出：\\n\"+Leehua.text())Leehua.find('ul').remove()print(\"移除节点ul后的输出：\\n\"+Leehua.text()) 123456# 输出：移除节点ul前的输出：LiYihualiyihua移除节点ul后的输出：LiYihua 伪选择器示例： 1234567891011121314151617181920212223242526272829303132333435363738394041from pyquery import PyQueryhtml = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''doc = PyQuery(html)# 选择属于父元素的第一个子元素的每个 &lt;li&gt; 元素。li = doc('li:first-child')print(li)# 选择属于父元素的最后一个子元素的每个 &lt;li&gt; 元素。li = doc('li:last-child')print(li)# 选择属于其父元素的第二个子元素的每个 &lt;li&gt; 元素li = doc('li:nth-child(2)')print(li)# 选择属于其父元素的最后两个子元素的每个 &lt;li&gt; 元素li = doc('li:gt(2)')print(li)# 选择属于父元素的第偶个子元素的每个 &lt;li&gt; 元素。li = doc('li:nth-child(2n)')print(li)# 选择包含'second'的每个元素li = doc('li:contains(second)')print(li) 1234567891011121314# 输出：&lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; CSS 选择器的用法：http://www.w3school.com.cn/cssref/css_selectors.asp","link":"/p/421330202004/"},{"title":"串联所有单词的子串","text":"@Author: YiHua Lee @Address: Guangdong province, China 题目LeetCode中第30题：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/ 题目难度：困难 给定一个字符串 s 和一些长度相同的单词 words。 找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 子串要与 words 中的单词完全匹配，中间不能有其他字符。 不需要考虑 words 中单词串联的顺序。 示例示例1Input 12s = \"barfoothefoobarman\"words = [\"foo\",\"bar\"] Output 1[0,9] Understand 12从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。 示例2Input 12s = \"wordgoodgoodgoodbestword\"words = [\"word\",\"good\",\"best\",\"word\"] Output 1[] 解答解题思路 用两个 HashMap 来解决这个问题。 首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数。 然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中。 判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value。 value如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。 子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SubstringWithConcatenationOfAllWords { /** * 串联所有单词的子串 * @param s 字符串 * @param words 单词集合 * @return 字符串s中，包含所有单词的字符子串的起始索引的集合 */ public List&lt;Integer&gt; findSubstring(String s, String[] words) { // 创建一个集合对象，用来存储包含所有单词的字符子串的起始索引的集合 List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 获取单词的总个数，假如单词的个数为0，则无需在进行后续的判断 int wordNum = words.length; if (wordNum == 0) { return res; } // 由于所有的单词的长度都是一样的，所以获取第一个单词的长度，即获取到了每个单词的长度 int wordLen = words[0].length(); // 将所有的单词存储到 HashMap1 中，Key 表示单词，Value 表示该单词出现的次数 HashMap&lt;String, Integer&gt; allWords = new HashMap&lt;&gt;(); for (String w : words) { int value = allWords.getOrDefault(w, 0); allWords.put(w, value + 1); } // 遍历所有子串 for (int i = 0; i &lt; s.length() - wordNum * wordLen + 1; i++) { // HashMap2 存当前扫描的字符串含有的单词，Key 表示字符串中含有的单词，Value 表示字符串中该单词出现的次数 HashMap&lt;String, Integer&gt; hasWords = new HashMap&lt;&gt;(); int num = 0; // 判断该子串是否符合（从子串的第一个字母开始，直到该子串的最后一个字母） while (num &lt; wordNum) { // 获取下一个子串 String word = s.substring(i + num * wordLen, i + (num + 1) * wordLen); // 判断该单词在 HashMap1 中 if (allWords.containsKey(word)) { int value = hasWords.getOrDefault(word, 0); hasWords.put(word, value + 1); // 判断当前单词的 value 和 HashMap1 中该单词的 value if (hasWords.get(word) &gt; allWords.get(word)) { // 假如当前单词出现的次数，大于 HashMap1 中该单词出现的次数，那么就无需判断下一个单词了 break; } } else { // 假如该当前单词不包含在 HashMap1 中，那么也无需判断下一个单词了 break; } // 一个单词一个单词的进行比较，直到最后一个出现不符合的条件，或者所有单词都符合 num ++; } // 判断是不是所有的单词都符合条件（子串中不同单词的个数，与所给单词（不同单词）的个数相同） if (num == wordNum) { res.add(i); } } return res; }} 时间复杂度：假设 s 的长度是 n，words 里有 m 个单词，那么时间复杂度就是 O（n * m）。 空间复杂度：两个 HashMap，假设 words 里有 m 个单词，就是 O（m）。 大佬题解解题思路 假设words数组长度为L，word单词长度为WL，遍历字符串s，下标记做i 需要比对的单词起始坐标则为 [i, i+WL, i+2WL ... i+(L-1)*WL] 如果i满足条件，各个单词的第k位之和一定相等 即：words[0][k] + words[1][k] + ... + words[L-1][k] == s[i + k] + s[i+WL + k] + ... + s[i+(L-1)*WL + k] 反之，若对于i，满足后者条件的i则可能为正确结果，这个时候直接校验即可。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { List&lt;Integer&gt; rs = new ArrayList&lt;&gt;(); if (words == null || words.length == 0) { return rs; } int wLen = words[0].length(); int wTotalLen = words[0].length() * words.length; int sLen = s.length(); int[] flagArray = new int[wLen]; for (int i = 0; i &lt; wLen; i++) { int flag = 0; for (String word : words) { flag += word.charAt(i); } flagArray[i] = flag; } BitSet bs = new BitSet(words.length); for (int i = 0; i &lt;= sLen - wTotalLen; i++) { int j = 0; for (; j &lt; wLen; j++) { int sumFlag = 0; for (int k = 0; k &lt; words.length; k++) { sumFlag += s.charAt(i + k * wLen + j); } if (sumFlag != flagArray[j]) { break; } } if (j == wLen) { // 可能匹配 bs.clear(); for (int k = 0; k &lt; words.length; k++) { String w = s.substring(i + k * wLen, i + (k + 1) * wLen); int n = 0; for (; n &lt; words.length; n++) { if (!bs.get(n) &amp;&amp; words[n].equals(w)) { bs.set(n); break; } } if (n == words.length) { break; } } if (bs.cardinality() == words.length) { rs.add(i); } } } return rs; }} 参考文献 luqihang","link":"/p/542123202006/"},{"title":"从尾到头打印链表","text":"@Author: YiHua Lee @Address: Guangdong province, China 题目LeetCode中第6题：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ 题目难度：简单 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例Input 1head = [1,3,2] Output 1[2,3,1] 解答解题思路 利用栈的先进后出特性，从尾到头输出链表数据（输出形式为数组） 实现1234567891011121314151617181920212223242526272829303132333435363738394041public class PrintListNodeEndToStartUseList { public int[] reversePrint(ListNode head) { // 利用栈的先进后出特性，从尾到头输出链表数据（输出形式为数组） Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode tmp = head; // 将链表中的数据，依次入栈 while (tmp != null) { stack.push(tmp.value); tmp = tmp.next; } int size = stack.size(); int[] prints = new int[size]; for (int i = 0; i &lt; size; i++) { // 将链表中的数据依次出栈 prints[i] = stack.pop(); } return prints; }}class ListNode { int value; ListNode next; ListNode(int x) { value = x; }}// 测试class Demo { public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(3); ListNode node4 = new ListNode(4); ListNode node5 = new ListNode(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; System.out.println(Arrays.toString(reversePrint(node1))); }} 涉及知识点 链表 栈 参考文献 … …","link":"/p/510925202006/"},{"title":"关系型数据库和非关系型数据库","text":"@Author: YiHua Lee @Address: Guangdong province, China 什么是关系型数据库 关系数据库是数据项之间具有预定义关系的数据项的集合。这些项被组织为一组具有列和行的表。表用于保存有关要在数据库中表示的对象的信息。表中的每列都保存着特定类型的数据，字段存储着属性的实际值。表中的行表示一个对象或实体的相关值的集合。表中的每一行可标有一个称为主键的唯一标识符，并且可使用外键在多个表中的行之间建立关联。可以通过许多不同的方式访问此数据，而无需重新组织数据库表本身。 关系型数据库以行和列的形式存储数据，行和列的形式被称为表，表是由一组相关实体组成的集合。一组表组成了数据库。 表中的一行称为关系的一个元组，用来存储事物的一个实例。 表中的一列称为关系的一个属性，用来描述实体的某一特征。 表内字段的组成一样，即便某个数据不需要某个字段，系统也会强加上这个字段及默认值，这种结构便于表与表之间进行操作，但它也是关系数据库性能瓶颈的一个因素。 什么是非关系型数据库 非关系型数据库即我们常说的NoSQL数据库。NoSQL的存储格式是key-value形式，可以像关系型数据库那样存储基础数据类型的数据，也可以存储集合、对象等等。NoSQL虽然性能比较高，但是并不支持事物，也不能进行联表查询，一般用于较大规模数据的存储。 非关系数据库以键值对存储 结构不固定，每一个元组可以有不一样的字段 每个元组可以根据需要增加或减少一些自己的键值对 不会局限于固定的结构，减少一些时间和空间的开销 关系型数据库和非关系型数据库优缺点 关系型数据库发展了很长一段时间，拥有非常成熟的体系。所占份额也在逐渐增加。而且支持事物的操作，保证数据的一致性，可以通过SQL语句完成复杂的操作。但是使用过程中当数据量到达一定程度时，关系型数据库的效率会有明显的下降。一个复杂的查询操作，一系列的组合索引都会消耗非常多的内存空间，此时我们需要对数据库进行读写分离操作，或者将数据库结构进行拆分(水平拆分、垂直拆分)将请求压力分担在不同的库中。 垂直拆分是指将一张表拆分成多个表，表之间通过主键进行关联。 水平拆分是按照某种规则拆分成多个表，比如通过用户角色进行拆分 读写分离：所谓读写分离就是讲读操作(查询数据)和写操作(插入&amp;更新)指向不同的数据库节点，他们中间通过某种机制实现数据的同步，如binlog。实际的应用中大部分压力还是来自读操作，所以主要是一主多从的架构。 非关系型数据库发展的这几年，深受人们的喜爱。免费开源、成本低、部署简单、非结构化存储等等明显的优势。而且它对海量数据处理能力非常强，内存级数据库，查询速度也非常快。存储的数据格式比较丰富，易于扩展，不能使用sql进行复杂的查询。 NoSQL数据库适用场景 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 参考文献 关系数据库是什么？_关系型数据库有哪些-AWS云服务 关系型数据库和非关系型数据库 【关系型数据库】和【非关系型数据库】总结！ NoSQL_百度百科","link":"/p/231512202007/"},{"title":"代理对象增强参数","text":"@Author: YiHua Lee @Address: Guangdong province, China 我们在购买电脑的时候，通常有两个路径，第一个路径就是去官网购买，第二个路径就是去代理商这里购买。我们购买电脑的时候，比较看重的一点就是价格和赠品。例如我们去苹果直营店购买MacBook Pro，价格是35000，且直营店距离我们比较远。距离我们比较近的一个位置有苹果代理商出售同款电脑，价格仅需原价的80%，而且还有一些赠品。这个时候很多人就会选择去代理商店铺这里购买了。 创建一个出手电脑的接口 12345678public interface SaleComputer { /** * 卖电脑 * @param money 钱 * @return 钱 */ public String sale(double money);} 接口实现类 1234567public class MacBookPro implements SaleComputer { @Override public String sale(double money) { System.out.println(\"花了\"+ money +\"钱买了一台苹果笔记本电脑\"); return \"MacBook Pro 16 寸 64G+4T\"; }} 使用动态代理来增强某些参数（如：价格） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ProxyDemo { public static void main(String[] args) { // 创建真实对象 MacBookPro macBookPro = new MacBookPro(); // 调用方法 String computer = macBookPro.sale(35000); System.out.println(\"官网直营店购买：\" + computer); // 动态代理增强 MacBook Pro 对象 /* 1. 处理器对象：代理逻辑编写的方法：代理对象调用所有的方法，都会触发执行该方法 三个参数： 1. proxy：代理对象 2. method：代理对象的方法被封装为对象 3. args1：代理对象调用的方法时，传递的实际参数 */ InvocationHandler invocationHandler = (proxy, method, args1) -&gt; { // System.out.println(\"InvocationHandler().invoke() 方法被执行了\"); // System.out.println(method.getName()); // sale // System.out.println(Arrays.toString(args1)); // [36000.0] // 使用真实对象（macBookPro）调用该方法（sale） // 判断是否是调用sale方法 if (method.getName().equals(\"sale\")) { // 增强参数（购买花费）: 回扣 20% double money = (double) args1[0]; money = money * 0.8; args1[0] = money; // 还有赠品 return method.invoke(macBookPro, args1) + \"\\t赠品：鼠标垫、鼠标、电脑包\"; } return method.invoke(macBookPro, args1); }; /* 2. 三个参数： 1. 类加载器： classAAA.getClass().getClassLoader() 2. 接口数组：classAAA.getClass().getInterfaces() 3. 处理器：InvocationHandler() */ SaleComputer proxyMacBookPro = (SaleComputer) Proxy.newProxyInstance( macBookPro.getClass().getClassLoader(), macBookPro.getClass().getInterfaces(), invocationHandler ); System.out.print(\"\\n\"); String proxySale = proxyMacBookPro.sale(35000); System.out.println(\"代理商店铺购买：\" + proxySale); }} 测试，控制台输出： 12345花了35000.0钱买了一台苹果笔记本电脑官网直营店购买：MacBook Pro 16 寸 64G+4T花了28000.0钱买了一台苹果笔记本电脑代理商店铺购买：MacBook Pro 16 寸 64G+4T 赠品：鼠标垫、鼠标、电脑包","link":"/p/071625202006/"},{"title":"初识 Ajax","text":"@Author: YiHua Lee @Address: Guangdong province, China Ajax 简介 AJAX 全称 Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 Ajax 工作原理 假如互联网用户，在某网站创建自己的账户，用户输入用户名后，输入其他信息，如密码等。网页公司为了在用户提交前，提示用户输入的用户名是否存在，Ajax就可以实现此功能。 用户输入用户名 网页端创建 XMLHttpRequest 对象，发送用户输入的用户名请求到服务器 服务器处理该请求，查询数据库中是否存在该用户名，然后创建响应 服务器将响应返回浏览器，使用JS处理被返回的数据 假如存在该用户名，那么就可以在用户提交之前，提示用户该输入的用户名已经存在。 XMLHttpRequest 对象 所有现代浏览器均支持 XMLHttpRequest 对象 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest 对象 1variable = new XMLHttpRequest(); 对于老版本的浏览器（IE5 和 IE6），使用的是 ActiveX 对象 1variable = new ActiveXObject(\"Microsoft.XMLHTTP\"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，需要检查浏览器是否支持 XMLHttpRequest 对象 123456789101112function loadXMLDoc() { var xmlhttp; // 浏览器如果支持 XMLHttpRequest 对象，那么就创建 XMLHttpRequest 对象 // 浏览器如果不支持 XMLHttpRequest 对象，那么就创建 ActiveX 对象 if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp = new XMLHttpRequest(); } else { // IE6, IE5 浏览器执行代码 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); }} Ajax 向服务器发送请求 XMLHttpRequest 对象用于和服务器交换数据。 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法 12xmlhttp.open(\"GET\", \"ajax_info.txt\", true);xmlhttp.send(); 方法说明： 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） send(string) 将请求发送到服务器。string：仅用于 POST 请求 open() 方法的 url 参数是服务器上文件的地址。该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 GET 还是 POST与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求 一个简单的 GET 请求 12xmlhttp.open(\"GET\", \"/try/ajax/demo_get.php\", true);xmlhttp.send(); 在上面的例子中，可能得到的是缓存的结果。为了避免这种情况，可以向 URL 添加一个唯一的 ID 向 URL 添加一个唯一的 ID 12xmlhttp.open(\"GET\", \"/try/ajax/demo_get.php?t=\" + Math.random(), true);xmlhttp.send(); 如果希望通过 GET 方法发送信息，需要向 URL 添加信息： 12xmlhttp.open(\"GET\", \"/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford\", true);xmlhttp.send(); POST 请求 一个简单 POST 请求 12xmlhttp.open(\"POST\", \"/try/ajax/demo_post.php\", true);xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，那就需要使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定希望发送的数据 123xmlhttp.open(\"POST\", \"/try/ajax/demo_post2.php\", true);xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");xmlhttp.send(\"fname=Henry&amp;lname=Ford\"); 方法 描述 setRequestHeader(header,value) 向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 异步 - True or False AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。 1xmlhttp.open(\"GET\", \"ajax_test.html\", true); Async=true当使用 async=true 时，需要规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数 12345678910// 响应处于就绪状态xmlhttp.onreadystatechange = function() { // 就绪状态值为4，页面访问状态为200 if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { // 通过ID获取对应的标签，并插入响应内容 document.getElementById(\"myDiv\").innerHTML = xmlhttp.responseText; }}xmlhttp.open(\"GET\", \"/try/ajax/ajax_info.txt\", true);xmlhttp.send() Async = false如需使用 async=false，需要将 open() 方法中的第三个参数改为 false 1xmlhttp.open(\"GET\", \"test1.txt\", false); 不推荐使用 async=false，但是对于一些小型的请求，也是可以的。 JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可 123xmlhttp.open(\"GET\", \"/try/ajax/ajax_info.txt\", false);xmlhttp.send();document.getElementById(\"myDiv\").innerHTML = xmlhttp.responseText; Ajax - 服务器响应服务器响应 如需获得来自服务器的响应，需要使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 responseText 属性 如果来自服务器的响应并非 XML，请使用 responseText 属性。 responseText 属性返回字符串形式的响应，因此可以这样使用： 1document.getElementById(\"myDiv\").innerHTML = xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，那么就可以使用 responseXML 属性： 1234567891011// 获取服务器发送来的 XML （响应）xmlDoc = xmlhttp.responseXML;txt = \"\";// 获取 XML 文件中的 &lt;ARTIST&gt;&lt;/ARTIST&gt; 标签x = xmlDoc.getElementsByTagName(\"ARTIST\");// 获取所有的 &lt;ARTIST&gt;&lt;/ARTIST&gt; 文本内容for (i = 0; i &lt; x.length; i ++) { txt = txt + x[i].childNodes[0].nodeValue + \"&lt;br&gt;\";}// 将获取到的文本内容插入到对应的html标签体中document.getElementById(\"myDiv\").innerHTML = txt; Ajax - onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪 12345xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { document.getElementById(\"myDiv\").innerHTML = xmlhttp.responseText; }} 注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。 使用回调函数 回调函数是一种以参数形式传递给另一个函数的函数。 如果一个网站上存在多个 AJAX 任务，那么应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）： 12345678function myFunction() { // 加载 ajax_info.txt，当 readyState=4、status=200 的时候，将响应文本插入 id=\"myDiv\" 的标签 loadXMLDoc(\"/try/ajax/ajax_info.txt\", function() { if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { document.getElementById(\"myDiv\").innerHTML = xmlhttp.responseText; } });} Ajax 实例使用 Ajax 加载 XML 文件 创建一个简单的XMLHttpRequest，从一个XML文件中返回数据。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script&gt; function loadXMLDoc(url) { var xmlhttp; // 需要检查浏览器是否支持 XMLHttpRequest 对象 if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } // 执行一些基于响应的任务 xmlhttp.onreadystatechange = function() { // 响应已就绪 if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { // 插入内容 document.getElementById('A1').innerHTML = xmlhttp.status; document.getElementById('A2').innerHTML = xmlhttp.statusText; document.getElementById('A3').innerHTML = xmlhttp.responseText; } } // 规定请求的类型、URL 以及是否异步处理请求 xmlhttp.open(\"GET\", url, true); // 向服务器发送请求 xmlhttp.send(); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Retrieve data from XML file&lt;/h2&gt; &lt;p&gt;&lt;b&gt;Status:&lt;/b&gt;&lt;span id=\"A1\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;Status text:&lt;/b&gt;&lt;span id=\"A2\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;b&gt;Response:&lt;/b&gt;&lt;span id=\"A3\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;button onclick=\"loadXMLDoc('note.xml')\"&gt;Get XML data&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 在note.xml 文件中， id=&quot;A1&quot; 的标签体内容为 200， id=&quot;A2&quot; 的标签体内容为空，id=&quot;A3&quot; 的标签体内容为 Tove Jani Reminder Don't forget me this weekend! ! 使用Ajax 从 XML 文件返回数据 创建一个XMLHttpRequest从XML文件中检索数据并显示在一个HTML表格中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; table,th,td { border : 1px solid black; border-collapse: collapse; } th,td { padding: 5px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;XMLHttpRequest 对象&lt;/h1&gt; &lt;button type=\"button\" onclick=\"loadXMLDoc()\"&gt;获取我收藏的 CD&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;table id=\"demo\"&gt;&lt;/table&gt; &lt;script&gt; function loadXMLDoc() { // 创建 XMLHttpRequest 对象 var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { // 执行一些基于响应的任务 if (this.readyState == 4 &amp;&amp; this.status == 200) { myFunction(this); } }; // 规定请求的类型、URL 以及是否异步处理请求 xhttp.open(\"GET\", \"cd_catalog.xml\", true); // 向服务器发送请求 xhttp.send(); } function myFunction(xml) { var i; // 获取服务器发送来的 XML（响应） var xmlDoc = xml.responseXML; var table = \"&lt;tr&gt;&lt;th&gt;Artist&lt;/th&gt;&lt;th&gt;Title&lt;/th&gt;&lt;/tr&gt;\"; // 获取 XML 响应内容中的 &lt;CD&gt;&lt;/CD&gt; 标签体 var x = xmlDoc.getElementsByTagName(\"CD\"); for (i = 0; i &lt;x.length; i++) { // 将每个 &lt;CD&gt;&lt;/CD&gt; 标签体 的 ARTIST、TITLE内容插入到表格行中的两个单元格 table += \"&lt;tr&gt;&lt;td&gt;\" + x[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue + \"&lt;/td&gt;&lt;td&gt;\" + x[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue + \"&lt;/td&gt;&lt;/tr&gt;\"; } // 将所有的表格行插入到 demo 表格中 document.getElementById(\"demo\").innerHTML = table; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击后： 其中 cd_catalog.xml 的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;!-- Edited by XMLSpy® --&gt;&lt;CATALOG&gt; &lt;CD&gt; &lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt; &lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;Columbia&lt;/COMPANY&gt; &lt;PRICE&gt;10.90&lt;/PRICE&gt; &lt;YEAR&gt;1985&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Hide your heart&lt;/TITLE&gt; &lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt; &lt;PRICE&gt;9.90&lt;/PRICE&gt; &lt;YEAR&gt;1988&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Greatest Hits&lt;/TITLE&gt; &lt;ARTIST&gt;Dolly Parton&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;RCA&lt;/COMPANY&gt; &lt;PRICE&gt;9.90&lt;/PRICE&gt; &lt;YEAR&gt;1982&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Still got the blues&lt;/TITLE&gt; &lt;ARTIST&gt;Gary Moore&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Virgin records&lt;/COMPANY&gt; &lt;PRICE&gt;10.20&lt;/PRICE&gt; &lt;YEAR&gt;1990&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Eros&lt;/TITLE&gt; &lt;ARTIST&gt;Eros Ramazzotti&lt;/ARTIST&gt; &lt;COUNTRY&gt;EU&lt;/COUNTRY&gt; &lt;COMPANY&gt;BMG&lt;/COMPANY&gt; &lt;PRICE&gt;9.90&lt;/PRICE&gt; &lt;YEAR&gt;1997&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;One night only&lt;/TITLE&gt; &lt;ARTIST&gt;Bee Gees&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Polydor&lt;/COMPANY&gt; &lt;PRICE&gt;10.90&lt;/PRICE&gt; &lt;YEAR&gt;1998&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Sylvias Mother&lt;/TITLE&gt; &lt;ARTIST&gt;Dr.Hook&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;CBS&lt;/COMPANY&gt; &lt;PRICE&gt;8.10&lt;/PRICE&gt; &lt;YEAR&gt;1973&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Maggie May&lt;/TITLE&gt; &lt;ARTIST&gt;Rod Stewart&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Pickwick&lt;/COMPANY&gt; &lt;PRICE&gt;8.50&lt;/PRICE&gt; &lt;YEAR&gt;1990&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Romanza&lt;/TITLE&gt; &lt;ARTIST&gt;Andrea Bocelli&lt;/ARTIST&gt; &lt;COUNTRY&gt;EU&lt;/COUNTRY&gt; &lt;COMPANY&gt;Polydor&lt;/COMPANY&gt; &lt;PRICE&gt;10.80&lt;/PRICE&gt; &lt;YEAR&gt;1996&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;When a man loves a woman&lt;/TITLE&gt; &lt;ARTIST&gt;Percy Sledge&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;Atlantic&lt;/COMPANY&gt; &lt;PRICE&gt;8.70&lt;/PRICE&gt; &lt;YEAR&gt;1987&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Black angel&lt;/TITLE&gt; &lt;ARTIST&gt;Savage Rose&lt;/ARTIST&gt; &lt;COUNTRY&gt;EU&lt;/COUNTRY&gt; &lt;COMPANY&gt;Mega&lt;/COMPANY&gt; &lt;PRICE&gt;10.90&lt;/PRICE&gt; &lt;YEAR&gt;1995&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;1999 Grammy Nominees&lt;/TITLE&gt; &lt;ARTIST&gt;Many&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;Grammy&lt;/COMPANY&gt; &lt;PRICE&gt;10.20&lt;/PRICE&gt; &lt;YEAR&gt;1999&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;For the good times&lt;/TITLE&gt; &lt;ARTIST&gt;Kenny Rogers&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Mucik Master&lt;/COMPANY&gt; &lt;PRICE&gt;8.70&lt;/PRICE&gt; &lt;YEAR&gt;1995&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Big Willie style&lt;/TITLE&gt; &lt;ARTIST&gt;Will Smith&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;Columbia&lt;/COMPANY&gt; &lt;PRICE&gt;9.90&lt;/PRICE&gt; &lt;YEAR&gt;1997&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Tupelo Honey&lt;/TITLE&gt; &lt;ARTIST&gt;Van Morrison&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Polydor&lt;/COMPANY&gt; &lt;PRICE&gt;8.20&lt;/PRICE&gt; &lt;YEAR&gt;1971&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Soulsville&lt;/TITLE&gt; &lt;ARTIST&gt;Jorn Hoel&lt;/ARTIST&gt; &lt;COUNTRY&gt;Norway&lt;/COUNTRY&gt; &lt;COMPANY&gt;WEA&lt;/COMPANY&gt; &lt;PRICE&gt;7.90&lt;/PRICE&gt; &lt;YEAR&gt;1996&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;The very best of&lt;/TITLE&gt; &lt;ARTIST&gt;Cat Stevens&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Island&lt;/COMPANY&gt; &lt;PRICE&gt;8.90&lt;/PRICE&gt; &lt;YEAR&gt;1990&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Stop&lt;/TITLE&gt; &lt;ARTIST&gt;Sam Brown&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;A and M&lt;/COMPANY&gt; &lt;PRICE&gt;8.90&lt;/PRICE&gt; &lt;YEAR&gt;1988&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Bridge of Spies&lt;/TITLE&gt; &lt;ARTIST&gt;T'Pau&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Siren&lt;/COMPANY&gt; &lt;PRICE&gt;7.90&lt;/PRICE&gt; &lt;YEAR&gt;1987&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Private Dancer&lt;/TITLE&gt; &lt;ARTIST&gt;Tina Turner&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;Capitol&lt;/COMPANY&gt; &lt;PRICE&gt;8.90&lt;/PRICE&gt; &lt;YEAR&gt;1983&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Midt om natten&lt;/TITLE&gt; &lt;ARTIST&gt;Kim Larsen&lt;/ARTIST&gt; &lt;COUNTRY&gt;EU&lt;/COUNTRY&gt; &lt;COMPANY&gt;Medley&lt;/COMPANY&gt; &lt;PRICE&gt;7.80&lt;/PRICE&gt; &lt;YEAR&gt;1983&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Pavarotti Gala Concert&lt;/TITLE&gt; &lt;ARTIST&gt;Luciano Pavarotti&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;DECCA&lt;/COMPANY&gt; &lt;PRICE&gt;9.90&lt;/PRICE&gt; &lt;YEAR&gt;1991&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;The dock of the bay&lt;/TITLE&gt; &lt;ARTIST&gt;Otis Redding&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;Atlantic&lt;/COMPANY&gt; &lt;PRICE&gt;7.90&lt;/PRICE&gt; &lt;YEAR&gt;1987&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Picture book&lt;/TITLE&gt; &lt;ARTIST&gt;Simply Red&lt;/ARTIST&gt; &lt;COUNTRY&gt;EU&lt;/COUNTRY&gt; &lt;COMPANY&gt;Elektra&lt;/COMPANY&gt; &lt;PRICE&gt;7.20&lt;/PRICE&gt; &lt;YEAR&gt;1985&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Red&lt;/TITLE&gt; &lt;ARTIST&gt;The Communards&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;London&lt;/COMPANY&gt; &lt;PRICE&gt;7.80&lt;/PRICE&gt; &lt;YEAR&gt;1987&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Unchain my heart&lt;/TITLE&gt; &lt;ARTIST&gt;Joe Cocker&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;EMI&lt;/COMPANY&gt; &lt;PRICE&gt;8.20&lt;/PRICE&gt; &lt;YEAR&gt;1987&lt;/YEAR&gt; &lt;/CD&gt;&lt;/CATALOG&gt; 参考文献 AJAX 教程| 菜鸟教程","link":"/p/251711202007/"},{"title":"初识数据库连接池","text":"@Author: YiHua Lee @Address: Guangdong province, China 概述数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。 这项技术能明显提高对数据库操作的性能。它其实就是一个容器，用来存放数据库连接对象的容器。 背景数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。 影响因素数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数制约。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素： 最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。 最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。 最小连接数与最大连接数差距最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。 原理连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 Java中的数据库连接池 C3P0：是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。 Proxool：是一个Java SQL Driver驱动程序，提供了对选择的其它类型的驱动程序的连接池封装。可以非常简单的移植到现存的代码中，完全可配置，快速、成熟、健壮。可以透明地为现存的JDBC驱动程序增加连接池功能。 Jakarta DBCP：DBCP是一个依赖Jakartacommons-pool对象池机制的数据库连接池。DBCP可以直接的在应用程序中使用。 DDConnectionBroker：是一个简单、轻量级的数据库连接池。 DBPool：是一个高效、易配置的数据库连接池。它除了支持连接池应有的功能之外，还包括了一个对象池，使用户能够开发一个满足自己需求的数据库连接池。 XAPool：是一个XA数据库连接池。它实现了javax.sql.XADataSource并提供了连接池工具。 Primrose：是一个Java开发的数据库连接池。当前支持的容器包括Tomcat4&amp;5、Resin3与JBoss3。它同样也有一个独立的版本，可以在应用程序中使用而不必运行在容器中。Primrose通过一个WEB接口来控制SQL处理的追踪、配置，以及动态池管理。在重负荷的情况下可进行连接请求队列处理。 SmartPool：是一个连接池组件，它模仿应用服务器对象池的特性。SmartPool能够解决一些临界问题如连接泄漏（connection leaks）、连接阻塞、打开的JDBC对象（如Statements、PreparedStatements）等。SmartPool的特性包括： 支持多个pool 自动关闭相关联的JDBC对象 在所设定time-outs之后察觉连接泄漏 追踪连接使用情况 强制启用最近最少用到的连接 把SmartPool“包装”成现存的一个pool MiniConnectionPoolManager：是一个轻量级JDBC数据库连接池。它只需要Java1.5（或更高）并且没有依赖第三方包。 BoneCP：是一个快速、开源的数据库连接池。帮用户管理数据连接，让应用程序能更快速地访问数据库。比C3P0/DBCP连接池速度快25倍。 Druid：Druid不仅是一个数据库连接池，还包含一个ProxyDriver、一系列内置的JDBC组件库、一个SQL Parser。 支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等。针对Oracle和MySql做了特别优化，比如： Oracle的PS Cache内存占用优化 MySql的ping检测优化 Druid提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。 简单SQL语句用时10微秒以内，复杂SQL用时30微秒。 通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。Druid防御SQL注入攻击的WallFilter，就是通过Druid的SQL Parser分析语义实现的。","link":"/p/181506202005/"},{"title":"圆和矩形是否有重叠","text":"@Author: YiHua Lee @Address: Guangdong province, China 题目LeetCode中第1401题：https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/ 题目难度：中等 一个以 (radius, x_center, y_center) 表示的圆。 一个与坐标轴平行的矩形 (x1, y1, x2, y2)。 (x1, y1) 是矩形左下角的坐标，(x2, y2) 是右上角的坐标。 判断圆和矩形是否有重叠的部分，有重叠部分返回 True ，否则返回 False 。 包括点落在边界上的情况。 提示 1 &lt;= radius &lt;= 2000 -10^4 &lt;= x_center, y_center, x1, y1, x2, y2 &lt;= 10^4 x1 &lt; x2 y1 &lt; y2 示例示例 1Input 12radius = 1, x_center = 0, y_center = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1 Output 1true Understand 1圆和矩形有公共点 (1,0) 示例 2Input 12radius = 1, x_center = 0, y_center = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1 Output 1true 示例 3Input 12radius = 1, x_center = 1, y_center = 1, x1 = -3, y1 = -3, x2 = 3, y2 = 3 Output 1true 示例 4Input 12radius = 1, x_center = 1, y_center = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1 Output 1false 解答解题思路 判断圆心是否在矩形内 判断矩形的四个点是否有在圆内或圆上的 矩形的点不在圆内,但矩形与圆相交的情况 圆心在矩形的左边或者右边：radius 与x_center、x1 或者 radius 与 x_center、x2 之间的关系 圆心在矩形的上边或者下边：radius 与y_center、y1 或者 radius 与 y_center、y2 之间的关系 实现1234567891011121314151617181920public class CircleAndRectangleOverlapping { public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) { // 判断圆心是否在矩形内 if (x1 &lt;= x_center &amp;&amp; x2 &gt;= x_center &amp;&amp; y1 &lt;= y_center &amp;&amp; y2 &gt;= y_center) { return true; } // 判断矩形的四个点是否在圆内或圆上 if ( Math.pow(x1 - x_center, 2) + Math.pow(y1 - y_center, 2) &lt;= Math.pow(radius, 2) || Math.pow(x1 - x_center, 2) + Math.pow(y2 - y_center, 2) &lt;= Math.pow(radius, 2) || Math.pow(x2 - x_center, 2) + Math.pow(y1 - y_center, 2) &lt;= Math.pow(radius, 2) || Math.pow(x2 - x_center, 2) + Math.pow(y2 - y_center, 2) &lt;= Math.pow(radius, 2) ) { return true; } // 矩形的点不在圆内,但矩形与圆相交的情况 return // 圆心在矩形的左边或者右边 (y1 &lt; y_center &amp;&amp; y2 &gt; y_center &amp;&amp; ((Math.abs(x1 - x_center) &lt;= radius || Math.abs(x2 - x_center) &lt;= radius))) || // 圆心在矩形的上边或者下边 (x1 &lt; x_center &amp;&amp; x2 &gt; x_center &amp;&amp; ((Math.abs(y1 - y_center) &lt;= radius || Math.abs(y2 - y_center) &lt;= radius))); }} 参考文献 。。。。","link":"/p/381024202006/"},{"title":"前端框架 BootStrap 的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 前端框架 BootStrap 快速入门（Hallo Word）BootStrap 响应式布局BootStrap 之 CSS全局样式中的按钮BootStrap 之 CSS全局样式中的图片BootStrap 之 CSS全局样式中的表格BootStrap 之 CSS全局样式中的表单Bootstrap 组件中的导航条Bootstrap 组件中的分页条BootStrap之JavaScript插件中的轮播图","link":"/p/581606202005/"},{"title":"对 Java File类的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China File类的概述java.io.File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 File类部分构造方法12345678910111213/** * 从父抽象路径名和子路径名字符串创建新的File实例。 */private File(String child, File parent) { ...}/** * 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 */public File(String pathname) { ...} 路径分隔符和默认名称分隔符12345678910111213141516// 依赖于系统的默认名称分隔符字符。此字段初始化为包含系统属性&lt;code&gt;file.separator&lt;/code&gt;值的第一个字符。// 在UNIX系统上，此字段的值为&lt;code&gt;'/'&lt;/code&gt;；在Microsoft Windows系统上，此字段的值为&lt;code&gt;'\\'&lt;/code&gt;。public static final char separatorChar = fs.getSeparator();// 依赖于系统的默认名称分隔符字符，为方便起见表示为字符串。public static final String separator = \"\" + separatorChar;// 依赖于系统的路径分隔符字符。此字段初始化为包含系统属性&lt;code&gt;path.separator&lt;/code&gt;值的第一个字符。// 此字符用于将文件名按&lt;em&gt;路径列表指定的文件序列分隔开。在UNIX系统上，此字符为&lt;code&gt;':'&lt;/code&gt;；// 在Microsoft Windows系统上，此字符为&lt;code&gt;';'&lt;/code&gt;。public static final char pathSeparatorChar = fs.getPathSeparator();// 依赖于系统的路径分隔符字符，为了方便起见表示为字符串public static final String pathSeparator = \"\" + pathSeparatorChar; 依赖于系统的默认名称分隔符12345678910111213import java.io.File;public class Demo01Separator { public static void main(String[] args) { // 依赖于系统的默认名称分隔符字符。 char separatorChar = File.separatorChar; System.out.println(\"系统的默认名称分隔符字符是'\" + separatorChar + \"'\"); // 依赖于系统的默认名称分隔符字符，为方便起见表示为字符串。 String separatorString = File.separator; System.out.println(\"系统的默认名称分隔符字符是'\" + separatorString + \"'\"); }} 123控制台输出：系统的默认名称分隔符字符是'/'系统的默认名称分隔符字符是'/' 依赖于系统的路径分隔符12345678910111213import java.io.File;public class Demo01PathSeparator { public static void main(String[] args) { // 依赖于系统的路径分隔符字符 char pathSeparatorChar = File.pathSeparatorChar; System.out.println(\"依赖于系统的路径分隔符字符是'\" + pathSeparatorChar + \"'\"); // 依赖于系统的路径分隔符字符，为了方便起见表示为字符串 String pathSeparatorString = File.pathSeparator; System.out.println(\"依赖于系统的路径分隔符字符是'\" + pathSeparatorString + \"'\"); }} 123控制台输出：依赖于系统的路径分隔符字符是':'依赖于系统的路径分隔符字符是':' 程序很多时候都是跨平台的，所以不要把路径写死，可以使用以上几个静态成员变量获取分隔符 File类的部分构造方法的使用1234567891011public class Demo02File { public static void main(String[] args) { // 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 File file1 = new File(\"~/IdeaProjects/Study/src/view/study/demo27/Demo02File.java\"); System.out.println(file1); // 从父抽象路径名和子路径名字符串创建新的File实例。 File file2 = new File(\"~/IdeaProjects/Study/\", \"/src/view/study/demo27/Demo02File.java\"); System.out.println(file2); }} 123控制台输出：~/IdeaProjects/Study/src/view/study/demo27/Demo02File.java~/IdeaProjects/Study/src/view/study/demo27/Demo02File.java File类获取功能的常用方法1234567891011public String getAbsolutePath()// 返回此File的绝对路径名字符串。public String getPath()// 将此File转换为路径名字符串。public String getName()// 返回由此File表示的文件或目录的名称。public long length()// 返回由此File表示的文件的长度。 这几个方法的使用 123456789101112131415161718192021222324import java.io.File;public class Demo01FileMethod { public static void main(String[] args) { File file = new File(\"~/IdeaProjects/Study/src/view/study/demo27/Demo01FileMethod.java\"); // 返回此File的绝对路径名字符串。 String fileAbsolutePath = file.getAbsolutePath(); // 将此File转换为路径名字符串。 String filePath = file.getPath(); // 返回由此File表示的文件或目录的名称。 String fileName = file.getName(); // 返回由此File表示的文件的长度。 long fileLength = file.length(); System.out.println(\"绝对路径：\" + fileAbsolutePath); System.out.println(\"路径名字符串：\" + filePath); System.out.println(\"文件或目录的名称：\" + fileName); System.out.println(\"文件的长度：\" + fileLength); }} 12345控制台输出：绝对路径：/Users/liyihua/IdeaProjects/Study/~/IdeaProjects/Study/src/view/study/demo27/Demo01FileMethod.java路径名字符串：~/IdeaProjects/Study/src/view/study/demo27/Demo01FileMethod.java文件或目录的名称：Demo01FileMethod.java文件的长度：0 文件路径不存在，返回文件的长度为0 File类判断功能的常用方法12345678public boolean exists()// 此File表示的文件或目录是否实际存在。public boolean isDirectory()// 此File表示的是否为目录。public boolean isFile()// 此File表示的是否为文件。 这几个方法的使用 123456789101112131415import java.io.File;public class Demo02FileMethod { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo27\"); boolean exiFile = file.exists(); boolean isD = file.isDirectory(); boolean isF = file.isFile(); System.out.println(\"文件或目录是否实际存在：\" + exiFile); System.out.println(\"是否为目录：\" + isD); System.out.println(\"是否为文件：\" + isF); }} 1234控制台输出：文件或目录是否实际存在：true是否为目录：true是否为文件：false 判断是否为文件或是否为目录的时候，路径必须存在，否则都返回false（计算机中只有文件和目录） File类创建删除功能的常用方法1234567891011public boolean createNewFile()// 当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。public boolean delete()// 删除由此File表示的文件或目录。public boolean mkdir()// 创建由此File表示的目录。public boolean mkdirs()// 创建由此File表示的目录,包括任何必需但不存在的父目录。 创建一个新的空文件12345678910import java.io.File;import java.io.IOException;public class Demo03FileMethod { public static void main(String[] args) throws IOException { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/test.txt\"); file.createNewFile(); }} 所在的目录下创建了一个文件——test.txt 删除一个文件或目录12345678910import java.io.File;import java.io.IOException;public class Demo04FileMethod { public static void main(String[] args) throws IOException { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/test.txt\"); file.delete(); }} 所在的目录下的一个文件（test.txt）被删除 创建一个目录12345678910import java.io.File;import java.io.IOException;public class Demo05FileMethod { public static void main(String[] args) throws IOException { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/test\"); file.mkdir(); }} 所在的目录下创建了一个目录——test 创建一个目录集（父子爷孙目录）12345678910import java.io.File;import java.io.IOException;public class Demo06FileMethod { public static void main(String[] args) throws IOException { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/t1/t2/t3\"); file.mkdirs(); }} 在目录“/Users/liyihua/IdeaProjects/Study/src/view/study/demo27”下创建了目录 /t1/t2/t3 File类目录的遍历功能12345public String[] 1ist()// 返回一个String数组，表示该File目录中的所有子文件或目录。public File[] listFiles()// 返回一个File数组，表示该File目录中的所有的子文件或目录。 这两个方法的使用： 123456789101112131415161718192021import java.io.File;public class Demo07FileMethod { public static void main(String[] args) { File file = new File(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo27\"); // 返回一个String数组 String[] stringList = file.list(); // 返回一个File数组 File[] fileList = file.listFiles(); // 遍历数组 for (String s : stringList) { System.out.println(s); } System.out.println(\"\\n\\n\"); for (File f : fileList) { System.out.println(f); } }} 12345678910111213141516171819202122232425262728控制台输出：Demo01PathSeparator.javaDemo01File.javaDemo01FileMethod.javaDemo06FileMethod.javaDemo07FileMethod.javaDemo02FileMethod.java了解File类Demo05FileMethod.javaDemo02File.javaDemo04FileMethod.javaDemo01Separator.javaDemo03FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo01PathSeparator.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo01File.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo01FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo06FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo07FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo02FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/了解File类/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo05FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo02File.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo04FileMethod.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo01Separator.java/Users/liyihua/IdeaProjects/Study/src/view/study/demo27/Demo03FileMethod.java","link":"/p/251703202005/"},{"title":"XML 的学习笔记","text":"@Author: YiHua Lee @Address: Guangdong province, China XML 概念xml简述XML 是 Extensible Markup Language 的简写，是一门可扩展标记语言，结构清晰。 可扩展XML 的标签都是自定义的，不同于html的标签，html的标签是预定义的。如下，标签都是自定义的，想写啥标签就写啥标签： 12&lt;user&gt;&lt;student&gt; 功能xml 的功能是存储数据 配置文件 网络中传输 xml与html的区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 xml 的语法实例引入XmlDemo.xml12345678910111213141516&lt;?xml version='1.0'?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 这里存储的是两个用户的信息，如： 123用户姓名：Lee Hua用户年龄：21用户性别：male 用浏览器打开如下： 基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 假如第一行不是文档声明，如上面实例引入中的例子，改为第一行不是文档声明： 12345678910111213141516&lt;?xml version='1.0'?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 这个时候用浏览器打开报错： xml文档中有且仅有一个根标签，否则会报错，就像XmlDemoError01.png中的类似。如上面实例中的标签。 属性值必须使用引号(单双都可)引起来，否则会报错，就像XmlDemoError01.png中的类似。如上面实例中的id=’1’、id=’2’。 标签必须正确关闭，否则会报错，就像XmlDemoError01.png中的类似。 xml标签名称区分大小写 组成部分文档声明 格式： 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值：yes（不依赖其他文件）、no（依赖其他文件） 指令：结合css的这个了解即可，因为XML主要是用来存储数据的，展示数据就交给HTML吧！！！ 如上面实例引入中： 定义css 123name{ color: coral;} 在文档声明下添加如下内容 1&lt;?xml-stylesheet type=\"text/css\" href=\"a.css\" ?&gt; 然后这个时候再用浏览器打开该实例文件 标签XML 的标签是自定义的，不过也有一定的书写规则。 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性XML 的标签属性是唯一的，要知道我们使用它来存储数据的，通常我们是通过标签的属性值来找到我们需要的数据的，所以我们在定义标签属性的时候要注意标签属性的唯一。 文本 CDATA区：在该区域中的数据会被原样展示。 使用格式： 1&lt;![CDATA[ 数据 ]]&gt; 举例如： 不使用CDATA区： 12345678&lt;?xml version='1.0'?&gt;&lt;coder&gt; &lt;code&gt; if (a &gt; b &amp;amp;&amp;amp; b &gt;c) { a = c; } &lt;/code&gt;&lt;/coder&gt; 用浏览器打开，查看效果如下： 使用CDATA区： 12345678910&lt;?xml version='1.0'?&gt;&lt;coder&gt; &lt;code&gt; &lt;![CDATA[ if (a &gt; b &amp;&amp; b &gt;c) { a = c; } ]]&gt; &lt;/code&gt;&lt;/coder&gt; 用浏览器打开，查看效果如下： 例子说明 我们代码区域使用了“&amp;&amp;”符号，所以我们必须对其进行转义，或者把这段代码写入CDATA区。 XML编写约束作为一个技术的使用者，我们怎么样编写xml文档才能够给程序读懂呢？如我们使用Spring MVC框架，这个时候就可以通过XML文档与这个半成品软件（框架）进行交互。研究者在编写框架的时候，是不知道我们将来编写的XML文档是怎么样的，这个时候就需要一个约束来规定编写，使得技术使用者能够通过阅读框架研究者编写的约束文档，来书写XML文档。 作为框架的使用者(程序员)： 我们要能够在xml中引入约束文档 还需要能够读懂约束文档 约束分类 DTD：一种简单的约束技术 Scheme：一种复杂的约束技术 DTD约束的使用 引入dtd文档到xml文档中。 引入方式： 内部引入：将约束规则定义在xml文档中 外部引入：将约束规则定义在外部的dtd文件中 外部引入的分类： 本地引入： 1&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络引入： 1&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; 举例 定义一个dtd约束文档 123456&lt;!ELEMENT students (student+) &gt;&lt;!ELEMENT student (name,age,sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 文档说明： 通过 ELEMENT 来定义标签，通过 ATTLIST 来定义属性。 文档第一行声明了一个 students 标签，students 标签里面需要放一个或多个 student 子标签。 文档第二行定义了一个 student 标签，每个 student 标签里面可以放 name, age, sex 标签各一个，且需要按顺序。 #PCDATA 声明的是该标签是字符串标签。 文档最后一行， 声明 student 标签有属性，属性名为 number，属性类型为 ID（即属性值必需唯一，不能重复）。#REQUIRED 规定该属性必须出现。 按照 dtd 约束文档，编写 xml 文档 xml 文档声明 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 引入dtd文档到xml文档中 外部引入 1&lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt; 内部引入 12345678&lt;!DOCTYPE students [ &lt;!ELEMENT students (student+) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt; 根据 dtd 约束文档，编写 xml 文档内容 12345678910111213&lt;students&gt; &lt;student number=\"A2018\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"B2018\"&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 必须要按照约束来编写 xml 文档，否则会编译报错。 这个xml文档的所有内容如下： 本地外部引入 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt;&lt;students&gt; &lt;student number=&quot;A2018&quot;&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;B2018&quot;&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 内部引入 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE students [ &lt;!ELEMENT students (student+) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt;&lt;students&gt; &lt;student number=&quot;A2018&quot;&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;B2018&quot;&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; dtd 的的简单理解就完成了 Scheme约束的简单了解对于dtd这个简单的约束技术，是有一定的缺陷的，比如上面的例子中： 12345&lt;student number=\"A2018\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt;&lt;/student&gt; 对于age标签的内容、sex标签的内容，都无法进行约束，如我们把年龄（age）设置为1000，性别（sex）设置为 ABC，这明显是不行的，所以这个时候我们就可以使用更为复杂的约束 —— Scheme XML Schema 是 DTD 的继任者 XML Schema 可针对未来的需求进行扩展 XML Schema 更完善，功能更强大 XML Schema 基于 XML 编写 XML Schema 支持数据类型 XML Schema 支持命名空间 定义一个Scheme约束文档直接对于这个定义的Scheme文档进行理解。 XML Scheme 版本声明 1&lt;?xml version=\"1.0\"?&gt; 对该面结点内的简述： 1&lt;xsd:schema&gt;&lt;/xsd:schema&gt; 代码说明此schema中使用的元素和数据类型来自于“http://www.w3.org/2001/XMLSchema&quot;名称空间（namespace）。它同样指出来自于“http://www.w3.org/2001/XMLSchema&quot;名称空间的（全局）元素和数据类型必须使用带”xsd: “前缀。 1xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" 备注：对于任何一个XML Schema定义文档都有一个最顶层的schema元素。而且该schema元素定义必须包含这个名称空间：http://www.w3.org/2001/XMLSchema。即此名称空间是由XML模式规范定义的标准名称空间-所有XML模式元素必须属于该名称空间。 表明此 schema 定义的元素来自于“http://www.w3schools.com“名称空间。也就是说在引用该 Schema 的其它文档（包括自身文档）中要声明名称空间，其 URI 应该是 targetNamespace 的属性值。 1targetNamespace=\"http://www.w3schools.com\" 该属性值为 qualified 时，说明非全局元素必须添加命名空间的前缀。 该属性值为 unqualified 时，说明非全局元素不必也不能添加前缀。 1elementFormDefault=\"qualified\" 这里的 element ，必须使用 “xsd:” 前缀。定义一个元素，元素名称为”students“，类型为”studentsType“。此类型为自定义类型。下面需要声明这个自定义类型。 1&lt;xsd:element name=\"students\" type=\"studentsType\"/&gt; 对该面这个结点的简述： 12345&lt;xsd:complexType name=\"studentsType\"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=\"student\" type=\"studentType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; 这里的 complexType ，必须使用 “xsd:” 前缀。声明一个（自定义）类型，类型名称为”studentsType“。 1xsd:complexType name=\"studentsType\" 这里的 sequence 和 element ，必须使用 “xsd:” 前缀。”xsd:element“ 定义了一个元素，元素的名称为”student“，类型为”studentType“。这个 student 元素最少出现0次，最多次数没有指定，即0次或多次。 123 &lt;xsd:sequence&gt; &lt;xsd:element name=\"student\" type=\"studentType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt;&lt;/xsd:sequence&gt; 对该这个结点的简述： 12345678&lt;xsd:complexType name=\"studentType\"&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=\"name\" type=\"xsd:string\"/&gt; &lt;xsd:element name=\"age\" type=\"ageType\" /&gt; &lt;xsd:element name=\"sex\" type=\"sexType\" /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=\"number\" type=\"numberType\" use=\"required\"/&gt;&lt;/xsd:complexType&gt; 自定义一个类型”studentType“。 1&lt;xsd:complexType name=\"studentType\"&gt; ... &lt;/xsd:complexType&gt; 里面定义的内容都需要按顺序。 1&lt;xsd:sequence&gt; ... &lt;/xsd:sequence&gt; 定义了三个元素，这三个元素的名称分别是 name、age、sex ，这三个元素的类型分别是string类型、ageType类型、sexType类型。其中string类型是已有类型，其余两个类型需要自定义。 123&lt;xsd:element name=\"name\" type=\"xsd:string\"/&gt;&lt;xsd:element name=\"age\" type=\"ageType\" /&gt;&lt;xsd:element name=\"sex\" type=\"sexType\" /&gt; 定义一个属性，属性名称为 “number“，类型为 “numberType“ ，且这个属性不需要使用。属性类型为自定义类型。 1&lt;xsd:attribute name=\"number\" type=\"numberType\" use=\"required\"/&gt; 对这三个结点的简述： 1234567891011121314151617&lt;xsd:simpleType name=\"sexType\"&gt; &lt;xsd:restriction base=\"xsd:string\"&gt; &lt;xsd:enumeration value=\"male\"/&gt; &lt;xsd:enumeration value=\"female\"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;&lt;xsd:simpleType name=\"ageType\"&gt; &lt;xsd:restriction base=\"xsd:integer\"&gt; &lt;xsd:minInclusive value=\"0\"/&gt; &lt;xsd:maxInclusive value=\"256\"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;&lt;xsd:simpleType name=\"numberType\"&gt; &lt;xsd:restriction base=\"xsd:string\"&gt; &lt;xsd:pattern value=\"stringbug_\\d{4}\"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; xsd:simpleType 定义一个简单的类型 定义一个简单的数据类型，基本的数据类型是string，enumeration 即枚举，数据只能在 “male“ 和 “female“ 之间选择。 123456 &lt;xsd:simpleType name=\"sexType\"&gt; &lt;xsd:restriction base=\"xsd:string\"&gt; &lt;xsd:enumeration value=\"male\"/&gt; &lt;xsd:enumeration value=\"female\"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 定义一个简单的数据类型，基本的数据类型是integer，最大数字是256，最小数字书0。 123456&lt;xsd:simpleType name=\"ageType\"&gt; &lt;xsd:restriction base=\"xsd:integer\"&gt; &lt;xsd:minInclusive value=\"0\"/&gt; &lt;xsd:maxInclusive value=\"256\"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 定义一个简单的数据类型，基本的数据类型是string。 12345&lt;xsd:simpleType name=\"numberType\"&gt; &lt;xsd:restriction base=\"xsd:string\"&gt; &lt;xsd:pattern value=\"stringbug_\\d{4}\"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; “pattern“ 定义一个正则规则，正则表达式为：”stringbug_\\d{4}“ 1&lt;xsd:pattern value=\"stringbug_\\d{4}\"/&gt; XML 文档含有对 XML Scheme 的引用如上定义的XML Scheme 约束，下面简单引用这个约束： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students xmlns=\"http://www.w3schools.com\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3schools.com student.xsd\"&gt; &lt;student number=\"stringbug_2020\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"stringbug_2018\"&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 其中， 1xmlns=\"http://www.w3school.com\" 定义了该xml元素的默认命名空间为”http://www.w3school.com&quot; 1xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 又定义了一个命名空间，和前缀xsi关联， 1xsi:schemaLocation=\"http://www.w3schools.com student.xsd\" 设置xsi前缀代表的命名空间中的一个属性schemaLocation为”http://www.w3schools.com student.xsd” student.xsd 为 scheme 约束文件的文件名，http://www.w3schools.com 为命名空间。Schema中的targetNamespace属性值必须和xsi:schemaLocation属性的第一个值相同。 浏览器中打开： 备注如果需要引入多个 scheme 约束文件，那么我们就需要对这些引入的约束进行命名，用以区分，举例如： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students xmlns:nameDistinction=\"http://www.w3schools.com\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3schools.com student.xsd\"&gt; &lt;nameDistinction:student number=\"stringbug_2020\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/nameDistinction:student&gt; &lt;nameDistinction:student number=\"stringbug_2018\"&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/nameDistinction:student&gt;&lt;/students&gt; 对比一下 XML 文档含有对 XML Scheme 的引用 与 备注 的例子中的区别。 其中最主要的是： 使用自己定义的student.xsd约束文件 引入student.xsd约束文件 XML 文档含有对 XML Scheme 的引用 例子 1xmlns=&quot;http://www.w3schools.com&quot; 采用默认命名，后续的标签都默认使用该约束 备注 中例子 1xmlns:nameDistinction=&quot;http://www.w3schools.com&quot; 这里使用命名为nameDistinction，这个名字可以自己随意定义，后续标签如果需要使用该约束，那么就需要在每个标签中添加”:nameDistinction“。如： 1&lt;nameDistinction:student number=\"stringbug_2020\"&gt; ... &lt;/nameDistinction:student&gt; 而对于 XML 文档含有对 XML Scheme 的引用 例子，不需要添加，因为下面使用的标签都需要根据所引入的约束来编写，如： 1&lt;student number=\"stringbug_2020\"&gt; ... &lt;/student&gt; XML 解析简单的说，对XML文档的解析就是，操作xml文档，将文档中的数据读取到内存中。 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式解析XML的方式有两种，DOM 和 SAX。 DOM方式解析xml文档将标记语言文档一次性加载进内存，在内存中形成一棵dom树。 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX方式解析xml文档该方式是逐行读取，基于事件驱动的。 优点：不占内存。读取一部分内容进内存，释放释放一部分内存。 缺点：只能读取，不能增删改 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 使用 Jsoup 解析 XML快速入门 下载 Jsoup架包：jsoup-1.13.1.jar、jsoup-1.13.1-sources.jar、jsoup-1.13.1-javadoc.jar。 备注：JSoup 官网 导入 Jsoup架包，这里使用的IDEA编程工具： 在项目目录下创建一个文件夹（libs），用来放架包 将下载好的架包复制到libs目录下 导入架包 这里就已经将架包导入到项目中了。 创建一个xml文件，用于后面的使用 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students&gt; &lt;student number=\"stringbug_2020\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"stringbug_2018\"&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 创建一个demo，获取document对象 获取上面创建的xml文件路径，创建该文件对象：student.xml 12345678910// 获取 JsoupDemo01 的字节码对象Class&lt;JsoupDemo01&gt; jsoupDemo01Class = JsoupDemo01.class;// 获取 JsoupDemo01.class 的类加载器ClassLoader classLoader = jsoupDemo01Class.getClassLoader();// 找到对应的资源位置：student.xml 文件位置URL resource = classLoader.getResource(\"jsoup/student.xml\");// 获取 student.xml 路径的字符串标示形式String path = resource.getPath();// 创建文件对象File file = new File(path); 解析xml文档，将xml文档内容加载进内存，获取dom树 1Document parse = Jsoup.parse(file, \"utf-8\"); 获取xml文件内容 根据标签的名称获取xml文件内容 1234567// 获取元素对象Elements name = parse.getElementsByTag(\"name\");// 输出获取到标签内容for (int i = 0; i &lt; name.size(); i++) { System.out.println(name.get(i)); System.out.println(\"------------\");} 123456789// 输出结果如下&lt;name&gt; Lee Hua&lt;/name&gt;------------&lt;name&gt; Rainbow&lt;/name&gt;------------ 获取标签中的文本内容 1234567// 获取元素对象Elements name = parse.getElementsByTag(\"name\");for (int i = 0; i &lt; name.size(); i++) { // 输出获取到的标签文本内容 System.out.println(name.get(i).text()); System.out.println(\"------------\");} 12345// 输出结果如下Lee Hua------------Rainbow------------ 实例代码汇总 jsoup/student.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students&gt; &lt;student number=\"stringbug_2020\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"stringbug_2018\"&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; jsoup/ 1234567891011121314151617181920212223242526272829303132333435363738import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;import java.net.URISyntaxException;import java.net.URL;public class JsoupDemo01 { public static void main(String[] args) throws IOException, URISyntaxException { // 获取 JsoupDemo01.java 的字节码对象 Class&lt;JsoupDemo01&gt; jsoupDemo01Class = JsoupDemo01.class; // 获取 JsoupDemo01.class 的类加载器 ClassLoader classLoader = jsoupDemo01Class.getClassLoader(); // 找到对应的资源位置：student.xml 文件位置 URL resource = classLoader.getResource(\"jsoup/student.xml\"); // 获取 student.xml 路径的字符串标示形式 String path = resource.getPath(); // 创建文件对象 File file = new File(path); // 解析xml文档，将xml文档内容加载进内存，获取dom树 Document parse = Jsoup.parse(file, \"utf-8\"); // 获取元素对象 Elements name = parse.getElementsByTag(\"name\"); for (int i = 0; i &lt; name.size(); i++) { System.out.println(name.get(i)); System.out.println(\"------------\"); } for (int i = 0; i &lt; name.size(); i++) { System.out.println(name.get(i).text()); System.out.println(\"------------\"); } }} 对象的使用 Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document 12345678parse​(File in, String charsetName)// 解析xml或html文件的。parse​(String html)// 解析xml或html字符串parse​(URL url, int timeoutMillis)// 通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 1234567891011getElementById​(String id)// 根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)// 根据标签名称获取元素对象集合 getElementsByAttribute​(String key)// 根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)// 根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList来使用 Element：元素对象 获取子元素对象 1234567891011getElementById​(String id)// 根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)// 根据标签名称获取元素对象集合 getElementsByAttribute​(String key)// 根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)// 根据对应的属性名和属性值获取元素对象集合 获取属性值 12String attr(String key)// 根据属性名称获取属性值 获取文本内容 12345String text()// 获取文本内容String html()// 获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象（了解即可） Node 是Document和Element的父类。 Jsoup 工具类的使用 parse(File in, String charsetName) 解析xml或html文件。 1234567// parse(File in, String charsetName) 解析xml或html文件。// 获取student.xml的pathString path = JsoupDemo02.class.getClassLoader().getResource(\"jsoup/student.xml\").getPath();// 解析xml文档，将xml文档内容加载进内存，获取dom树Document document1 = Jsoup.parse(new File(path), \"utf-8\");// 输出的内容是 student.xml 文档的所有内容System.out.println(document1); parse(String html) 解析xml或html字符串 123456789101112String xml = \"&lt;student number=\\\"stringbug_2020\\\"&gt;\\n\" + \" &lt;name&gt;Lee Hua&lt;/name&gt;\\n\" + \" &lt;age&gt;21&lt;/age&gt;\\n\" + \" &lt;sex&gt;male&lt;/sex&gt;\\n\" + \"&lt;/student&gt;\\n\" + \"&lt;student number=\\\"stringbug_2018\\\"&gt;\\n\" + \" &lt;name&gt;Rainbow&lt;/name&gt;\\n\" + \" &lt;age&gt;20&lt;/age&gt;\\n\" + \" &lt;sex&gt;female&lt;/sex&gt;\\n\" + \"&lt;/student&gt;\";Document document2 = Jsoup.parse(xml);System.out.println(xml); parse(URL url, int timeoutMillis) 通过网络路径获取指定的html或xml的文档对象 123URL url = new URL(\"https://www.baidu.com/\");Document document3 = Jsoup.parse(url, 10000);System.out.println(document3); 代码汇总 1234567891011121314151617181920212223242526272829303132333435363738394041import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.net.URL;public class JsoupDemo03 { public static void main(String[] args) throws IOException { // parse(File in, String charsetName) 解析xml或html文件。 // 获取student.xml的path String path = JsoupDemo02.class.getClassLoader().getResource(\"jsoup/student.xml\").getPath(); // 解析xml文档，将xml文档内容加载进内存，获取dom树 Document document1 = Jsoup.parse(new File(path), \"utf-8\"); // 输出的内容是 student.xml 文档的所有内容 System.out.println(document1); System.out.println(\"===============================================================================\"); // parse(String html) 解析xml或html字符串 String xml = \"&lt;student number=\\\"stringbug_2020\\\"&gt;\\n\" + \" &lt;name&gt;Lee Hua&lt;/name&gt;\\n\" + \" &lt;age&gt;21&lt;/age&gt;\\n\" + \" &lt;sex&gt;male&lt;/sex&gt;\\n\" + \"&lt;/student&gt;\\n\" + \"&lt;student number=\\\"stringbug_2018\\\"&gt;\\n\" + \" &lt;name&gt;Rainbow&lt;/name&gt;\\n\" + \" &lt;age&gt;20&lt;/age&gt;\\n\" + \" &lt;sex&gt;female&lt;/sex&gt;\\n\" + \"&lt;/student&gt;\"; Document document2 = Jsoup.parse(xml); System.out.println(document2); System.out.println(\"===============================================================================\"); // parse(URL url, int timeoutMillis) 通过网络路径获取指定的html或xml的文档对象 URL url = new URL(\"https://www.baidu.com/\"); Document document3 = Jsoup.parse(url, 10000); System.out.println(document3); }} student.xml 文件在当前 .java 文件所在的目录下 Element元素对象的使用 xml字符串内容如下： 解析xml字符串 1Document document = Jsoup.parse(xml); getElementById(String id) 根据id属性值获取唯一的element对象 12Element elementById = document.getElementById(\"666\");System.out.println(elementById); getElementsByTag(String tagName) 根据标签名称获取元素对象集合 12Elements elementsByTag = document.getElementsByTag(\"sex\");System.out.println(elementsByTag); getElementsByAttribute(String key) 根据属性名称获取元素对象集合 12Elements elementsByAttribute = document.getElementsByAttribute(\"number\");System.out.println(elementsByAttribute); getElementsByAttributeValue(String key, String value) 根据对应的属性名和属性值获取元素对象集合 12Elements elementsByAttributeValue = document.getElementsByAttributeValue(\"number\", \"stringbug_2018\");System.out.println(elementsByAttributeValue); 代码汇总 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.IOException;public class JsoupDemo04 { public static void main(String[] args) throws IOException { // 解析xml或html字符串 String xml = \"&lt;student id=\\\"666\\\" number=\\\"stringbug_2020\\\"&gt;\\n\" + \" &lt;name&gt;Lee Hua&lt;/name&gt;\\n\" + \" &lt;age&gt;21&lt;/age&gt;\\n\" + \" &lt;sex&gt;male&lt;/sex&gt;\\n\" + \"&lt;/student&gt;\\n\" + \"&lt;student number=\\\"stringbug_2018\\\"&gt;\\n\" + \" &lt;name&gt;Rainbow&lt;/name&gt;\\n\" + \" &lt;age&gt;20&lt;/age&gt;\\n\" + \" &lt;sex&gt;female&lt;/sex&gt;\\n\" + \"&lt;/student&gt;\"; Document document = Jsoup.parse(xml); // getElementById(String id) 根据id属性值获取唯一的element对象 Element elementById = document.getElementById(\"666\"); System.out.println(elementById); System.out.println(\"===============================================================================\"); // getElementsByTag(String tagName) 根据标签名称获取元素对象集合 Elements elementsByTag = document.getElementsByTag(\"sex\"); System.out.println(elementsByTag); System.out.println(\"===============================================================================\"); // getElementsByAttribute(String key) 根据属性名称获取元素对象集合 Elements elementsByAttribute = document.getElementsByAttribute(\"number\"); System.out.println(elementsByAttribute); System.out.println(\"===============================================================================\"); // getElementsByAttributeValue(String key, String value) 根据对应的属性名和属性值获取元素对象集合 Elements elementsByAttributeValue = document.getElementsByAttributeValue(\"number\", \"stringbug_2018\"); System.out.println(elementsByAttributeValue); }} 选择器查询XML内容12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students&gt; &lt;student id=\"string\" number=\"stringbug_2020\"&gt; &lt;name&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"stringbug_2018\"&gt; &lt;name&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 选择name标签 12Elements name = document.select(\"name\");System.out.println(name); 选择 id=”sting” 的标签 12Elements idString = document.select(\"#string\");System.out.println(idString); 选择 id=”srting” 的标签 下的 name 标签 12Elements idStringName = document.select(\"#string name\");System.out.println(idStringName); 代码汇总 12345678910111213141516171819202122232425262728293031import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class JsoupDemo05 { public static void main(String[] args) throws IOException { // 获取student.xml的path String path = JsoupDemo02.class.getClassLoader().getResource(\"jsoup/student.xml\").getPath(); // 解析xml文档，将xml文档内容加载进内存，获取dom树 Document document = Jsoup.parse(new File(path), \"utf-8\"); // 通过CSS选择器，选择name标签 Elements name = document.select(\"name\"); System.out.println(name); System.out.println(\"===============================================================================\"); // 通过CSS选择器，选择 id=\"string\" 的标签 Elements idString = document.select(\"#string\"); System.out.println(idString); System.out.println(\"===============================================================================\"); // 通过CSS选择器，选择 id=\"sting\" 的标签 下的 name 标签 Elements idStringName = document.select(\"#string name\"); System.out.println(idStringName); }} XPath 获取 XML 内容XPath 概述 XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航。 什么是 XPath： XPath 使用路径表达式在 XML 文档中进行导航 XPath 包含一个标准函数库 XPath 是 XSLT 中的主要元素 XPath 是一个 W3C 标准 XPath 的使用JsoupXPath-0.3.2.jar 下载地址 将下载好的架包导入到项目中 创建一个student.xml文档 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;students&gt; &lt;student number=\"stringbug_2020\"&gt; &lt;name me=\"2020\"&gt;Lee Hua&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"stringbug_2018\"&gt; &lt;name love=\"2018\"&gt;Rainbow&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 在student.xml文档所在的目录下创建一个demo，获取所有student标签 123456789/* \"//\" 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 获取所有student标签 */List&lt;JXNode&gt; students = jxDocument.selN(\"//student\");for (JXNode student : students) { System.out.println(student); System.out.println(\"==========================================\");} 获取所有student标签，然后再获取student标签下的name标签 123456789/* \"/\" 从根节点选取。 获取所有student标签，然后再获取student标签下的name标签 */List&lt;JXNode&gt; names = jxDocument.selN(\"//student/name\");for (JXNode name : names) { System.out.println(name); System.out.println(\"==========================================\");} 获取所有student标签，然后再获取student标签下的name标签，且name标签要有me属性 123456789/* //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 获取所有student标签，然后再获取student标签下的name标签，且name标签要有me属性 */List&lt;JXNode&gt; mes = jxDocument.selN(\"//student/name[@me]\");for (JXNode me : mes) { System.out.println(me); System.out.println(\"==========================================\");} 获取所有student标签，然后再获取student标签下的name标签，name标签要有love属性，且属性值为2018 123456789/* //title[@lang='eng'] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 获取所有student标签，然后再获取student标签下的name标签，name标签要有love属性，且属性值为2018 */List&lt;JXNode&gt; loves = jxDocument.selN(\"//student/name[@love='2018']\");for (JXNode love : loves) { System.out.println(love); System.out.println(\"==========================================\");} 代码汇总 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;import cn.wanghaomiao.xpath.model.JXDocument;import cn.wanghaomiao.xpath.model.JXNode;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.util.List;public class JsoupDemo06 { public static void main(String[] args) throws IOException, XpathSyntaxErrorException { // 获取student.xml的path String path = JsoupDemo02.class.getClassLoader().getResource(\"jsoup/student.xml\").getPath(); // 解析xml文档，将xml文档内容加载进内存，获取dom树 Document document = Jsoup.parse(new File(path), \"utf-8\"); // 根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); /* \"//\" 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 获取所有student标签 */ List&lt;JXNode&gt; students = jxDocument.selN(\"//student\"); for (JXNode student : students) { System.out.println(student); System.out.println(\"==========================================\"); } /* \"/\" 从根节点选取。 获取所有student标签，然后再获取student标签下的name标签 */ List&lt;JXNode&gt; names = jxDocument.selN(\"//student/name\"); for (JXNode name : names) { System.out.println(name); System.out.println(\"==========================================\"); } /* //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 获取所有student标签，然后再获取student标签下的name标签，且name标签要有me属性 */ List&lt;JXNode&gt; mes = jxDocument.selN(\"//student/name[@me]\"); for (JXNode me : mes) { System.out.println(me); System.out.println(\"==========================================\"); } /* //title[@lang='eng'] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 获取所有student标签，然后再获取student标签下的name标签，name标签要有love属性，且属性值为2018 */ List&lt;JXNode&gt; loves = jxDocument.selN(\"//student/name[@love='2018']\"); for (JXNode love : loves) { System.out.println(love); System.out.println(\"==========================================\"); } }} 参考文档 XSD 简易元素 XML和Schema命名空间详解—实例篇 对XSD schema文件中elementFormDefault属性的理解 在 XML 文档中引用 Schema DOM 树 XPath 语法","link":"/p/381608202005/"},{"title":"学会用Java中的Lambda表达式","text":"@Author: YiHua Lee @Address: Guangdong province, China 函数式的编程思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法一一强调做什么，而不是以什么形式做。 冗余的Runnable代码传统写法当需要启动一个线程去完成任务时，通常会通过java.lang. Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789public class Runnable01Implement implements Runnable { /** * 创建Runnable接口的实现类 */ @Override public void run() { System.out.println(Thread.currentThread().getName() + \" 创建了新的线程\"); }} 123456789101112131415161718192021public class Demo01Runnable { public static void main(String[] args) { // 创建Runnable接口的实现类对象 Runnable runnable = new Runnable01Implement(); // 创建Thread对象，传递Runnable接口的实现类对象 Thread thread = new Thread(runnable); // 调用start方法，开启新线程，执行run方法 thread.start(); // 简化代码，使用匿名内部类实现多线程程序 Runnable runnable1 = new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + \" 创建了新的线程\"); } }; // 创建Thread对象，传递Runnable接口的实现类对象，调用start方法，开启新线程，执行run方法 new Thread(runnable1).start(); }} 123控制台输出：Thread-0 创建了新的线程Thread-1 创建了新的线程 代码分析对于Runnable的匿名内部类用法,可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要 Runnable接口的实现类； 为了省去定义一个 Runnable实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 编程思想的转换做什么，而不是怎么做 我们真的希望创建一个匿名内部类对象吗？不，我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码，这オ是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那么，有没有更加简单的办法？如果我们将关注点从”怎么做”回归到”做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 体验Lambda的更优写法借助Java8的全新语法，上述 Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 12345678910111213141516171819public class Demo02Runnable { public static void main(String[] args) { // 简化代码，使用匿名内部类实现多线程程序 Runnable runnable1 = new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + \" 创建了新的线程\"); } }; // 创建Thread对象，传递Runnable接口的实现类对象，调用start方法，开启新线程，执行run方法 new Thread(runnable1).start(); // 借助Java8的全新语法，上述 Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： // 体验Lambda的更优写法 new Thread( () -&gt; System.out.println(Thread.currentThread().getName() + \" 创建了新的线程\") ).start(); }} 这段代码和刚才的执行效果是完全一样的，可以在JDK1.8或更高的编译级別下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定不再有不得不创建接口对象”的東缚，不再有抽象方法覆盖重写”的负担，就是这么简单! 回顾匿名内部类使用匿名内部类这个Runnable实现类只是为了实现 Runnable接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类： 1234567891011121314public class Demo02Runnable { public static void main(String[] args) { // 简化代码，使用匿名内部类实现多线程程序 // 创建Thread对象，传递Runnable接口的实现类对象，调用start方法，开启新线程，执行run方法 new Thread( new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + \" 创建了新的线程\"); } } ).start(); }} 匿名内部类的好处与弊端 好处：匿名内部类可以帮我们省去实现类的定义。 弊端：置名内部类的语法，确实太复杂了! 语义分析仔细分析该代码中的语义，Runnable接口只有一个run方法的定义public abstract void run()也就是制定了一种做事情的方案（其实就是一个函数）： 无参数：不需要迁何条件即可执行该方宰。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中,要更加简单： 1() -&gt; System.out.println(&quot;多线程任务执行!&quot;) 前面的一对小括号即run方法的参数(无)，代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： 1(参数类型 参数名称) -&gt; { 代码语句 } 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 如： 123456789public class Demo04Runnable { public static void main(String[] args) { new Thread( () -&gt; System.out.println(Thread.currentThread().getName() + \" 创建了新的线程\") ).start(); }} 使用Lambda标准格式给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。如下: 123public interface Cook { public abstract void makeFood();} 在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦!”字样： 12345678910111213141516171819202122public class Demo01InvokeCook { public static void main(String[] args) { // 调用invokeCook(Cook cook)方法，传递Cook接口匿名内部类对象 invokeCook( new Cook() { @Override public void makeFood() { System.out.println(\"1吃饭了！！！\"); } } ); // 使用Lambdas的标准格式调用invokeCook方法 invokeCook( () -&gt; System.out.println(\"2吃饭了！！！\") ); } public static void invokeCook(Cook cook) { cook.makeFood(); }} 123控制台输出：1吃饭了！！！2吃饭了！！！ Lambda的参数和返回值 需求：使用数组存储多个Person对象。对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序 下面举例演示java.util.Comparator接口的使用场景代码，其中的抽象方法定义为： 1public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个 Comparator接口实例来指定排序的规则。假设有一个Person类，含有 String name和int age两个成员变量： 12345678910111213141516171819202122232425public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public int getAge() { return age; }} 传统写法1234567891011121314151617181920212223242526272829import java.util.Arrays;import java.util.Comparator;public class Demo01Array { public static void main(String[] args) { // 创建Person集合 Person[] arr = { new Person(\"大哥\", 22), new Person(\"二哥\", 21), new Person(\"小弟\", 20) }; // 调用Arrays类的sort方法，sort方法传递参数：ArrayList集合、排序规则 Arrays.sort( arr, new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return o1.getAge() - o2.getAge(); } } ); // 遍历集合 for (Person person : arr) { System.out.println(person); } }} 1234控制台输出：Person{name='小弟', age=20}Person{name='二哥', age=21}Person{name='大哥', age=22} Lambda表达式写法12345678910111213141516171819202122232425import java.util.Arrays;public class Demo02Array { public static void main(String[] args) { // 创建Person集合 Person[] arr = { new Person(\"大哥\", 22), new Person(\"二哥\", 21), new Person(\"小弟\", 20) }; // 调用Arrays类的sort方法，sort方法传递参数：ArrayList集合、排序规则 Arrays.sort( arr, (Person o1, Person o2) -&gt; { return o1.getAge() - o2.getAge(); } ); // 遍历集合 for (Person person : arr) { System.out.println(person); } }} Lambda省略格式可推导即可省略Lambda强调的是“做什么”而不是怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如： 省略规则在Lambda标准格式的基础上，使用略写法的规则为： 小括号内参数的类型可以省略； 如如果小括号内有且仅有一个参，则小括号可以略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、 return关键字及语句分号。 注意事项：如果要省略 分号、大括号、return关键字，必须三个都同时省略。 使用规则Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda，必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、 Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口称为“函数式接口“。","link":"/p/051703202005/"},{"title":"对 Java IO字符流的简单学习","text":"@Author: YiHua Lee @Address: Guangdong province, China 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储（如：”学生”两个字占用了四个字节）。所以Java提供一些字符流类，以字符为单位读写数据专门用于处理文本文件。 字符输入流 —— Readerjava.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信到内存中。它定义了字符输入流的基本共性功能方法。 12345678public void close()// 关闭此流并释放与此流相关联的任何系统资源。public int read()// 从输入流读取一个字符。public int read(char[] chars)// 从输入流中读取一些字符，并将它们存储到字符数组chars中。 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法： 12345FileReader(File file)// 刨建一个新的FileReader，给定要读取的File对象。Filereader( String filename)// 创建一个新的 FileReader，给定要读取的文件的名称。 举例： 字符输入流Reader，类似于字节输入流InputStream。字符输入流一单个字符为单位，字节输入流以一个字节为单位。 12345678910111213141516171819202122232425/** * 字符输入流使用步骤： * 1、创建FileReader对象，构造方法中绑定要读取的数据源 * 2、使用FileReader对象中的方法read，读取文件 * 3、释放资源 */import java.io.IOException;import java.io.Reader;import java.io.FileReader;public class DemoFileReader { public static void main(String[] args) throws IOException { // 创建FileReader对象，构造方法中绑定要读取的数据源 FileReader fr = new FileReader(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/A\"); // 使用FileReader对象中的方法read，读取文件 int len = 0; while ((len = fr.read()) != -1) { System.out.println((char) len); } // 释放资源 fr.close(); }} 文件A里面的内容： 控制台输出： 1234567891011零一二三四五六七八九十 字符输出流 —— Writerjava.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信思写出到目的地。它定义了字节输出流的基本共性功能方法。 1234567891011121314151617181920public void write(int c)// 写入单个字符。public void write(char cbuf[])// 写入字符数组。abstract public void write(char cbuf[], int off, int len)// 写入字符数组的某一部分，off是数组的开始索引，len是写的字符个数。public void write(String str)// 写入字符串。public void write(String str, int off, int len)//写入字符的某一部分。off是字符的开始素，len是写的字符个数。abstract public void flush()// 刷新该流的缓冲。abstract public void close()// 关闭此流，但要先刷新它。 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 字符输出流的使用步骤： 创建FileWriter对象，构造方法中绑定要写入数据的目的地。 使用 FileWriter中的方法write把数据写入到内存缓冲区中（字符转换为字节的过程） 使用FileWriter中的方法flush，把内存缓冲区中的数据刷新到文件中。 释放资源（会先把内存冲区中的数据刷新到文件中）。 123456789101112131415161718import java.io.IOException;import java.io.FileWriter;public class DemoFileWriter { public static void main(String[] args) throws IOException { // 1.创建FileWriter对象，构造方法中绑定要写入数据的目的地。 FileWriter fw = new FileWriter(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/test.txt\"); // 2.使用FileWriter中的方法write把数据写入到内存缓冲区中（字符转换为字节的过程）。 fw.write(\"Hello FileWriter\"); // 3.使用FileWriter中的方法flush，把内存缓冲区中的数据刷新到文件中。 fw.flush(); // 4.释放资源（会先把内存冲区中的数据刷新到文件中）。 fw.close(); }} 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush方法了。 flush：刷新绶冲区，流对象可以继续使用。 close：先刷新绶冲区，然后通知系统释放资源。流对象不可以再被使用了。 如上个例子，在使用了flush()方法后可以继续使用write方法，而在使用了close()方法后，就不可以继续使用write方法了，否则在运行期会抛出错误。 写出其他数据write(char cbuf[])方法和*write(char cbuf[], int off, int len)方法，每次可以写出字符数组的数据，即将字符数组中的数据写入到文件中去。* 123456789101112131415161718192021import java.io.FileWriter;import java.io.IOException;public class Demo1FileWriter { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/write1.txt\"); char[] chars = \"编程路上的小学生\".toCharArray(); fw.write(chars); char[] chars1 = {97, 98, 99}; fw.write(chars1, 0, 2); fw.flush(); fw.close(); }} 运行结果： 续写与换行操作类似于FileOutputStream 123456789101112131415161718import java.io.FileWriter;import java.io.IOException;public class DemoAppendAddLindWrite { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/test2.txt\", true); fw.write(\"工程师\"); fw.write(\"\\n\"); fw.write(\"程序员\"); fw.flush(); fw.close(); }} 程序运行两次： IO异常的处理12345678910111213141516171819202122232425262728293031323334import java.io.FileWriter;import java.io.IOException;public class DemoFileWriteTryCatch { public static void main(String[] args) { // 创建FileWriter并赋值Null FileWriter fw = null; try { // 创建FileWriter对象 fw = new FileWriter(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/test3.txt\", true); // 写入数据 fw.write(\"处理异常测试输入1\"); fw.write(\"\\n\"); fw.write(\"处理异常测试输入2\"); // 刷新 fw.flush(); } catch (IOException e) { // 自己处理异常 System.out.println(e.getMessage()); } finally { // 无论咋滴，最后都释放资源 try { // 关闭，当且仅当fw != null的时候 assert fw != null; fw.close(); } catch (IOException e) { // 自己处理异常 System.out.println(e.getMessage()); } } }} 运行两次结果： 在JDK7后，可以直接在try后创建流对象，而不用写finally语句块，最后也会释放资源（自动释放资源）。 格式： 12345try (定义流对象1; 定义流对象2.....) { 可能会出现异常的代码块} catch (异常变量 变量名) { 异常的逻辑} 举例（文件复制）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 没使用try...catchimport java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * 文件复制的步骤： * 1.创建一个字节输入流对象，构造方法中绑定要读取的数据源。 * 2.创建一个字节输出流对象，构造方法中绑定要写入的目的地。 * 3.使用字节输入流对象中的方法read读取文件。 * 4.使用字节输出流中的方法write，把读取到的字节写入到目的地的文件中。 * 5.释放资源。 */public class Demo01CopyFile { public static void main(String[] args) throws IOException { // 创建一个字节输入流对象，构造方法中绑定要读取的数据源。 FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo30/666.jpg\"); // 创建一个字节输出流对象，构造方法中绑定要写入的目的地。 FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo30/999.jpg\"); // 使用字节输入流对象中的方法read读取文件。 int len = 0; while ((len = fis.read()) != -1) { // 使用字节输出流中的方法write，把读取到的字节写入到目的地的文件中。 fos.write(len); } // 释放资源。 fis.close(); fos.close(); }}// 使用try...catchimport java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class DemoJDK7 { public static void main(String[] args) { try ( FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/666.jpg\"); FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo31/999.jpg\"); ) { int len = 0; while ((len = fis.read()) != -1) { fos.write(len); } } catch (IOException e) { System.out.println(e.getMessage()); } }} 运行两个程序结果都一样，将文件666.jpg复制为999.jpg","link":"/p/111803202005/"},{"title":"对 Java 中泛型理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 泛型的概念 泛型是一种末知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型 泛型也可以看成是一个变量用来接收数据类型 E e：Element元素 T t：Type类型有无使用泛型的对比 不使用泛型创建集合对象，不使用泛型 好处：集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据。 举例： 1234567891011121314151617181920public class Demo01Generic { public static void main(String[] args) { // 集合不使用泛型 ArrayList arrayList = new ArrayList(); // 向集合中添加数据，用于测试，这里添加了String类型的数据，和int类型的数据 arrayList.add(\"ABC\"); arrayList.add(123); // 使用迭代器遍历集合 // 第一步：获取送代器的实现类对象，并使用Iterator接口接收 Iterator ite = arrayList.iterator(); // 第二步：使用hasNext方法和next方法遍历集合，取出的元素的类型默认是Object类型 while (ite.hasNext()) { System.out.println( ite.next() ); } }} 123输出结果：ABC123 弊端：不安全，会引发异常 12345678910111213141516171819202122public class Demo02Generic { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add(\"ABC\"); arrayList.add(123); Iterator ite = arrayList.iterator(); while (ite.hasNext()) { // 取出的数据，默认是Object类型 Object object = ite.next(); // 假如想使用String特有的length方法来获取字符串的长度，是不可以的 // 需要将Object类型向下转型为String类型才能使用它的特有方法 // 但是集合里面还有数据类型是Integer的数据，所以不能进行向下转型为String类型， // 如果强行转换，那么在运行是会抛出ClassCastException异常 String string = (String)object; System.out.println(string.length()); } }} 123抛出错误：Exception in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at XXXXXX.main(Demo02Generic.java:36) 使用泛型创建集合对象，使用泛型 好处： 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型 把运行期昇常，提升到了编译期 弊端：泛型是什么类型，只能存储什么类型的数据 举例： 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.Iterator;public class Demo03Generic { public static void main(String[] args) { ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(\"ABC\"); // 假如添加的数据的类型不是String类型， // 那么会抛出错误：方法 java,util.Collection.add(java.lang.String)不适用 // arrayList.add(123); Iterator&lt;String&gt; ite = arrayList.iterator(); while (ite.hasNext()) { String string = ite.next(); System.out.println( string.length() ); } }} 12输出结果：3 定义和使用含有泛型的类说明 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类： 定义格式： 1修饰符 class 类名称&lt;代表泛型的变量&gt; { . . . } 举例 创建一个含有泛型的类 1234567891011public class GenericClass&lt;E&gt; { private E name; public E getName() { return name; } public void setName(E name) { this.name = name; }} 使用这个类 123456789101112131415public class DemoGenericClass { public static void main(String[] args) { // 使用泛型 GenericClass&lt;String&gt; name1 = new GenericClass&lt;&gt;(); name1.setName(\"使用泛型：这里只能添加指定类型的数据\"); String string = name1.getName(); System.out.println(string); // 不使用泛型，默认是Object类型 GenericClass name2 = new GenericClass(); name2.setName(\"不使用泛型：这里能添加不同类型的数据\"); Object object = name2.getName(); System.out.println(object); }} 输出结果 12使用泛型：这里只能添加指定类型的数据不使用泛型：这里能添加不同类型的数据 定义和使用含有泛型的方法说明 定义含有泛型的方法:泛型定义在方法的修饰符和返回值类型之间。 格式： 123修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)) { 方法体} 含有泛型的方法，在调用方法的时候确定泛型的数据类型。传递什么类型的参数，泛型就是什么类型。 举例 定义含有泛型的方法 123456789101112131415public class GenericMethod { /** * 定义一个含有泛型的方法 */ public &lt;W&gt; String method1(W w) { return \"一个含有泛型的方法：\" + w; } /** * 定义一个含有泛型的静态方法 */ public static &lt;Z&gt; String method2(Z z) { return \"一个含有泛型的静态方法：\" + z; }} 使用这两个方法 123456789101112131415161718192021222324252627282930public class DemoGenericMethod { public static void main(String[] args) { // 创建类对象 GenericMethod gm = new GenericMethod(); // 调用含有泛型的普通方法 System.out.println( gm.method1(666) ); System.out.println( gm.method1(\"ABC\") ); System.out.println( gm.method1(0.999) ); // 调用含有泛型的静态方法 // 可以使用gm.method2()来调用静态方法 // 不推荐使用创建对象来调用静态方法，推荐直接用类名称来调用 System.out.println( GenericMethod.method2(666) ); System.out.println( GenericMethod.method2(\"ABC\") ); System.out.println( GenericMethod.method2(0.999) ); }} 输出结果 123456一个含有泛型的普通方法：666一个含有泛型的普通方法：ABC一个含有泛型的普通方法：0.999一个含有泛型的静态方法：666一个含有泛型的静态方法：ABC一个含有泛型的静态方法：0.999 定义和使用含有泛型的接口说明 含有泛型的接口，第一种使用方式是：通过定义接口的实现类，实现接口，指定接口的泛型。 含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型。 举例例子1 定义一个含有泛型的接口 12345678public interface GenericInterface&lt;I&gt; { /** * 接口的抽象方法 * @param i 泛型参数 */ public abstract void method(I i);} 创建接口实现类 123456789public class GenericInterfaceImplement implements GenericInterface&lt;String&gt;{ @Override public void method(String s) { System.out.println( \"含有泛型的接口，第一种使用方式是：通过定义接口的实现类，实现接口，指定接口的泛型\\n\" + \"这个方法传入指定类型参数是：\" + s ); }} 测试含有泛型的接口 1234567public class DemoGenericInterfaceImplement { public static void main(String[] args) { GenericInterfaceImplement gii = new GenericInterfaceImplement(); gii.method(\"666999\"); }} 输出结果： 12含有泛型的接口，第一种使用方式是：通过定义接口的实现类，实现接口，指定接口的泛型这个方法传入指定类型参数是：666999 例子2 创建一个含有泛型的接口 12345678public interface GenericInterface&lt;I&gt; { /** * 接口的抽象方法 * @param i 泛型参数 */ public abstract void method(I i);} 创建接口的实现类 12345678910public class GenericInterfaceImplement&lt;I&gt; implements GenericInterface&lt;I&gt;{ @Override public void method(I i) { System.out.println( \"含有泛型的接口第二种使用方式:接口使用什么泛型,实现类就使用什么泛型,类跟着接口走\\n\" + \"创建对象的时候传入指定类型参数是：\" + i ); }} 测试含有泛型的接口 1234567public class DemoGenericInterfaceImplement { public static void main(String[] args) { GenericInterfaceImplement01&lt;Integer&gt; gii = new GenericInterfaceImplement01&lt;&gt;(); gii.method(2020); }} 泛型通配符 通配符基本使用泛型的通配：不知道使用什么类型来接收的时候，此时可以使用?，?表示未知通配符，即：表示任意的数据类型。 使用方式：不能创建对象使用，只能作为方法的参数使用。 注意：一但使用泛型的通配符，那么，只能使用Object类中的共性方法，集合中元素的自身方法无法使用。 举例 创建一个遍历集合的方法 123456789101112public class IteratorArrayList { // 由于不知道接收的ArrayList的数据是什么类型，所以使用泛型通配符? public static void printArrayList(ArrayList&lt;?&gt; arrayList) { // 使用迭代器遍历集合 Iterator&lt;?&gt; ite = arrayList.iterator(); while (ite.hasNext()) { // next()方法取出的元素是Object，可以接收任意的数据类型 Object object = ite.next(); System.out.println(object); } }} 测试这个方法 12345678910111213141516171819202122232425public class DemoIteratorArrayList { public static void main(String[] args) { // Integer类型数据 ArrayList&lt;Integer&gt; arrayList1 = new ArrayList&lt;&gt;(); arrayList1.add(1); arrayList1.add(2); arrayList1.add(3); arrayList1.add(4); arrayList1.add(5); // 遍历Integer数据类型的集合 IteratorArrayList.printArrayList(arrayList1); System.out.println(\"==========================================\"); // String数据类型 ArrayList&lt;String&gt; arrayList2 = new ArrayList&lt;&gt;(); arrayList2.add(\"一号元素\"); arrayList2.add(\"二号元素\"); arrayList2.add(\"三号元素\"); arrayList2.add(\"四号元素\"); arrayList2.add(\"五号元素\"); // 遍历String数据类型的集合 IteratorArrayList.printArrayList(arrayList2); }} 输出结果： 123456789101112345==========================================一号元素二号元素三号元素四号元素五号元素","link":"/p/392001202005/"},{"title":"对 Java 中等待唤醒机制的理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 线程的状态首先了解一下什么是线程的状态，线程状态就是当线程被创建（new），并且启动（start）后，它不是一启动就进入了执行状态（run），也不是一直都处于执行状态。 这里说一下Java 的Thread类里面有一个State方法，这个方法里面涵盖了6种线程的状态，如下： 12345678910111213141516171819public enum State { // 尚未启动的线程的线程状态。 NEW, // 可运行线程的线程状态。 RUNNABLE, // 线程的线程状态被阻塞，等待监视器锁定。 BLOCKED, // 等待线程的线程状态。 WAITING, // 具有指定等待时间的等待线程的线程状态。 TIMED_WAITING, // 终止线程的线程状态。 TERMINATED;} 导致这六种线程状态发生的条件 New – 新建线程刚被创建，不过还没有被启动（还没有调用start方法） Runnable – 可运行处于可运行状态的线程正在Java虚拟机中执行，但是它可能正在等待来自操作系统（例如处理器）的其他资源。 Blocked – 锁阻塞当一个线程想获取一个对象锁，不过该对象锁被其它的线程持有时，该线程就会进入锁阻塞状态；当该线程持有锁的时候，该线程将会变成可运行的状态. Waiting – 无限等待当一个线程在等待另一个线程执行一个（唤醒）动作时，该线程就会进入无限等待状态。进入这个状态后是不能自动唤醒的，要等待另一个线程调用notify()方法，或notifyall()方法才能够被唤醒。 Timed_Waiting – 计时等待类似于无限等待状态，有几个方法有超时参数，如：Thread.sleep、Object.wait方法。调用这些方法，进入计时等待状态。计时等待状态将会一直保持到超时期满或者接收到唤醒通知。 terminated – 被终止 因为run方法的正常退出而死亡。 因为没有捕获的异常，终止了run方法而死亡。 等待唤醒案例切入 顾客要去饭店吃饭，自助下单，说明要吃什么，数量是多少。下完单以后，顾客就等待该饭店厨师做饭菜，也就是Waiting状态（无限等待状态）。 厨师收到下单信息，开始做饭菜，做好饭菜，把饭菜递到顾客桌面上，顾客看到饭菜已经来了（notify方法），就可以开吃了（等待唤醒机制）。 线程之间的通信分析创建一个顾客线程：下单，告知厨师要什么菜，菜的数量，调用wait方法，放弃CPU的执行，进入到无限等待状态（Waiting） 创建一个厨师线程：看到下单，花了3秒钟做饭菜，做好之后，调用notify方法，唤醒顾客吃饭了。 注意顾客线程和厨师线程，必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行。 同步使用的锁对象必须保证唯一。 只有锁对象才能够调用Object.wait方法和Object.notify方法。 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Demo01WaitNotify { public static void main(String[] args) { // 创建锁对象（要保证锁唯一） Object object = new Object(); // 创建一个顾客线程 new Thread() { @Override public void run() { // 使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行。 synchronized (object) { // 顾客下单 System.out.println(\"我要一个西虹市炒番茄，一个马铃薯炒土豆，两碗米饭\"); // 调用wait方法，放弃CPU的执行，进入到无限等待状态（Waiting） try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } // 唤醒之后（饭菜上来后），吃饭！！！真香。 System.out.println(\"我就是饿死，从这里跳下去，也不会吃你们一口饭。。。真香！！！！\"); } } }.start(); // 创建一个厨师线程 new Thread() { @Override public void run() { // 厨师收到下单请求，花三秒钟把饭菜做好 try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } // 使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行。 synchronized (object) { System.out.println(\"我的饭菜三秒钟做好了，你食唔食哦？\"); // 做好之后，调用notify方法，唤醒顾客吃饭了。 object.notify(); } } }.start(); }} 1234控制台输出：我要一个西虹市炒番茄，一个马铃薯炒土豆，两碗米饭我的饭菜三秒钟做好了，你食唔食哦？我就是饿死，从这里跳下去，也不会吃你们一口饭。。。真香！！！！ 备注：上面的代码，存在线程间的通信，那什么又是线程间的通信呢？简单的说，就是多个线程在处理同一个资源，但是处理的动作（线程的任务）却不同。如上，厨师线程做饭菜，顾客线程吃饭菜。那为什么要进行线程间的通信呢？多个线程并发执行的时候，在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且希望它们有规律的执行的时候，那么多线程就之间就需要一些协调通信，来达到多线程共同操作一份数据。 对代码中通信的理解对又没有饭菜进行判断—— 1、没有饭菜（False）。 2、顾客下单。 3、厨师做饭菜。 4、顾客线程等待。 5、厨师做好饭菜 6、修改饭菜的状态（True） 7、有饭菜，厨师线程提醒顾客线程吃饭菜。 8、厨师线程等待 9、吃完饭菜，修改饭菜的状态（False） 这就是顾客线程与厨师线程之间的通信。以此类推，其它Java程序中多线程的通信也是同样的道理。","link":"/p/411603202005/"},{"title":"对 Java 中的Map集合的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China Map集合概述 首先对比一下Map接口和Collection接口 12345// Collection集合，有一个泛型&lt;E&gt;public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; { ... }// Map集合，有两个泛型&lt;K, V&gt;public interface Map&lt;K,V&gt; { ... } 在Collection集合中，E映射的是值的类型。在Map集合中，K映射的是键的类型，V映射的是值的类型。 简单的说，Map集合是一个将键(Key)映射到值(Value)的对象。且一个映射不能包含重复的键；每个键只能映射到一个值。 Map接口提供三种collection视图，允许以Key集、Value集、Key-Value映射关系的形式查看某个映射的内容。映射顺序定义为迭代器在映射的collection视图上返回其元素的顺序。 那什么是映射呢？在生活中，我们常常会看到这样的一种集合：账号——密码、IP地址——主机名、系统用户名——系统用户对象等。像这种一一对应的关系，就叫做映射。在Java中，Map类就是如此，专门用来存放这种对象关系的对象。 Map集合与Collection集合的区别 collection中的集合，元素是孤立存在的(单身狗)，向集合中存储元素采用一个个元素的方式存储。 map中的集合，元素是成对存在的(情侣、夫妻)，每个元素由键(key)与值(value)两个部分组成，通过键可以找到其所对应的值。 collection中的集合成为单列集合，map中的集合称为双列集合。 Collection接口的底层是由哈希表或哈希表+链表实现的。 Map接口的底层是由哈希表和链接列表实现的 简单总结一下Map集合的特点 Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）。 Map集合中的元素，key和value的数据类型可以相同，也可以不同。 Map集合中的元素，key是不允许重复的， value是可以重复的。 Map集合中的元素，key和 value是一一对应的。 Map接口常用的方法1234567891011121314151617public V put(K key, V value)// 把指定的键与指定的值添加到Map集合中。public V remove(Object key)// 把指定的键所对应的键值对元素在Map集合中删除,返回被删除元素的值public V get(Object key)// 根据指定的键,在Map集合中获取对应的值。boolean containsKey(Object key)// 判断集合中是否包含指定的键。public Set&lt;K&gt; keySet()// 获取Map集合中所有的键,存储到Set集合中。public Set&lt;Map. Entry&lt;K,V&gt; entrySet()// 获取到Map集合中所有的键值对对象的集合(Set集合)。 put()方法 作用：把指定的键与指定的值添加到Map集合中。 注意： 当要添加的key不存在的时候，调用put方法后，map集合中会添加新的，添加成功会返回null。 当要添加的key存在的时候，调用put方法后，会使用新的Value替换map集合中旧的Value，替换成功会返回旧的Value。 举例 例子1： 12345678910111213141516import java.util.HashMap;import java.util.Map;public class DemoMapPut { public static void main(String[] args) { // 用多态的形式，创建一个hashMap集合，集合长度为16 Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(16); // 使用Map接口的特有方法put方法，向集合中添加&lt;key-value&gt; String return0 = hashMap.put(\"杨过\", \"小龙女\"); String return1 = hashMap.put(\"过儿\", \"姑姑\"); System.out.println(\"返回值0：\" + return0); System.out.println(\"返回值1：\" + return1); System.out.println(\"Map集合：\" + hashMap); }} 输出结果： 123返回值0：null返回值1：nullMap集合：{杨过=小龙女, 过儿=姑姑} 例子2： 123456789101112131415import java.util.HashMap;import java.util.Map;public class Demo02MapPut { public static void main(String[] args) { Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(16); String return0 = hashMap.put(\"杨过\", \"小龙女\"); String return1 = hashMap.put(\"杨过\", \"姑姑\"); System.out.println(\"返回值0：\" + return0); System.out.println(\"返回值1：\" + return1); System.out.println(\"Map集合：\" + hashMap); }} 输出结果： 123返回值0：null返回值1：小龙女Map集合：{杨过=姑姑} remove()方法 作用：把指定的键所对应的键值对元素在Map集合中删除,返回被删除元素的值。 注意： key存在，删除对应元素，并返回被删除的值 key不存在，返回null 例子： 12345678910111213141516171819import java.util.HashMap;import java.util.Map;public class Demo01MapRemove { public static void main(String[] args) { Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"key0\", \"value0\"); hashMap.put(\"key1\", \"value1\"); hashMap.put(\"key2\", \"value2\"); System.out.println(\"没有调用remove方法前的Map集合：\" + hashMap); String return0 = hashMap.remove(\"key0\"); String return1 = hashMap.remove(\"key666\"); System.out.println(\"返回值0：\" + return0); System.out.println(\"返回值1：\" + return1); System.out.println(\"调用remove方法后的Map集合：\" + hashMap); }} 输出结果： 1234没有调用remove方法前的Map集合：{key1=value1, key2=value2, key0=value0}返回值0：value0返回值1：null调用remove方法后的Map集合：{key1=value1, key2=value2} get()方法 作用：根据指定的键,在Map集合中获取对应的值。 注意： key存在，并返回对应Value值 key不存在，返回null 例子： 1234567891011121314import java.util.HashMap;import java.util.Map;public class Demo01MapGet { public static void main(String[] args) { Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"Aa\", 18); hashMap.put(\"Bb\", 20); System.out.println(\"key是'Aa'对应的Value是：\" + hashMap.get(\"Aa\")); System.out.println(\"key是'BB'对应的Value是：\" +hashMap.get(\"BB\")); }} 输出结果： 12key是'Aa'对应的Value是：18key是'BB'对应的Value是：null containsKey()方法 作用：判断集合中是否包含指定的键。 返回值： key存在的情况下，返回true key不存在的情况下，返回false 例子： 1234567891011121314151617import java.util.HashMap;import java.util.Map;public class Demo01MapContainsKey { public static void main(String[] args) { Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"k1\", 100); hashMap.put(\"k2\", 200); System.out.println(\"hashMap集合：\" + hashMap); boolean response1 = hashMap.containsKey(\"k1\"); boolean response2 = hashMap.containsKey(\"k999\"); System.out.println(\"是否存在键值为'k1'的元素：\" + response1); System.out.println(\"是否存在键值为'k999'的元素：\" + response2); }} 输出结果： 123hashMap集合：{k1=100, k2=200}是否存在键值为'k1'的元素：true是否存在键值为'k999'的元素：false keySet()方法 作用：获取Map集合中所有的键,存储到Set集合中。 返回值：返回Map集合中所有的Key的一个集合对象。 例子： 1234567891011121314151617181920212223import java.util.Map;import java.util.HashMap;import java.util.Set;public class Demo01MapKeySet { public static void main(String[] args) { Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"k1\", 1); hashMap.put(\"k2\", 2); hashMap.put(\"k3\", 3); hashMap.put(\"k4\", 4); hashMap.put(\"k5\", 5); hashMap.put(\"k6\", 6); System.out.println(\"hashMap：\" + hashMap); // 使用keySet()方法，获取Map集合中所有的键,存储到Set集合中。 Set&lt;String&gt; set = hashMap.keySet(); // 输出set集合 System.out.println(\"set：\" + set); }} 输出结果： 12hashMap：{k1=1, k2=2, k3=3, k4=4, k5=5, k6=6}set：[k1, k2, k3, k4, k5, k6] entrySet()方法 作用：获取到Map集合中所有的键值对对象的集合(Set集合)。 返回值：返回值是一个key-value的Set集合对象 注意：由于Map集合中有两个泛型(K, V)，Set集合中只有一个泛型，所以不能直接赋值给Set对象，但可以通过Map.Entry的方式赋值给Set对象 如： 抛出错误： 或者又如： 抛出错误： 赋值给Set集合对象： entrySet方法举例： 1234567891011121314151617181920import java.util.HashMap;import java.util.Map;public class Demo01MapEntrySet { public static void main(String[] args) { Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"k1\", \"1\"); hashMap.put(\"k2\", \"2\"); hashMap.put(\"k3\", \"3\"); hashMap.put(\"k4\", \"4\"); hashMap.put(\"k5\", \"5\"); hashMap.put(\"k6\", \"6\"); System.out.println(\"hashMap：\" + hashMap); // 调用entrySet方法，获取到Map集合中所有的键值对对象的集合 System.out.println(\"键值对对象的集合：\" + hashMap.entrySet()); }} 输出结果： 12hashMap：{k1=1, k2=2, k3=3, k4=4, k5=5, k6=6}键值对对象的集合：[k1=1, k2=2, k3=3, k4=4, k5=5, k6=6] Map集合遍历键(key)的方式找值(Value) 通过Map集合的keySet()方法，获取Map集合中所有的Key，存储到Set集合中 遍历Set集合，获取每个Key所对应的Value 举例： 123456789101112131415161718192021222324252627282930import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Demo01MapIteratorKey { public static void main(String[] args) { Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"k1\", 1); hashMap.put(\"k2\", 2); hashMap.put(\"k3\", 3); hashMap.put(\"k4\", 4); hashMap.put(\"k5\", 5); hashMap.put(\"k6\", 6); System.out.println(\"hashMap：\" + hashMap); Set&lt;String&gt; sKey = hashMap.keySet(); // 获取Set集合的迭代器对象，并遍历该迭代器对象 Iterator&lt;String&gt; ite = sKey.iterator(); while (ite.hasNext()) { // 通过迭代器对象中的每一个值(Map集合中的键)，获取key-value System.out.println( \"Key：\" + ite.next() + \" Value：\" + hashMap.get(ite.next()) ); } }} 输出结果： 1234hashMap：{k1=1, k2=2, k3=3, k4=4, k5=5, k6=6}Key：k1 Value：2Key：k3 Value：4Key：k5 Value：6 Map集合遍历键值对方式例子理解： 12345678910111213141516171819202122232425262728293031import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Demo01MapIteratorKeyValue { public static void main(String[] args) { Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(\"k1\", 1); hashMap.put(\"k2\", 2); hashMap.put(\"k3\", 3); hashMap.put(\"k4\", 4); hashMap.put(\"k5\", 5); hashMap.put(\"k6\", 6); System.out.println(\"hashMap：\" + hashMap); Set&lt;Map.Entry&lt;String, Integer&gt;&gt; keyValue = hashMap.entrySet(); // 获取Set集合的迭代器对象，并遍历该迭代器对象 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; ite = keyValue.iterator(); while (ite.hasNext()) { // 通过Entry对象的getKey()和getValue()方法，获取Key和Value Map.Entry&lt;String, Integer&gt; kv = ite.next(); System.out.println( \"Key：\" + kv.getKey() + \" Value：\" + kv.getValue() ); } }} 输出结果： 1234567hashMap：{k1=1, k2=2, k3=3, k4=4, k5=5, k6=6}Key：k1 Value：1Key：k2 Value：2Key：k3 Value：3Key：k4 Value：4Key：k5 Value：5Key：k6 Value：6 HashMap存储自定义类型的键值注意：Map集合，要保证Key是唯一的。作为Key的元素，必须重写hashCode()方法和equals()方法，才能保证Key的唯一性 代码理解 创建一个Student类，用左Map中Key的数据类型： 123456789101112131415161718public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 创建两个方法： 方法1使用&lt;String, String&gt;为&lt;key, value&gt;的数据类型 方法2使用&lt;Student, String&gt;为&lt;key, value&gt;的数据类型 12345678910111213141516171819202122232425262728293031323334import java.util.HashMap;import java.util.Map;public class MapRepeat { /** * String类型已经重写了hashCode()方法和equals()方法 * 可以保证key唯一 */ public static void method01() { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16); map.put(\"k1\", \"v1\"); map.put(\"k2\", \"v2\"); map.put(\"k3\", \"v3\"); map.put(\"k4\", \"v4\"); map.put(\"k1\", \"v5\"); System.out.println(map); } /** * Student类型没有重写hashCode()方法和equals()方法 * 不能保证key唯一 */ public static void method02() { Map&lt;Student, String&gt; map = new HashMap&lt;&gt;(16); map.put(new Student(\"学生1\", 22), \"v1\"); map.put(new Student(\"学生2\", 18), \"v2\"); map.put(new Student(\"学生3\", 19), \"v3\"); map.put(new Student(\"学生4\", 21), \"v4\"); map.put(new Student(\"学生1\", 22), \"v5\"); System.out.println(map); }} 比较这两个方法： 12345678public class Demo01MapRepeat { public static void main(String[] args) { // Map&lt;String, String&gt;，String类已经重写了hashCode()方法和equals()方法 MapRepeat.method01(); // Map&lt;Student, String&gt;，Student类没有重写了hashCode()方法和equals()方法 MapRepeat.method02(); }} 输出结果： 12{k1=v5, k2=v2, k3=v3, k4=v4}{Student{name='学生1', age=22}=v1, Student{name='学生1', age=22}=v5, Student{name='学生2', age=18}=v2, Student{name='学生4', age=21}=v4, Student{name='学生3', age=19}=v3} 可以看到，方法1输出的集合，并没有重复的Key，而方法2输出的集合存在冲的的Key。其中重复的Key是Student{name=’学生1’, age=22} 在Student类中重写hashCode()方法和equals()方法12345678910111213141516171819202122import java.util.Objects;public class Student { @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, age); }} 那么对MapRepeat.method02()测试，输出结果则是： 1{Student{name='学生4', age=21}=v4, Student{name='学生2', age=18}=v2, Student{name='学生3', age=19}=v3, Student{name='学生1', age=22}=v5} 可以看出，与没有重写hashCode()方法和equals()方法前相比，重写后，不存在重复的key了。 LinkedHashMap集合简单了解 说明： LinkedHashMap类是HashMap的子类 LinkedHashMap底层采用的是哈希表+链表结构，LinkedHashMap集合是有存取顺序的集合，而其父类HashMap是没有存取顺序的集合 例子： 1234567891011121314151617181920212223242526272829import java.util.Map;import java.util.HashMap;import java.util.LinkedHashMap;public class DemoLinkedHashMap { public static void main(String[] args) { // 无序Map集合：HashMap Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(1, 200); hashMap.put(3, 400); hashMap.put(5, 600); hashMap.put(2, 100); hashMap.put(4, 300); hashMap.put(6, 500); System.out.println(hashMap); // 有序Map集合：LinkedHashMap Map&lt;Integer, Integer&gt; linked = new LinkedHashMap&lt;&gt;(16); linked.put(1, 200); linked.put(3, 400); linked.put(5, 600); linked.put(2, 100); linked.put(4, 300); linked.put(6, 500); System.out.println(linked); }} 输出结果： 12{1=200, 2=100, 3=400, 4=300, 5=600, 6=500}{1=200, 3=400, 5=600, 2=100, 4=300, 6=500} Hashtable集合的简单了解说明 java.utiL.Hashtable&lt;k, v&gt;集合 implements Map&lt;K,V&gt;接口Hashtable 底层也是一个哈希表,是一个线程安全的集合，是单线程集合，速度慢 HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快 ArrayList集合、LinkedList集合、HashSet集合、HashMap集合等：可以存储null值【null键】 Hashtable集合，不能存储null值，null键 Hashtable和Vector集合一样，在jdk1.2版本之后被更先进的集合( HashMap、 ArrayList)取代了 Hashtable的子类 Properties依然活跃在历史舞台 Properties集合是一个唯一和I0流相结合的集合 Hashtable传入null，抛出错误 例子12345678910111213141516171819202122import java.util.HashMap;import java.util.Hashtable;public class DemoHashTable { public static void main(String[] args) { HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(null, null); hashMap.put(null, \"A\"); hashMap.put(\"A\", null); hashMap.put(\"B\", \"B\"); System.out.println(\"hashMap：\" + hashMap); Hashtable&lt;String, String&gt; hashtable = new Hashtable&lt;&gt;(16); // Hashtable集合，key和value都不能是null // 如果传入空值，会抛出错误：空指针异常（NullPointerException） // hashtable.put(null, null); // hashtable.put(null, \"A\"); // hashtable.put(\"A\", null); hashtable.put(\"B\", \"B\"); System.out.println(\"hashtable：\" + hashtable); }} 输出结果： 12hashMap：{null=A, A=null, B=B}hashtable：{B=B}","link":"/p/522301202005/"},{"title":"对 Java 异常处理的学习","text":"@Author: YiHua Lee @Address: Guangdong province, China throw关键字 作用：可以使用throw关键字在指定的方法中抛出指定的异常 使用格式： 1throw new xxxException(“异常产生的原因“) 注意事项 throw关键字必须写在方法的内部 throw关键字后边new的对象必须是 Exception或者 Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象。 throw关键字后边创建的是 RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JW处理(打印异常对象，中断程序) throw关键字后边创建的是编译异常，我们就必须处理这个异常，要么 throws,要么try…catch 举例例子1 1234567891011121314151617public class DemoThrow { public static void main(String[] args) { int[] array = {}; int element = DemoThrow.getElement(array, 1); } public static int getElement(int[] array, int index) { if (array.length == 0) { throw new NullPointerException(\"传入的数组为空\"); } else if (index == 0 || index &gt; array.length - 1) { throw new ArrayIndexOutOfBoundsException(\"传递的索引超出了数组的适用范围\"); } else { return array[index]; } }} 1234抛出错误:Exception in thread \"main\" java.lang.NullPointerException: 传入的数组为空 at XXX.DemoThrow.getElement(DemoThrow.java:10) at XXX.DemoThrow.main(DemoThrow.java:5) 例子2 1234567891011121314151617public class DemoThrow { public static void main(String[] args) { int[] array = {1, 2, 3}; int element = DemoThrow.getElement(array, 100); } public static int getElement(int[] array, int index) { if (array.length == 0) { throw new NullPointerException(\"传入的数组为空\"); } else if (index == 0 || index &gt; array.length - 1) { throw new ArrayIndexOutOfBoundsException(\"传递的索引超出了数组的适用范围\"); } else { return array[index]; } }} 1234抛出错误：Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 传递的索引超出了数组的适用范围 at XXX.DemoThrow.getElement(DemoThrow.java:12) at XXX.DemoThrow.main(DemoThrow.java:5) Objects非空判断requireNonNull java.util.Objects类是由一些静态实用方法组成，这些方法是空指针安全的（即：容忍空指针的） 在源码中对对象null值进行了抛出异常错误，源码如下： 123456// 查看指定对象时不时nullpublic static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj;} requireNonNull方法的使用 12345678import java.util.Objects;public class DemoObjectsNonNull { public static void main(String[] args) { String s = null; Objects.requireNonNull(s, \"传入的参数为空\"); }} 1234抛出错误：Exception in thread \"main\" java.lang.NullPointerException: 传入的参数为空 at java.util.Objects.requireNonNull(Objects.java:228) at XXX.DemoObjectsNonNull.main(DemoObjectsNonNull.java:6) 自定义非空判断123456789101112public class DemoObjectsNonNull { public static void main(String[] args) { String s = null; methodNonNull(s); } public static &lt;E&gt; void methodNonNull(E e) { if (e == null) { throw new NullPointerException(\"传入的参数为空\"); } }} 1234抛出错误：Exception in thread \"main\" java.lang.NullPointerException: 传入的参数为空 at XXX.DemoObjectsNonNull.methodNonNull(DemoObjectsNonNull.java:9) at XXX.DemoObjectsNonNull.main(DemoObjectsNonNull.java:5) throws 关键字处理异常throws作用当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象。可以使用 throws关键字处理异常对象，它会把异常对象声明抛给方法的调用者处理(自己不处理，绐别人处理)最终交给JVM–&gt;中断处理 使用格式12345修饰符 返回值类型 方法名(参数列表) throws AaaException, BbbException ... { throw new AaaException(\"产生原因\"); throw new BbbException(\"产生原因\"); ...} 注意事项 throws关键字必须写在方法声明处。 throws关键字后边声明的异常必须是Exception或者是Exception的子类。 方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常。如果批出的多个异常对象有子父类关系，那么直接声明父类异常即可 调用了一个声明抛出异常的方法，我们就必须处理声明的异常，要么继续使用throws声明抛出，交给方法的调用者处理,最终交给JVM，要么try…catch自己处理异常。 举例例子1： 12345678910111213141516import java.io.FileNotFoundException;public class Demo01Throws { public static void main(String[] args) throws FileNotFoundException{ String s = \"/Users/data.txt\"; readFile(s); } public static void readFile(String s) throws FileNotFoundException { if (\"/Users/data.txt\".equals(s)) { System.out.println(\"传入的参数是'/Users/data.txt'\"); } else { throw new FileNotFoundException(\"传入的参数不是'/Users/data.txt'\"); } }} 12输出结果：传入的参数是'/Users/data.txt' 例子2： 12345678910111213141516import java.io.FileNotFoundException;public class Demo01Throws { public static void main(String[] args) throws FileNotFoundException{ String s = \"/Users/data\"; readFile(s); } public static void readFile(String s) throws FileNotFoundException { if (\"/Users/data.txt\".equals(s)) { System.out.println(\"传入的参数是'/Users/data.txt'\"); } else { throw new FileNotFoundException(\"传入的参数不是'/Users/data.txt'\"); } }} 1234抛出错误：Exception in thread \"main\" java.io.FileNotFoundException: 传入的参数不是'/Users/data.txt' at XXX.Demo01Throws.readFile(Demo01Throws.java:11) at XXX.Demo01Throws.main(Demo01Throws.java:6) try catch 关键字处理异常使用格式123456789try { ...} catch (异常类名 变量名) { ...}...catch(异常类名 变量名) { ...} ... 注意事项 try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象。 如果try中产生了异常，那么就会执行ctch中的异常处理逻辑，执行完catch中的处理逻辑，会继续执行try…catch之后的代码。 如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try…catch之后的代码。 举例12345678910111213141516public class Demo01TryCatch { public static void main(String[] args) { try { String[] strings = {}; System.out.println(strings[100]); } catch (ArrayIndexOutOfBoundsException e) { // 数组索引越界异常 System.out.println(\"Exception in thread \\\"main\\\" java.lang.ArrayIndexOutOfBoundsException\"); } catch (NullPointerException e) { // 空指针异常 System.out.println(\"Exception in thread \\\"main\\\" java.lang.NullPointerException\"); } System.out.println(\"程序执行完成\"); }} 123输出结果：Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException程序执行完成 Throwable类中3个异常处理的方法123456public void printStackTrace()// 打印异常的跟踪栈信息，并输出到控制台。包含了异常的类型，异常的原因，还包括异常出现的位置。在开发和调试阶段都得使用printStackTrace。public String getMessage()// 获取发生异常的原因。提示给用户时候就提示误原因。public String toString()// 获取异常的类型和异常描述信息。 这三个方法源码： 123public void printStackTrace() { printStackTrace(System.err);} 123public String getMessage() { return detailMessage;} 12345public String toString() { String s = getClass().getName(); String message = getLocalizedMessage(); return (message != null) ? (s + \": \" + message) : s;} 三个方法举例12345678910111213141516171819202122232425public class DemoTryCatch { public static void main(String[] args) { try { String[] strings = new String[10]; getElement(strings, 10); } catch (ArrayIndexOutOfBoundsException e) { // 获取发生异常的原因 System.out.println(e.getMessage()); // 获取异常的类型和异常描述信息 System.out.println(e.toString()); // 获取栈的跟踪信息（异常的类型、异常的原因、异常出现的位置） e.printStackTrace(); } } public static String getElement(String[] array, int index) { if (array.length == 0) { throw new NullPointerException(\"传入的数组为空\"); } else if (index == 0 || index &gt; array.length - 1) { throw new ArrayIndexOutOfBoundsException(\"传递的索引超出了数组的适用范围\"); } else { return array[index]; } }} 123456控制台输出：传递的索引超出了数组的适用范围java.lang.ArrayIndexOutOfBoundsException: 传递的索引超出了数组的适用范围java.lang.ArrayIndexOutOfBoundsException: 传递的索引超出了数组的适用范围 at XXX.DemoTryCatch.getElement(DemoTryCatch.java:19) at XXX.DemoTryCatch.main(DemoTryCatch.java:5) finally代码块格式1234567891011try { ...} catch (异常类名 变量名) { ...}...catch(异常类名 变量名) { ...} finally { ...} 注意事项 finally不能单独使用，必须要和try一起使用 finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放IO 举例123456789101112131415public class DemoFinally { public static void main(String[] args) { try { String[] strings = {}; System.out.println(strings[100]); } catch (ArrayIndexOutOfBoundsException e) { // 获取异常的类型和异常描述信息 System.out.println(e.toString()); } finally { System.out.println(\"程序执行完成\"); } }} 123控制台输出：java.lang.ArrayIndexOutOfBoundsException: 100程序执行完成 多异常的捕获处理多个异常分别处理实例理解： 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Demo01ManyException { public static void main(String[] args) { try { int[] array = {1, 2, 3}; int a = array[3]; } catch (ArrayIndexOutOfBoundsException e) { System.out.println(e.toString()); } try { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, 1, 2, 3); int b = list.get(3); } catch (IndexOutOfBoundsException e) { System.out.println(e.toString()); } }} 123控制台输出：java.lang.ArrayIndexOutOfBoundsException: 3java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 多个异常一次捕获多次处理实例理解： 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Demo01ManyException { public static void main(String[] args) { try { int[] array = {1, 2, 3}; int a = array[3]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, 1, 2, 3); int b = list.get(3); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(e.toString()); } catch (IndexOutOfBoundsException e) { System.out.println(e.toString()); } }} 12控制台输出：java.lang.ArrayIndexOutOfBoundsException: 3 注意事项一个try，多个catch，catch里面定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在前面，否则会报错 如ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException： 多个异常一次捕获一次处理实例理解： 123456789101112131415161718192021import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Demo01ManyException { public static void main(String[] args) { try { int[] array = {1, 2, 3}; int a = array[3]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, 1, 2, 3); int b = list.get(3); } catch (Exception e) { System.out.println(e.toString()); } }} 12控制台输出：java.lang.ArrayIndexOutOfBoundsException: 3 finally有return语句如果finally中有return语句，只会返回finally中的值。 如： 1234567891011121314151617public class Demo01FinallyReturn { public static void main(String[] args) { System.out.println(Demo01FinallyReturn.method()); } public static String method() { try { String s = \"abc\"; return s; } catch (Exception e) { e.printStackTrace(); } finally { String s = \"ABC\"; return s; } }} 12控制台输出：ABC 子父类异常 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。 如： 1234567891011public class Fu { public static void method1() throws NullPointerException, ClassCastException { } public static void method2() throws IndexOutOfBoundsException { } public static void method3() { } public static void method4() { }} 123456789101112131415161718192021222324252627282930313233public class Zi extends Fu { /** * 子类重写父类方法时，抛出和父类相同的异常 * @throws NullPointerException 空指针异常 * @throws ClassCastException 类强制转换异常 */ public static void method1() throws NullPointerException, ClassCastException { } /** * 子类重写父类方法时，抛出父类异常的子类 * @throws ArrayIndexOutOfBoundsException 索引越界异常 */ public static void method2() throws ArrayIndexOutOfBoundsException { } /** * 子类重写父类方法时，不抛出异常 */ public static void method3() { } /** * 父类方法没有抛出异常，子类重写父类方法时，也不可以抛出异常 * 只能捕获处理，不能声明抛出 */ public static void method4(){ try { throw new Exception(\"编译期异常\"); } catch (Exception e) { e.printStackTrace(); } }} 自定义异常类的简单练习要求模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 分析 使用数组保存已经注册过的用户名 使用Scanner获取用户输入的注册的用户名 定义一个方法，对用户输入中的注册用户名进行判断，遍历存储已经注册过用户名的数组，获取每一个用户名，使用获取到的用户名和用户输入的用户名比较 实现123456789101112131415161718192021222324252627import java.util.Scanner;public class MyUsersException { private static String[] names = {\"小红\", \"小明\", \"李华\", \"小军\", \"大雄\"}; public static void registerUser(String scannerUser) { for (String name : names) { if (name.equals(scannerUser)) { try { throw new RuntimeException(\"亲，该用户名已被注册！\"); } catch (RuntimeException e) { System.out.println(e.getMessage()); return; } } } System.out.println(\"恭喜您注册成功!\"); } public static void main(String[] args) throws RuntimeException{ Scanner scn = new Scanner(System.in); System.out.print(\"输入要注册的用户名：\"); String registerUserName = scn.next(); MyUsersException.registerUser(registerUserName); }} 123控制台输入：李华控制台输出：亲，该用户名已被注册！ 123控制台输入：静香控制台输出：恭喜您注册成功!","link":"/p/201502202005/"},{"title":"对 Java 线程池的理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 线程池的思想概述 我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结東了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务?Java中可以通过线程池来达到这样的效果。下面们就来详细讲解一下Java的线程池。 线程池概念线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需因为反复创建线程而消耗过多资源。 由于线程池中有很多操作都是与优化资源相关的，在这里就不多述。我们通过一张图来了解线程池的工作原理 合理利用线程池好处 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下（每个线程需要大约1MB内存,线程开的越多，消耗的内存也就越大，最后死机）。 线程池的原理 当程序第一次启动的时候创建多个线程保存到一个集合中 当我们想要使用线程的时候就可以从集合中取出来线程使用 Thread t = list.remove(index);返回的是被移除的元素（线程只能被一个任务使用） Thread t = linked.removeFirst();返回的是被移除的第一个元素 当我们使用完毕线程需要把线程归还给线程池 list. add(t); linked.add Last(t); 线程池的简单实现说明 线程池：JDK1.5之后提供的java.util.concurrent.Executors：线程池的工厂类，用来生成线程池。 Executors类中的静态方法static ExecutorService newFixedThreadPool( int nThreads)：创建一个可重用固定线程数的转程池 参数：int nThreads：创建线程池中包含的线程数量 返回值：ExecutorService接口，返回的是 ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程） java.util.concurrent.ExecutorService：线程池接口用来从线程池中获取线程，调用start方法，执行线程任务。 submit(Runnable task)：提交一个 Runnable任务用于执行 void shutdown()：关闭/销毁线程池 线程池使用步骤 使用线程池的工厂类Executors里边提供的静态方法 newFixedThreadPool生产一个指定线程数量的线程池。 创建一个类，实现Runnable接口重写run方法，设置线程任务。 调用ExecutorService中的方法 submit，传递线程任务(实现类)开启线程，执行run方法。 调用ExecutorService中的方法 shutdown销毁线程池(不建议执行) Java代码实现12345678910111213141516171819import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class DemoThreadPool { public static void main(String[] args) { // 1.使用线程池的工厂类Executors里边提供的静态方法 newFixedThreadPool生产一个指定线程数量的线程池。 ExecutorService executorService = Executors.newFixedThreadPool(3); // 3.调用ExecutorService中的方法submit，传递线程任务(实现类)开启线程，执行run方法。 // 线程池会一直开启，使用完了线程，会自动把线程归还给线程池，线程池可以继续使用 executorService.submit(new Runnable01()); executorService.submit(new Runnable01()); executorService.submit(new Runnable01()); executorService.submit(new Runnable01()); // 4.调用ExecutorService中的方法 shutdown销毁线程池(不建议执行) // executorService.shutdown(); }} 12345控制台输出：线程名称：pool-1-thread-2线程名称：pool-1-thread-1线程名称：pool-1-thread-3线程名称：pool-1-thread-3","link":"/p/511603202005/"},{"title":"对Java中可变参数的理解","text":"@Author: YiHua Lee @Address: Guangdong province, China 说明：可变参数:是DK1.5之后出现的新特性，其实可变参数是0、1、2、3、….个参数的数组。 使用前提：当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数。 使用格式： 1修饰符 返回值类型 方法名(数据类型 ... 变量名) { 方法内容区 } 可变参数原理：可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数传递的参数个数,可以是0个(不传递)、1、2、3……多个。 举例： 12345678910111213import java.util.Arrays;public class VariableParameters { public static void main(String[] args) { method(1, 2, 3, 4, 5); } public static int method(int ... ints) { System.out.println(\"可变参数（数组）：\" + Arrays.toString(ints)); System.out.println(\"可变参数（数组）长度，即数组元素个数：\" + ints.length); return 0; }} 123输出结果：可变参数（数组）：[1, 2, 3, 4, 5]可变参数（数组）长度，即数组元素个数：5 注意事项： 一个方法的参数列表，只能有一个可变参数 一个方法的参数列表中有多个不同的参数时，可变参数要放在其他所有参数的后面 如上图：只有一个可变参数，抛出错误（可变参数，必须在参数列表最后） 如上图：有两个可变参数，还是抛出同样的错误（可变参数，必须在参数列表最后），也就是说只能有一个可变参数 可变参数的特殊写法： 1234public static void method(Object o) {}// 在不知道要传入什么类型的参数时，可以使用Object，Object可以接收任意数据类型的参数","link":"/p/022301202005/"},{"title":"对MVC设计思想的理解","text":"@Author: YiHua Lee @Address: Guangdong province, China jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦。 后来jsp简化了Servlet的开发，如果过度使用jsp，在jsp中写大量的java代码，又写html标签，造成难于维护，难于分工协作。 再后来，java的web开发，借鉴mvc设计思想，使得程序的设计更加合理性 MVC设计思想 MVC不是一种设计模式，而是一种设计思想，概念的区别： 设计模式：是一种固定的方法，不灵活，有特定的使用场景； 设计思想：是一种思想，比较灵活，由多种设计模式组合实现。 MVC的设计思想： M（Model）：主要功能提供数据（主要用来提供数据，不关心数据让谁显示（Controller 负责给M要数据，然后控制数据让哪一个View来显示））； V（View）：主要功能是展示数据（主要有数据即可，不关心数据来源）； C（Controller）：主要功能协调V层与M层，作为V层与M层沟通的桥梁。 流程： 首先浏览器发送请求,Controller获取用户的请求， 然后Controller调用Model，让Model里的业务操作来进行处理， Model处理完毕后将返回的模型数据返回给Controller， Controller根据模型返回会的数据选择视图，展示模型。 MVC优缺点 优点： 降低代码耦合性，方便维护，可以利于分工协作。所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。 有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。 缺点： 增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 对开发人员要求高。 视图层展示依赖与模型层，视图层需要很少的字段，但是模型层全部提供，性能上有一定影响。 参考文献 怎么理解MVC设计思想 荐 两张图彻底搞懂MVC模型和三层框架以及区别和优缺点 建议收藏！","link":"/p/502105202006/"},{"title":"对集合元素进行处理：传统方式和Stream方式的对比","text":"@Author: YiHua Lee @Address: Guangdong province, China 题目现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环(或增强for循环)依次进行以下若干操作步骤： 第一个队伍只要名字为3个字的成员姓名;存储到一个新集合中。 第一个队伍筛选之后只要前3个人;存储到一个新集合中。 第二个队伍只要姓张的成员姓名;存储到一个新集合中。 第二个队伍筛选之后不要前2个人;存储到一个新集合中。 将两个队伍合并为一个队伍;存储到一个新集合中。 根据姓名创建 Person 对象;存储到一个新集合中。 打印整个队伍的Person对象信息。两个队伍(集合)的代码如下： 1234567891011121314import java.util.ArrayList;import java.util.Collections;public class DemoArrayListNames { public static void main(String[] args) { //第一支队伍 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); Collections.addAll(one, \"迪丽热巴\", \"宋远桥\", \"苏星河\", \"石破天\", \"石中玉\", \"老子\", \"庄子\", \"洪七公\"); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); Collections.addAll(two, \"古力娜扎\", \"张无忌\", \"赵丽颖\", \"张三丰\", \"尼古拉斯赵四\", \"张天爱\", \"张二狗\"); }} Person 类的代码为： 1234567891011121314public class Person { private String name; public Person() { } public Person(String name) { this.name = name; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 传统方式解答既然使用传统的for循环写法，那么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.ArrayList;import java.util.Collections;import java.util.List;public class DemoArrayListNamesTradition { public static void main(String[] args) { //第一支队伍 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); Collections.addAll(one, \"迪丽热巴\", \"宋远桥\", \"苏星河\", \"石破天\", \"石中玉\", \"老子\", \"庄子\", \"洪七公\"); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); Collections.addAll(two, \"古力娜扎\", \"张无忌\", \"赵丽颖\", \"张三丰\", \"尼古拉斯赵四\", \"张天爱\", \"张二狗\"); // 第一个队伍只要名字为3个字的成员姓名; List&lt;String&gt; oneA = new ArrayList&lt;&gt;(); for (String name : one) { if (name.length() == 3) { oneA.add(name); } } // 第一个队伍筛选之后只要前3个人; List&lt;String&gt; oneB = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { oneB.add(oneA.get(i)); } // 第二个队伍只要姓张的成员姓名; List&lt;String&gt; twoA = new ArrayList&lt;&gt;(); for (String name : two) { if (name.startsWith(\"张\")) { twoA.add(name); } } // 第二个队伍筛选之后不要前2个人; List&lt;String&gt; twoB = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; twoA.size(); i++) { twoB.add(twoA.get(i)); } // 将两个队伍合并为一个队伍; List&lt;String&gt; totalNames = new ArrayList&lt;&gt;(); totalNames.addAll(oneB); totalNames.addAll(twoB); // 根据姓名创建Person对象; List&lt;Person&gt; totalPersonList = new ArrayList&lt;&gt;(); for (String name : totalNames) { totalPersonList.add(new Person(name)); } // 打印整个队伍的Person对象信息。 for (Person person : totalPersonList) { System.out.println(person); } }} 运行程序，控制台输出： 12345Person{name='宋远桥'}Person{name='苏星河'}Person{name='石破天'}Person{name='张天爱'}Person{name='张二狗'} Stream方式解答12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.Collections;import java.util.stream.Stream;public class DemoArrayListNamesStream { public static void main(String[] args) { //第一支队伍 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); Collections.addAll(one, \"迪丽热巴\", \"宋远桥\", \"苏星河\", \"石破天\", \"石中玉\", \"老子\", \"庄子\", \"洪七公\"); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); Collections.addAll(two, \"古力娜扎\", \"张无忌\", \"赵丽颖\", \"张三丰\", \"尼古拉斯赵四\", \"张天爱\", \"张二狗\"); // 第一个队伍只要名字为3个字的成员姓名; Stream&lt;String&gt; streamOneA = one.stream().filter(name -&gt; name.length() == 3); // 第一个队伍筛选之后只要前3个人; Stream&lt;String&gt; streamOneB = streamOneA.limit(3); // 第二个队伍只要姓张的成员姓名; Stream&lt;String&gt; streamTwoA = two.stream().filter(name -&gt; name.startsWith(\"张\")); // 第二个队伍筛选之后不要前2个人; Stream&lt;String&gt; streamTwoB = streamTwoA.skip(2); // 将两个队伍合并为一个队伍; Stream&lt;String&gt; totalNames = Stream.concat(streamOneB, streamTwoB); // 根据姓名创建Person对象; Stream&lt;Person&gt; personStream = totalNames.map(personName -&gt; new Person(personName)); // 打印整个队伍的Person对象信息。 personStream.forEach(System.out::println); }} 运行程序，控制台输出： 12345Person{name='宋远桥'}Person{name='苏星河'}Person{name='石破天'}Person{name='张天爱'}Person{name='张二狗'} 该程序中，使用的Stream接口中的方法：java.util.stream.Stream 接口中的常用方法。","link":"/p/351404202005/"},{"title":"对 SpringMVC 的简单认识","text":"@Author: YiHua Lee @Address: Guangdong province, China SpringMVC 的基本概念 系统标准的三层架构包括：表现层、业务层、持久层。 三层架构中，每一层各司其职： 表现层 也就是我们常说的 web 层。它负责接收客户端请求，向客户端响应结果，通常客户端使用 http 协议请求web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层 也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体， 数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 MVC 模型 MVC 全名是 Model View Controller： Model（模型） View（视图） Controller（控制器） SpringMVC SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架 ，属于 Spring FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 在三层架构的位置 SpringMVC 的优势 清晰的角色划分： 前端控制器（DispatcherServlet） 请求到处理器映射（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 处理器或页面控制器（Controller） 验证器（ Validator） 命令对象（Command） 请求参数绑定到的对象就叫命令对象） 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要 。 由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。 强大的 JSP 标签库，使 JSP 编写更容易。 参考文献黑马 Java","link":"/p/512215202008/"},{"title":"数据库连接池 —— C3P0的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China C3P0：是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。 使用步骤 导入jar包： c3p0-0.9.5.2.jar、mchange-commons-java-0.2.12.jar、mysql-connector-java-5.1.48.jar 定于配置文件：可以命名为c3p0-config.xml 12345678910111213141516171819202122232425262728&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/Study&lt;/property&gt; &lt;property name=\"user\"&gt;登录数据库的用户&lt;/property&gt; &lt;property name=\"password\"&gt;登录数据库的密码&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=\"otherc3p0\"&gt; &lt;!-- 连接参数 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/Study&lt;/property&gt; &lt;property name=\"user\"&gt;登录数据库的用户&lt;/property&gt; &lt;property name=\"password\"&gt;登录数据库的密码&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;8&lt;/property&gt; &lt;property name=\"checkoutTimeout\"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 创建数据库连接池对象 1DataSource dataSource = new ComboPooledDataSource(); 获取数据库连接对象 1Connection connection = dataSource.getConnection(); 举例如下： 12345678910111213141516171819202122package my.view.datasource.c3p0;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class C3P0Demo01 { public static void main(String[] args) throws SQLException { // 创建数据库连接池对象 DataSource dataSource = new ComboPooledDataSource(); // 获取一个连接对象 Connection connection = dataSource.getConnection(); // 打印获取的连接对象的地址值 System.out.println(connection); }} 配置文件说明获取MySQL驱动 1&lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; 要连接的数据库地址 1&lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/Study&lt;/property&gt; 登录数据库时的用户名 1&lt;property name=\"user\"&gt;登录数据库的用户&lt;/property&gt; 登录数据库是用户名对应的密码 1&lt;property name=\"password\"&gt;登录数据库的密码&lt;/property&gt; 初始化申请的数据库连接数量 1&lt;property name=\"initialPoolSize\"&gt;最小数量&lt;/property&gt; 最大的数据库连接数量 1&lt;property name=\"maxPoolSize\"&gt;最大数量&lt;/property&gt; 毫秒为单位的超时时间 1&lt;property name=\"checkoutTimeout\"&gt;超时时间&lt;/property&gt; 默认配置 12345&lt;default-config&gt; .......&lt;/default-config&gt; 指定名称配置 12345&lt;named-config name=\"名称\"&gt; ......&lt;/named-config&gt; 配置的使用使用默认配置 12// 创建数据库连接池对象DataSource dataSource = new ComboPooledDataSource(); 使用指定名称配置 12// 创建数据库连接池对象DataSource dataSource = new ComboPooledDataSource(\"名称\"); 举例如c3p0-config.xml中的默认配置，最大数据库连接对象是10个。 获取10个数据库连接对象： 123456789101112131415161718192021222324package my.view.datasource.c3p0;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class C3P0Demo02 { public static void main(String[] args) throws SQLException { // 创建数据库连接池对象 DataSource dataSource = new ComboPooledDataSource(); for (int i = 0; i &lt; 10; i++) { // 获取一个连接对象 Connection connection = dataSource.getConnection(); // 打印获取的连接对象的地址值 System.out.println(i + \" ———— \" + connection); } }} 运行程序，控制台输出连接池中获取的所有数据库连接对象的地址值： 123456780 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@71e7a66b [wrapping: com.mysql.jdbc.JDBC4Connection@2ac1fdc4]1 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@1c53fd30 [wrapping: com.mysql.jdbc.JDBC4Connection@50cbc42f]2 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@282ba1e [wrapping: com.mysql.jdbc.JDBC4Connection@13b6d03]5 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@326de728 [wrapping: com.mysql.jdbc.JDBC4Connection@25618e91]6 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@71f2a7d5 [wrapping: com.mysql.jdbc.JDBC4Connection@2cfb4a64]7 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@4b6995df [wrapping: com.mysql.jdbc.JDBC4Connection@2fc14f68]8 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@66048bfd [wrapping: com.mysql.jdbc.JDBC4Connection@61443d8f]9 ———— com.mchange.v2.c3p0.impl.NewProxyConnection@61a52fbd [wrapping: com.mysql.jdbc.JDBC4Connection@233c0b17] 获取超过10个数据库连接对象，如获取11个数据库连接池对象，运行程序，会抛出异常： 1Exception in thread &quot;main&quot; java.sql.SQLException: An attempt by a client to checkout a Connection has timed out. 获取第11个熟即可连接池对象的时候，超时（如上配置的超时时间为3秒钟）。那么该如何解决呢？很简单，我获取完一个数据连接池对象，就归还给数据库连接池即可，保证数据库连接池有数据库连接对象可以获取，操作如下： 123456789101112131415161718192021222324252627package my.view.datasource.c3p0;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;public class C3P0Demo03 { public static void main(String[] args) throws SQLException { // 创建数据库连接池对象 DataSource dataSource = new ComboPooledDataSource(); for (int i = 0; i &lt; 11; i++) { // 获取一个连接对象 Connection connection = dataSource.getConnection(); // 打印获取的连接对象的地址值 System.out.println(i + \" ———— \" + connection); // 将获取到的数据库连接对象归还给数据库连接池 connection.close(); } }}","link":"/p/201506202005/"},{"title":"控制反转-Inversion Of Control","text":"@Author: YiHua Lee @Address: Guangdong province, China 什么是工厂 工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 控制反转 控制反转(Inversion of Control,英文缩写为I0C)把创建对象的权利交给框架,是框架的重要特征,并非面向对象编程的专用术语。它包括依赖注入(Dependency Injection,简称DI)和依赖查找( Dependency Lookup) . 原来：我们在获取对象时，都是采用 new 的方式。是主动的。 现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。 是被动的。 ioc 的作用 ：削减计算机程序的耦合(解除我们代码中的依赖关系)。","link":"/p/002225202007/"},{"title":"数据库连接池 —— Druid的简单使用","text":"@Author: YiHua Lee @Address: Guangdong province, China Druid不仅是一个数据库连接池，还包含一个ProxyDriver、一系列内置的JDBC组件库、一个SQL Parser。支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等。 使用步骤一定要导入jar架包。要配置好文件，如果不配置文件，记得在程序中自行添加。 导入jar包： druid-1.0.9.jar、mysql-connector-java-5.1.48.jar 定义配置文件：可以命名为druid-1.0.9.properties 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://MySQL地址/数据库名username=用户名password=密码initialSize=初始化连接数maxActive=最大连接数maxWait=最大等待时间（毫秒为单位） 加载配置文件druid-1.0.9.properties 获取连接池对象 获取数据库连接 举例如下： 1234567891011121314151617181920212223242526272829303132333435package my.view.datasource.druid;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;public class DruidDemo { public static void main(String[] args) throws Exception { // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取类的类加载器 ClassLoader classLoader = DruidDemo.class.getClassLoader(); // 获取druid-1.0.9.properties配置文件资源输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid-1.0.9.properties\"); // 加载配置文件 properties.load(resourceAsStream); // 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(properties); // 获取数据库连接对象 Connection connection = dataSource.getConnection(); // 打印获取到的数据库连接对象地址值 System.out.println(connection); }} 定义一个创建数据库连接池对象的类在使用数据库连接池的时候，我们不可能说每次都如上例中的情况自己写一遍吧。我们可以自定义一个工具类，用来创建数据库连接池对象，这个时候，我们乳沟想要创建数据库连接池对象，直接调用该工具类即可。 创建工具类实例定义获取数据库连接池对象的方法 123456789101112131415161718192021222324252627282930313233/** * 数据库连接对象 */private static DataSource dataSource;/* 获取数据库连接池对象 */static { try { // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取类的类加载器 ClassLoader classLoader = JdbcUtils.class.getClassLoader(); // 获取druid-1.0.9.properties配置文件资源输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid-1.0.9.properties\"); // 加载配置文件 properties.load(resourceAsStream); // 获取连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); }}/** * 获取连接池对象 */public static DataSource getDataSource() { return dataSource;} 定义获取数据库连接对象的方法 123456/** * 获取数据库连接对象 */public static Connection getConnection() throws Exception { return dataSource.getConnection();} 定义释放资源的方法 12345678910111213141516171819/** * 归还连接 * @param t 要被归还到熟即可连接池对象的数据库连接对象 * @param &lt;T&gt; 数据库连接对象的类型 */public static &lt;T&gt; void releaseResources (T t){ if(t != null){ try { // 利用反射，获取class对象 Class&lt;?&gt; aClass = t.getClass(); // 获取class对象中的方法对象 Method close = aClass.getMethod(\"close\"); // 执行方法 close.invoke(t); } catch (Exception e) { e.printStackTrace(); } }} 该工具类总的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package my.view.utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Properties;public class JdbcUtils { /** * 数据库连接对象 */ private static DataSource dataSource; /* 获取数据库连接池对象 */ static { try { // 获取加载配置文件的对象 Properties properties = new Properties(); // 获取类的类加载器 ClassLoader classLoader = JdbcUtils.class.getClassLoader(); // 获取druid-1.0.9.properties配置文件资源输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid-1.0.9.properties\"); // 加载配置文件 properties.load(resourceAsStream); // 获取连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource() { return dataSource; } /** * 获取数据库连接对象 */ public static Connection getConnection() throws Exception { return dataSource.getConnection(); } /** * 归还连接 * @param t 要被归还到熟即可连接池对象的数据库连接对象 * @param &lt;T&gt; 数据库连接对象的类型 */ public static &lt;T&gt; void releaseResources (T t){ if(t != null){ try { // 利用反射，获取class对象 Class&lt;?&gt; aClass = t.getClass(); // 获取class对象中的方法对象 Method close = aClass.getMethod(\"close\"); // 执行方法 close.invoke(t); } catch (Exception e) { e.printStackTrace(); } } }} 使用上面创建个工具类实例有如下一个数据表格 1234567CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(10), -- 名字 balance DOUBLE -- 余额);INSERT INTO account (NAME, balance) VALUES ('LeeHua', 1000), ('Tom', 1000); 向该表格中插入一条数据，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package my.view.datasource.druid;import my.view.utils.JdbcUtils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.PreparedStatement;public class JdbcUtilsDemo { public static void main(String[] args) throws Exception{ // 获取数据库连接池对象 DataSource dataSource = JdbcUtils.getDataSource(); // 从数据库连接池对象中获取数据库连接对象 Connection connection = dataSource.getConnection(); // 预定义定义SQL语句 String sql = \"INSERT INTO account (NAME, balance) VALUES (?, ?);\"; // 获取执行预定义SQL语句对象 PreparedStatement preparedStatement = connection.prepareStatement(sql); // 给?赋值 preparedStatement.setString(1, \"WanWu\"); preparedStatement.setInt(2, 2000); // 执行预编译好的SQL语句 preparedStatement.executeUpdate(); // 释放资源：PreparedStatement JdbcUtils.releaseResources(preparedStatement); // 归还连接 JdbcUtils.releaseResources(connection); // 释放资源：数据库连接池 JdbcUtils.releaseResources(dataSource); }} 运行程序，然后查询一下表记录： 可以看到插入了一条数据，说明测试成功。","link":"/p/231506202005/"},{"title":"正则表达式和python中的re模块","text":"@Author: YiHua Lee @Address: Guangdong province, China 常用的正则匹配规则 元字符 量词 字符组 字符集 转义符 贪婪匹配 re模块使用正则表达式举例：判断一个手机号码是否合法 不使用正则表达式 123456789101112# 不使用正则表达式phone_number = input(\"请输入一个11位数导入手机号码 :\")if len(phone_number) == 11 \\ and phone_number.isdigit() \\ and (phone_number.startswith('13') or phone_number.startswith('15') or phone_number.startswith('17') or phone_number.startswith('18') or phone_number.startswith('19')): print(\"这个手机好码是合法的\")else: print(\"这个手机号码是不合法的\") 使用正则表达式 1234567# 调用re模块使用正则表达式import rephone_number = input(\"请输入一个11位数导入手机号码 :\")if re.match('^(13|15|17|18|19)[0-9]{9}$', phone_number): 正则规则 : ^(13|15|17|18|19)[0-9]{9}$ print(\"这个手机好码是合法的\")else: print(\"这个手机号码是不合法的\") match 方法 是从头开始匹配，如果正则规则开头可以匹配上，就返回一个变量。匹配的内容需要调用group才能显示。 如果没有找到匹配内容，则返回None，调用group会报错 12345678910111213141516171819import restring = 'Hello! Regular expression, 520'result = re.match('^Hello!\\s\\w*\\s\\w+.\\s\\d{3}', string=string)print(len(string), result, result.group(), result.span(), sep='\\n\\n')# 输出：30&lt;re.Match object; span=(0, 30), match='Hello! Regular expression, 520'&gt;Hello! Regular expression, 520(0, 30)# span()方法可以输出皮牌的范围 修饰符 re.I 使匹配对大小写不敏感 re.L 做本地化识别( locale-aware )匹配 re.M 多行匹配，影响^和$ re.S. 使 .匹配包括换行在内的所有字符 re.U. 根据Unicode字符集解析字符。 这个标志影响\\w、\\W、\\b和\\B re.X. 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 举例： 123import restring = 'Hello! Regular expression, 520'result = re.match('^Hello!\\s\\w*\\s\\w+.\\s\\d{3}', string, re.S) search 方法从前往后，寻找到一个就返回，返回的变量需要调用group才能拿到结果。如果没有找到，那么返回None，调用group回报错 1234567891011import restring = 'Hello! Regular expression, 5201314,Learning makes me happy and addicted to learning.'regular = 'Hello!\\s\\w*\\s\\w+.\\s\\d{3}'ret = re.search(regular, string)# 从前面往后面找到一个\"Hello!\\s\\w*\\s\\w+.\\s\\d{3}\"就返回print(ret)# 返回的是一个对象 : &lt;re.Match object; span=(0, 30), match='Hello! Regular expression, 520'&gt; findall 方法想要获取匹配正则表达式的所有内容，借助findall()方法，该方法会搜索整个字符串 举例： 1234ret = re.findall('[a-z]+', 'eva egon yuan')# 返回所有满足匹配条件的结果，放在列表里print(ret)# 输出：['eva', 'egon', 'yuan'] sub 方法 和 subn 方法sub()方法修改文本 举例： 12345ret = re.sub('\\d', '马冬梅', '马什么梅？ 0 马什么冬？ 0 冬什么梅？ 0', 3)# 将数字替换成'马冬梅',其中3代表替换了3次print(ret)# 输出：马什么梅？ 马冬梅 马什么冬？ 马冬梅 冬什么梅？ 马冬梅 subn()方法和sub()方法很相似 举例： 1234567import reret = re.subn('\\d', '马冬梅', '马什么梅？ 0 马什么冬？ 0 冬什么梅？ 0')# 将数字替换成'马冬梅',返回元组（替换的结果，替换了多少次）print(ret)# 输出：('马什么梅？ 马冬梅 马什么冬？ 马冬梅 冬什么梅？ 马冬梅', 3) compile 方法将正则字符串编译成一个正则表达式对象 举例： 12345678import reobj = re.compile('\\d{3}')# 将正则表达式编译成一个正则表达式对象，这里正则规则是要匹配三个数字ret = obj.search('abc123cba')# 正则表达式对象调用search，参数为待匹配的字符串print(ret.group())# 输出结果 : 123 finditer 方法返回一个存放匹配结果的迭代器 举例： 12345678910111213141516171819202122import reret = re.finditer('\\d', 'ab2cd4567efg') # finditer返回一个存放匹配结果的迭代器print(ret)print(next(ret).group()) # 查看第一个结果print(next(ret).group()) # 查看第二个结果print(i.group() for i in ret) # 查看剩余的所有结果# 上一条print已经输出了所有的结果，所以这个for循环不输出任何字符for i in ret: print(i.group())# 输出：&lt;callable_iterator object at 0x10a077cf8&gt;24&lt;generator object &lt;genexpr&gt; at 0x1142f5f48&gt;567 举例理解正则和re模块 例子1 12345ret = re.findall('www.(baidu|oldboy).com', 'www.oldboy.com')print(ret) # # ['oldboy'] 这是因为findall会优先匹配结果组内容返回，如果想要匹配结果，取消权限即可ret = re.findall('www.(?:baidu|oldboy).com', 'www.oldboy.com')print(ret) # # ['www.oldboy.com'] 取消优先级别的权限 例子2 123456789ret = re.split('\\d+', 'eva3egon4yuan')print(ret) # 结果 ： ['eva', 'egon', 'yuan']ret = re.split('(\\d+)', 'eva3egon4yuan')print(ret) # 结果 ： ['eva', '3', 'egon', '4', 'yuan']# 在匹配部分加上()之后，切出的结果是不同的，# 没有()的没有保留匹配的项，但是有()却能够保留匹配的项# 这个在某些需要保留匹配部分的使用过程是非常重要的 例子3 12345ret = re.search(\"&lt;(?P&lt;tag_name&gt;\\w+)&gt;\\w+&lt;/(?P=tag_name)&gt;\", \"&lt;hi&gt;hello&lt;/hi&gt;\")# 还可以利用?P&lt;name&gt;的形式给分组起个名字# 获取匹配的结果可以直接用group('名字')拿到对应的值print(ret.group('tag_name')) # 结果 : hiprint(ret.group()) # 结果 : &lt;hi&gt;hello&lt;/hi&gt; 例子4 12345ret = re.search(\"&lt;(\\w+)&gt;\\w+&lt;/\\1&gt;\", \"&lt;hi&gt;hello&lt;/hi&gt;\")# 如果不给组起名字也可以用\\序号来找到对应的组，表示要找的内容要和前面组的内容一致# 获取匹配的结果可以用group(序号)拿到对应的值print(ret.group(1))print(ret.group()) 正则在线测试网址：http://tool.chinaz.com/regex/ 抓取猫眼电影12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import requestsimport refrom requests.exceptions import RequestExceptionimport jsonimport time# 抓取首页def get_one_page(url): try: headers = { # 伪浏览器 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36' } response = requests.get(url, headers) # 响应 # 根据状态码返回响应内容 if response.status_code == 200: return response.text return None # 请求异常 except RequestException: return None# 正则表达式提取所需内容def paser_one_page(html): # 正则 pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\\d+)&lt;/i&gt;.*?data-src=\"(.*?)\".*?name\"&gt;&lt;a' '.*?&gt;(.*?)&lt;/a&gt;.*?star\"&gt;(.*?)&lt;/p&gt;.*?releasetime\"&gt;(.*?)&lt;/p&gt;' '.*?integer\"&gt;(.*?)&lt;/i&gt;.*?fraction\"&gt;(.*?)&lt;/i&gt;&lt;/p&gt;.*?&lt;/dd&gt;', re.S) # 提取内容 items = re.findall(pattern, html) print(items) # 每部电影对应一个字典 for item in items: yield{ 'index': item[0], # 电影排名 'image': item[1], # 电影图片 'title': item[2], # 电影名称 'actor': item[3].strip()[3:], # 演员 'time': item[4].strip()[5:], # 上映时间 'score': item[5]+item[6] # 电影评分 }# 将提取的内容写入文件def write_to_file(content): with open('result.txt', 'a', encoding='utf-8') as f: # 通过json.dumps()，实现字典的序列化，指定ensure_ascii=False保证输出结果是中文形式而不是Unicode编码 f.write(json.dumps(content, ensure_ascii=False)+'\\n') f.close()def main(offset): url = 'http://maoyan.com/board/4?offset='+str(offset) # URL html = get_one_page(url) # 抓取网页 paser_one_page(html) # 提取抓取的内容 for item in paser_one_page(html): # 输出结果和写入文件 print(item) write_to_file(item)if __name__ == '__main__': for i in range(10): main(offset=i*10) time.sleep(1) # 现在猫眼多了反爬虫 ， 如果速度过快，则会无响应，所以这里又增加了一个延时等待# 运行后，生成一个result.txt文件,输出内容雨文件内容一致","link":"/p/471729202004/"},{"title":"爬虫基本库的使用之requests库","text":"@Author: YiHua Lee @Address: Guangdong province, China 使用requests由于处理网页验证和Cookies时，需要写Opener和Handler来处理，为了更方便地实现这些操作，就有了更强大的库requests。requests库功能很强大。能实现Cookies、登录验证、代理设置等操作。 简单使用requests库123import requestsr = requests.get('http://wwww.baidu.com/')print(type(r), r.status_code, r.text, r.cookies, sep='\\n\\n') GET请求返回相应的请求信息 12requests.get(url, params)# url表示要捕获的页面链接，params表示url的额外参数（字典或字节流格式） 举例1：123import requestsr = requests.get('http://httpbin.org/get')print(r.text) 123456789101112# 输出{ \"args\": {}, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.21.0\" }, \"origin\": \"120.85.108.192, 120.85.108.192\", \"url\": \"https://httpbin.org/get\" } 举例21234567import requestsdata = { 'name': 'LiYihua', 'age': '21' }r = requests.get('http://httpbin.org/get', params=data)print(r.text) 123456789101112131415# 输出：{ \"args\": { \"age\": \"21\", \"name\": \"LiYihua\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.21.0\" }, \"origin\": \"120.85.108.92, 120.85.108.92\", \"url\": \"https://httpbin.org/get?name=LiYihua&amp;age=21\"} 举例3123import requestsr = requests.get('http://httpbin.org/get')print(type(r.text), r.json(), type(r.json()), sep='\\n\\n') 123456# 输出：&lt;class 'str'&gt;{'args': {}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.21.0'}, 'origin': '120.85.108.92, 120.85.108.92', 'url': 'https://httpbin.org/get'}&lt;class 'dict'&gt; 举例4抓取照片 1234import requestsr = requests.get('https://github.com/favicon.ico')with open('favicon.ico', 'wb') as f: f.write(r.content) 1# 运行结束后生成一个名为favicon.ico的图标 POST请求这是一种比较常见的URL请求方式，举例： 123456789101112131415161718192021222324252627282930313233import requestsdata = { 'name': 'LiYihua', 'age': 21}r = requests.post('http://httpbin.org/post', data=data)print(r.text)# 输出：{ \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"age\": \"21\", \"name\": \"LiYihua\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Length\": \"19\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.21.0\" }, \"json\": null, \"origin\": \"120.85.108.90, 120.85.108.90\", \"url\": \"https://httpbin.org/post\"}# POST请求成功，获得返回结果，form部分为提交的数据 Response text 和 content 获取响应的内容 status code 属性得到状态码 headers 属性得到响应头 cookies属性得到 Cookies url属性得到 URL history属性得到请求历史 举例： 1234567891011121314151617181920212223242526272829303132import requestsr = requests.get('https://www.cnblogs.com/liyihua/')print(type(r.status_code), r.status_code, type(r.headers), r.headers, type(r.cookies), r.cookies, type(r.url), r.url, type(r.history), r.history, sep='\\n\\n')# 输出：&lt;class 'int'&gt;200&lt;class 'requests.structures.CaseInsensitiveDict'&gt;{'Date': 'Thu, 20 Jun 2019 08:18:00 GMT', 'Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', 'Vary': 'Accept-Encoding', 'Cache-Control': 'private, max-age=10', 'Expires': 'Thu, 20 Jun 2019 08:18:10 GMT', 'Last-Modified': 'Thu, 20 Jun 2019 08:18:00 GMT', 'X-UA-Compatible': 'IE=10', 'X-Frame-Options': 'SAMEORIGIN', 'Content-Encoding': 'gzip'}&lt;class 'requests.cookies.RequestsCookieJar'&gt;&lt;RequestsCookieJar[]&gt;&lt;class 'str'&gt;https://www.cnblogs.com/liyihua/&lt;class 'list'&gt;[] requests 的高级用法 文件上传 1234567891011121314151617181920212223242526272829import requestsfiles = { 'file': open('favicon.ico', 'rb')}r = requests.post('http://httpbin.org/post', files=files)print(r.text)# 输出：{ \"args\": {}, \"data\": \"\", \"files\": { \"file\": \"data:application/octetstream;base64,AAABAAIAEBAAAAEAIAAoBQAAJgAAACAgAAABACAAKBQAAE4FAAAoAAAAEAAAACAAAAABACAAAAAAAAAFAAA... }, \"form\": {}, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Length\": \"6665\", \"Content-Type\": \"multipart/form-data; boundary=c1b665273fc73e67e57ac97e78f49110\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.21.0\" }, \"json\": null, \"origin\": \"120.85.108.71, 120.85.108.71\", \"url\": \"https://httpbin.org/post\"} 会话维持 Session对象，可以方便的维护一个会话 123456789101112131415161718192021222324252627import requestsrequests.get('http://httpbin.org/cookies/set/number/123456789')r = requests.get('http://httpbin.org/cookies')print(r.text)# 输出：{ \"cookies\": {}}import requestss = requests.Session()s.get('http://httpbin.org/cookies/set/number/123456789')r = s.get('http://httpbin.org/cookies')print(r.text)# 输出：{ \"cookies\": { \"number\": \"123456789\" }} SSL证书验证 12345678910111213141516import requestsr = requests.get('https://www.12306.cn')print(r.status_code)# 没有出错会输出：200# 如果请求一个HTTPS站点，但是证书验证错误的页面时，就会错误。# 为了避免错误，可以将改例子稍作修改import requestsfrom requests.packages import urllib3urllib3.disable_warnings()r = requests.get('https://www.12306.cn', verify=False)print(r.status_code) 代理设置 1234567891011import requestsproxies = { 'http': 'socks5://user:password@10.10.1.10:3128', 'https': 'socks5://user:password@10.10.1.10:1080'}requests.get('https://www.taobao.com', proxies=proxies)# 使用SOCKS协议代理 超时设置 123456import requestsr = requests.get('https://taobao.com', timeout=(0.1, 1))print(r.status_code)# 输出：200 身份验证 123456789101112131415161718import requestsfrom requests.auth import HTTPBasicAuthr = requests.get('http://localhost', auth=HTTPBasicAuth('liyihua', 'woshiyihua134'))print(r.status_code)# 输出：200# 也可以使用OAuth1方法import requestsfrom requests_oauthlib import OAuth1url = 'https://api.twitter.com/1.1/account/verify_credentials.json'auth = OAuth1('YOUR_APP_KEY', 'YOUR_APP_SECRET' 'USER_OAUTH_TOKEN', 'USER_OAUTH_TOKEN_SECRET')requests.get(url, auth=auth) Prepared Request（准备请求 1要获取一个带有状态的 Prepared Request， 需要用Session.prepare_request() 12345678910111213141516171819202122232425262728293031323334353637from requests import Request, Sessionurl = 'http://httpbin.org/post'data = { 'name': 'LiYihua'} # 参数header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537 (KHTML, like Gecko Chrome/53.0.2785.116 Safari/537.36'} # 伪装浏览器s = Session() # 会话维持req = Request('POST', url, data=data, headers=header)prepped = s.prepare_request(req) # Session的prepare_request()方法将req转化为一个 Prepared Request对象 r = s.send(prepped) # send() 发送请求print(r.text)# 输出：{ \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"name\": \"LiYihua\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Length\": \"12\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537 (KHTML, like Gecko Chrome/53.0.2785.116 Safari/537.36\" }, \"json\": null, \"origin\": \"120.85.108.184, 120.85.108.184\", \"url\": \"https://httpbin.org/post\"}","link":"/p/581629202004/"},{"title":"爬虫基本库的使用之urllib库","text":"@Author: YiHua Lee @Address: Guangdong province, China urllib的简单使用urllib模块是Python内置的HTTP请求模块 urllib包含模块：request模块、error模块、parse模块、robotparser模块 例子举例1： 向指定的url发送请求，并返回服务器响应的类文件对象 1response = urllib.request.urlopen('https://www.python.org') 读取文件全部内容 1html = response.read() 将其他编码的字符串转换成unicode编码 1print(html.decode('utf-8')) 部分输出如下： 举例2: 向指定的url发送请求，并返回服务器响应的类文件对象 1response = urllib.request.urlopen('https://www.python.org') 输出 1print(type(response)) 输出结果如下 1&lt;class 'http.client.HTTPResponse'&gt; 举例3:1234import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.getheaders())print(response.getheader('Server')) 1234说明：# status属性：返回响应的状态码，如200代表请求成功# getheaders()方法：返回响应的头信息# getheader('name')方法：获取响应头中的name值 urllib子模块之Request模块urlopen()方法可以实现最基本请求的发起，Request更强大 举例 1234import urllib.requestrequest = urllib.request.Request('https://python.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) urllib.request.Request() 方法说明1Request(url, data=None, headers={ }, origin_req_host=None, unverifiable=False, mothod=None) 12345678910参数：url参数: 请求URLdata参数：Post 提交的数据, 默认为 None ，当 data 不为 None 时,urlopen() 提交方式为 Postheaders参数：也就是请求头，headers参数可以在构造请求时使用，也可以用add_header()方法来添加请求头最常用的用法:修改User-Agent来伪装浏览器（如伪装Firefox：Mozilla/s.o (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11）origin_req_host参数：指的是请求方的host名称或者IP地址unverifiable参数：表示这个请求是否是无法验证 的，默认是 False，意思就是说用户没有足够权限来选择接收这个请求的结果。 例如，我们请求一个 HTML文档中的图片，但是我们没有向动抓取图像的权限，这时 unverifiable 的值就是 True。method参数:它是一个字符串，用来指示请求使用的方法（如：GET、POST、PUT等） 举例 1234567891011from urllib import request, parseurl = 'https://python.org/post'headers = { 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT', 'Host': 'httpbin.org'}dict = { 'name': 'Germey' }data = bytes(parse.urlencode(dict), encoding='utf-8') req = request.Request(url=url, data=data, headers=headers, method='POST')response = request.urlopen(req)print(response.read().decode('utf-8')) 高级用法Request虽然可以构造请求，但是对于一些更高级的操作（比如Cookies处理，代理设置等），就需要更强大的工具Handler了。各种Handler子类继承BaseHandler类。 例子1 在登录某些网站时，需要输入用户名和密码，验证成功后才能查看页面，这时可以借助HTTPBasicAuthHandler 123456789101112131415161718from urllib.request import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_openerfrom urllib.error import URLErrorusername = 'username'password = 'password'url = 'http://localhost:5000/'p = HTTPPasswordMgrWithDefaultRealm() # 创建一个密码管理对象，用来保存 HTTP 请求相关的用户名和密码p.add_password(None, url, username, password) # 添加url，用户名，密码auth_handler = HTTPBasicAuthHandler(p) # 来处理代理的身份验证opener = build_opener(auth_handler) # 利用build_opener()方法构建一个Openertry: result = opener.open(url) # 利用Opener的open()方法打开链接，完成验证 html = result.read().decode('utf-8') # 读取返回的结果，解码返回结果 print(html)except URLError as e: print(e.reason) # 获取错误的原因 例子2 代理 1234567891011121314151617from urllib.error import URLErrorfrom urllib.request import ProxyHandler, build_opener# ProxyHandler()使用代理IP, 它的参数是一个字典，键名是协议类型（比如HTTP或者HTTPS等），键值是代理链接，可以添加多个代理proxy_handler = ProxyHandler( { 'http': 'http://127.0.0.1:9743', 'https': 'https://127.0.0.1:9743' })opener = build_opener(proxy_handler) # 利用build_opener()方法，构造一个Openertry: response = opener.open('https://www.baidu.com') # 发送请求 print(response.read().decode('utf-8'))except URLError as e: print(e.reason) 例子3 爬一些需要登录的网站，就要用到cookie相关的一些模块来操作了 12345678910111213import http.cookiejar# http.cookiejar.CookieJar()# 1、管理储存cookie，向传出的http请求添加cookie# 2、cookie存储在内存中，CookieJar示例回收后cookie将自动消失import urllib.requestcookie = http.cookiejar.CookieJar() # 创建cookiejar实例对象handler = urllib.request.HTTPCookieProcessor(cookie) # 根据创建的cookie生成cookie的管理器opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name+\"=\"+item.value) urllib 模块之error模块URLError123456from urllib import request, errortry: response = request.urlopen('https://www.bucunzai_tan90.com/index.htm') print(response.read().decode('utf8'))except error.URLError as e: print(e.reason) 123说明：打开一个不存在的页面时，输出结果是:[Errno 8] nodename nor servname provided, or not known打开一个存在的页面时，输出结果是网页的源代码 HTTPErrorHTTPError 是URLError的子类，专门用来处理HTTP请求错误，比如认证请求失败等 code: 返回 HTTP状态码，比如 404表示网页不存在， 500表示服务器内部错误等 reason:同父类一样，用于返回错误的原因 。 headers: 返回请求头。 举例： 1234567891011121314151617181920from urllib import request, errortry: response = request.urlopen('https://cuiqingcai.com/index.htm') print(response.read().decode('utf8'))except error.HTTPError as e: print(e.reason, e.code, e.headers, sep='\\n\\n')# 或者如下写法# 更好的写法是，先处理子类，再处理父类，最后处理正常逻辑from urllib import request, errortry: response = request.urlopen('https://cuiqingcai.com/index.htm') # print(response.read().decode('utf8'))except error.HTTPError as e: # 处理HTTPError子类 print(e.reason, e.code, e.headers, sep='\\n\\n')except error.URLError as e: # 处理URLError父类 print(e.reason)else: # 处理正常逻辑 print('Request Successful') 输出： 123456789101112131415Not Found404Server: nginx/1.10.3 (Ubuntu)Date: Sun, 16 Jun 2019 10:53:09 GMTContent-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedConnection: closeSet-Cookie: PHPSESSID=vrvrfqq88eck9speankj0ogus0; path=/Pragma: no-cacheVary: CookieExpires: Wed, 11 Jan 1984 05:00:00 GMTCache-Control: no-cache, must-revalidate, max-age=0Link: &lt;https://cuiqingcai.com/wp-json/&gt;; rel=&quot;https://api.w.org/&quot; 解析链接ullib.parse定义了处理URL的标准接口，它支持file、ftp、 hdl、 https、 imap、mms 、 news 、 prospero 、 telnet等协议的URL处理。 举例 urlparse：实现URL的识别和分段 12345678910111213from urllib.parse import urlparse# 实现URL的分段result = urlparse('http://www.baidu.com/index.html;user?id=5#comment')print(type(result), result, sep='\\n') # 输出的result是一个元组# 输出：&lt;class 'urllib.parse.ParseResult'&gt;ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5', fragment='comment')# scheme='协议', netloc='域名', path='访问路径', params='参数', query='查询条件'(?后面), fragment='锚点'(#号后面) urlunparse：实现URL的构造 123456789101112131415from urllib.parse import urlunparse# urllib.parse.urlunparse()，接受的参数是一个可迭代对象，它的长度必须是6# 这里的data用了列表，也可以用元组或者特定的数据结构data1 = ['http', 'www.baidu.com', '/index.html', 'user', 'id=5', 'comment']data2 = ['', 'www.baidu.com', '/index.html', 'user', 'id=5', 'comment']data3 = ['http', '', '/index.html', 'user', 'id=5', 'comment']data4 = ['http', 'www.baidu.com', '', 'user', 'id=5', 'comment']data5 = ['http', 'www.baidu.com', '/index.html', '', 'id=5', 'comment']data6 = ['http', 'www.baidu.com', '/index.html', 'user', '', 'comment']data7 = ['http', 'www.baidu.com', '/index.html', 'user', 'id=5', '']print(\"缺少协议：\\t\"+urlunparse(data2), \"缺少域名：\\t\"+urlunparse(data3), \"缺少访问路径：\\t\"+urlunparse(data4), \"缺少参数：\\t\"+urlunparse(data5), \"缺少查询条件：\\t\"+urlunparse(data6), \"缺少锚点：\\t\"+urlunparse(data7), \"标准链接：\\t\"+urlunparse(data1), sep='\\n\\n') urlsplit：实现URL的识别和分段 123456789101112from urllib.parse import urlsplitresult = urlsplit('http://www.baidu.com/index.html;user?id=5#comment')print(result, result.scheme, result[4], sep='\\n')# 输出结果：SplitResult(scheme='http', netloc='www.baidu.com', path='/index.html;user', query='id=5', fragment='comment')httpcomment# urlsplit()方法与urlparse()方法很相似，urlsplit()方法与urlparse()相比，urlsplit()将path和params合在一起放在path中,而urlparse()中，path和params是分开的 urlsplit：实现URL的构造 123456789from urllib.parse import urlunsplit# urlunsplit()方法与urlunparse()方法类似，urlunsplit()传入的参数是一个可迭代的对象，# 不同之处是path和params是否合在一起（urlunsplit是合在一起的）data = ('http', 'wwww.baidu.com', 'index.html;user', 'id=5', 'comment')print(urlunsplit(data))# 输出结果：http://wwww.baidu.com/index.html;user?id=5#comment urljoin：完成链接的合并 1234567891011121314151617181920212223from urllib.parse import urljoin# 完成链接的合并（前提是必须有特定长度的对象，链接的每一部分都要清晰分开）print(urljoin('http://www.baidu.com', 'FAQ.html'))print(urljoin('http://www.baidu.com', 'https://cuiqingcai.com/FAQ.html'))print(urljoin ('http://www.baidu.com/about.html', 'https://cuiqingcai.com/FAQ.html'))print(urljoin('http://www.baidu.com/about.html', 'https://cuiqingcai.com/FAQ.html?question=2'))print(urljoin ('http://www.baidu.com d=abc', 'https://cuiqingcai.com/index.php'))print(urljoin('http://www.baidu.com', '?category=2#comment'))print(urljoin('www.baidu.com', '?category=2#comment'))print(urljoin('www.baidu.com#comment', '?category=2'))# 输出：http://www.baidu.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.htmlhttps://cuiqingcai.com/FAQ.html?question=2https://cuiqingcai.com/index.phphttp://www.baidu.com?category=2#commentwww.baidu.com?category=2#commentwww.baidu.com?category=2 urlencode：把key-value这样的键值对转换成我们想要的格式 123456789101112from urllib.parse import urlencodeparams = {}params['name'] = 'Tom'params['age'] = 21base_url = 'http://wwww.baidu.com?'url = base_url + urlencode(params)print(url)# 输出：http://wwww.baidu.com?name=Tom&amp;age=21 parse_qs：如果说urlencode()方法实现序列化，那么parse_qs()就是反序列化 12345678from urllib.parse import parse_qsquery = 'name=Tom&amp;age=21'print(parse_qs(query))# 输出：{'name': ['Tom'], 'age': ['21']} parse_qsl：parse_qsl()方法与parse_qs()方法很相似，parse_qsl()返回的是列表，列表中的每个元素是一个元组，parse_qs()返回的是字典 12345678from urllib.parse import parse_qslquery = 'name=Tom&amp;age=21'print(parse_qsl(query))# 输出：[('name', 'Tom'), ('age', '21')] quote：将内容转化为URL编码的格式 123456789from urllib.parse import quotekeyword = '壁纸'url = 'https://www.baidu.com/s?wd=' + quote(keyword)print(url)# 输出：https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8 unquote：进行URL解码 12345678from urllib.parse import unquoteurl = 'https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8'print(unquote(url))# 输出：https://www.baidu.com/s?wd=壁纸 robotparserurllib.robotparser.RobotFileParser(url=’’)根据某网站的robots.txt文件来判断一个爬取爬虫是否有权限来爬取这个网页 set_url() 用来设置robot.txt文件的链接 read() 读取robots.txt文件并进行分析 parse() 解析robots.txt文件，传入的参数是robots.txt某些行内容 can_fetch(User-agent=’’, URL=’’) 返回内容是该搜索引擎是否可以抓取这个URL，返回结果是True或False mtime() 返回上一次抓取和分析robots.txt的时间 modified() 将当前时间设置为上次抓取和分析robots.txt的时间 举例1：1234567891011121314from urllib.robotparser import RobotFileParserrp = RobotFileParser()rp.set_url('http://www.jianshu.com/robots.txt') # 设置robots.txt文件的链接rp.read() # 读取robots.txt文件并进行分析print(rp.can_fetch('*', 'http://www.jianshu.com/p/b67554025d7d')) # 输出该搜索引擎是否可以抓取这个URLprint(rp.can_fetch('*', 'http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections'))# 输出：FalseFalse# False也就是说该搜索引擎不能抓取这个URL 举例2：1234567891011from urllib.robotparser import RobotFileParserfrom urllib.request import urlopenrp = RobotFileParser()rp.parse(urlopen('http://www.jianshu.com/robots.txt').read().decode('utf-8').split('\\n'))print(rp.can_fetch('*', 'http://www.jianshu.com/p/b67554025d7d'))print(rp.can_fetch('*', 'http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections'))# 输出结果与上面一个例子一样，只是上一个例子用read()方法，这个例子用parse()方法","link":"/p/081629202004/"},{"title":"爬虫数据存储之文件存储","text":"@Author: YiHua Lee @Address: Guangdong province, China TXT 文件存储爬取知乎上的热门话题，获取话题的问题、作者、答案，然后保存在TXT文本中 12345678910111213141516171819202122232425262728import requestsfrom pyquery import PyQueryurl = 'https://www.zhihu.com/explore'headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/58.0.3029.110 Safari/537.36'}html = requests.get(url, headers=headers).textdoc = PyQuery(html)# 选择class=\"explore-tab\"的内部class=\"feed-item\"的所有节点，再遍历每一个元素（每个元素就是一个热门话题）items = doc('.explore-tab .feed-item').items()for item in items: # 找到'h2'节点，获取知乎上热门话题的问题 question = item.find('h2').text() # 选择class=\"author-link-line\"的所有节点，获取文本值 author = item.find('.author-link-line').text() # 找到属性值为content的节点，获取其内部文本值，再通过PyQuery()方法初始化获取文本信息 answer = PyQuery(item.find('.content').html()).text() file = open('explore.txt', 'a', encoding='utf-8') file.write('\\n'.join([question, author, answer])) file.write('\\n' + '=' * 50 + '\\n') file.close() 运行结果生成一个TXT文件 JSON 文件存储读取 JSON调用JSON库的loads()方法将JSON文本字符串转为JSON对象 12345678910111213141516171819202122import json# 注意：JSON数据需要用双引号来包围，不能用单引号。string = '''[ { \"name\": \"Lee Hua\", \"gender\": \"male\", \"birthday\": \"1997-10-25\" }, { \"name\": \"Li Hua\", \"gender\": \"female\", \"birthday\": \"1998-10-25\" }]'''print(type(string), string, sep='\\n')data = json.loads(string)print(type(data), data, sep='\\n') 123456789101112131415161718# 输出：&lt;class 'str'&gt;[ { \"name\": \"Lee Hua\", \"gender\": \"male\", \"birthday\": \"1997-10-25\" }, { \"name\": \"Li Hua\", \"gender\": \"female\", \"birthday\": \"1998-10-25\" }]&lt;class 'list'&gt;[{'name': 'Lee Hua', 'gender': 'male', 'birthday': '1997-10-25'}, {'name': 'Li Hua', 'gender': 'female', 'birthday': '1998-10-25'}] 输出 JSON通过dumps()方法将JSON对象转为文本字符串。 123456789101112131415161718192021222324252627282930313233343536373839import jsondata = [ { \"name\": \"Lee Hua\", \"gender\": \"male\", \"birthday\": \"1997-10-25\" }, { \"name\": \"李 华\", \"gender\": \"男\", \"birthday\": \"1998-10-25\" }]with open('data.json', 'w') as file: file.write(json.dumps(data, indent=2))# 如果不存在data.json文件，运行结果则生成一个名为data.json的文件# data.json文件内写入的内容:[ { \"name\": \"Lee Hua\", \"gender\": \"male\", \"birthday\": \"1997-10-25\" }, { \"name\": \"\\u674e \\u534e\", \"gender\": \"\\u7537\", \"birthday\": \"1998-10-25\" }]# file.write(json.dumps(data, indent=2))中， indent参数代表缩进字符个数。# 如果想要再写入的data.json文件中显示写入的中文，那么file.write(json.dumps(data, indent=2, ensure_ascii=False))即可 CSV 文件存储csv.writer()和csv.DictWriter()方法 123456789101112131415161718192021222324252627282930313233import csvwith open('data.csv', 'w') as csvfile: writer = csv.writer(csvfile) writer.writerow(['id', 'name', 'age']) writer.writerow(['10001', 'Li Hua', '18']) writer.writerow(['10002', 'Lee Hua', '19']) writer.writerow(['10003', 'liyihua', '20'])# 上面的内容也可以这样写入# writer = csv.writer(csvfile)# writer.writerow(['id', 'name', 'age'])# writer.writerow(# [# ['10001', 'Li Hua', '18'],# ['10002', 'Lee Hua', '19'],# ['10003', 'liyihua', '20']# ]# )# 上面内容还可以这样写入# field_names = ['id', 'name', 'age']# writer = csv.DictWriter(csvfile, fieldnames=field_names)# writer.writerow({'id': '10001', 'name': 'Li Hua', 'age': '18'})# writer.writerow({'id': '10002', 'name': 'Lee Hua', 'age': '19'})# writer.writerow({'id': '10003', 'name': 'liyihua', 'age': '20'})# 运行结果：生成一个data.csv文件，文件内容如下id,name,age10001,Li Hua,1810002,Lee Hua,1910003,liyihua,20 123# 想修改行与列之间的分隔符，可以传入参数delimiter参数，writer = csv.writer(csvfile, delimiter='分隔符')# 如果想要追加写入的话，可以修改文件的打开模式，即将open()函数的第二个参数改成a。如：open('file', 'a')# 写入时有时候会遇到编码错误问题，此时只要给open()函数指定编码形式就可以了。如：open('file', 'r', encoding='utf-8')","link":"/p/051430202004/"},{"title":"理解 Java 多线程","text":"@Author: YiHua Lee @Address: Guangdong province, China 并发与并行 并发：指两个或多个事件在同一时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 进程与线程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。 线程调度 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。 抢占式调度：优先让优先级高的銭程使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 Java中的主线程主线程：执行主（main）方法的线程。 单线程单线程：Java程序中，只有一个线程，执行从main方法开始，从上到下的执行。 举例： 123456789101112131415161718public class Student { public static void method1() { for (int i = 0; i &lt; 5; i++) { System.out.println(\"我正在执行Student的方法1\"); } } public static void method2() { for (int i = 0; i &lt; 5; i++) { System.out.println(\"我正在执行Student的方法2\"); } } public Student() { }} 123456public class Demo01MainThread { public static void main(String[] args) { Student.method1(); Student.method2(); }} 1234567891011控制台输出：我正在执行Student的方法1我正在执行Student的方法1我正在执行Student的方法1我正在执行Student的方法1我正在执行Student的方法1我正在执行Student的方法2我正在执行Student的方法2我正在执行Student的方法2我正在执行Student的方法2我正在执行Student的方法2 从控制台输出可以知道，程序从上到下的执行，从方法1开始执行，到方法2开始执行。 多线程创建多线程程序的第一种方式创建Thread类的子类java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类实现步骤： 创建一个 Thread类的子类。 在Thread类的子类中重写Thread类中的run方法，设置线程任务（开启线程要做什么）。 创建Thread类的子类对象。 调用Thread类中的start方法，开启新的线程，执行run方法 void start()使该线程开始执行。Java虚拟机调用该线程的run方法。结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其run方法）。多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。Java程序属于抢占式调度，哪个线程的优先级高，哪个线程优先执行；同一个优先级，随机选择一个执行。 举例 12345678910111213public class Person extends Thread { /** * 重写Thread类的run方法，设置任务 */ @Override public void run() { for (int i = 0; i &lt; 6; i++) { System.out.println(\"我正在执行重写的run方法中的线程：\" + i); } }} 1234567891011121314public class Demo02MainThread { public static void main(String[] args) { // 创建Thread的子类对象 Thread myThread = new Person(); // 调用Thread类中的start方法，开启新的线程，执行run方法 myThread.start(); // main方法中的要执行的线程 for (int i = 0; i &lt; 6; i++) { System.out.println(\"我正在执行main方法的线程：\" + i); } }} 控制台输出 123456789101112我正在执行main方法的线程：0我正在执行main方法的线程：1我正在执行重写的run方法中的线程：0我正在执行main方法的线程：2我正在执行重写的run方法中的线程：1我正在执行重写的run方法中的线程：2我正在执行重写的run方法中的线程：3我正在执行重写的run方法中的线程：4我正在执行重写的run方法中的线程：5我正在执行main方法的线程：3我正在执行main方法的线程：4我正在执行main方法的线程：5 多线程的原理 Thread类的常用方法12345678public String getName()// 获取当前线程名称。public void start()// 导致此线程开始执行;Java虚拟机调用此线程的run方法。public void run()// 此线程要执行的任务在此处定义代码。public static void sleep(long millis// 返回对当前正在执行的线程对象的引用。 getName()方法、start()方法、run()方法123456public class MyThread extends Thread { @Override public void run() { // 此线程要执行的任务 }} 1234567891011121314151617181920212223public class Demo01MyThread { public static void main(String[] args) { MyThread myThread1 = new MyThread(); myThread1.start(); String run1Name = myThread1.getName(); MyThread myThread2 = new MyThread(); myThread2.start(); String run2Name = myThread2.getName(); MyThread myThread3 = new MyThread(); myThread3.start(); String run3Name = myThread3.getName(); System.out.println(\"线程1名称：\" + run1Name); System.out.println(\"线程2名称：\" + run2Name); System.out.println(\"线程3名称：\" + run3Name); }} 1234控制台输出：线程1名称：Thread-0线程2名称：Thread-1线程3名称：Thread-2 currentThread()方法123456789public class MyThread extends Thread { @Override public void run() { // 此线程要执行的任务 System.out.println(Thread.currentThread()); }} 1234567891011121314public class Demo02MyThread { public static void main(String[] args) { MyThread myThread1 = new MyThread(); myThread1.start(); MyThread myThread2 = new MyThread(); myThread2.start(); MyThread myThread3 = new MyThread(); myThread3.start(); }} 1234控制台输出：Thread[Thread-0,5,main]Thread[Thread-2,5,main]Thread[Thread-1,5,main] 了解一下setName()方法setName()：设置线程的名称 1234567public class Demo03MyThread { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"李华\"); myThread.start(); }} 12控制台输出：Thread[李华,5,main] sleep()方法123456789101112131415public class MyThread2 extends Thread { @Override public void run() { // 此线程要执行的任务 for (int i = 0; i &lt; 11; i++) { try { // 参数为毫秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print(\"第\" + i + \"秒 \"); } }} 123456public class Demo01MyThread2 { public static void main(String[] args) { MyThread2 thread2 = new MyThread2(); thread2.start(); }} 12控制台输出：第0秒 第1秒 第2秒 第3秒 第4秒 第5秒 第6秒 第7秒 第8秒 第9秒 第10秒 创建多线程的第二种方式实现Runnable接口，来创建多线程。 实现步骤 创建一个 Runnable接口的实现类。 在实现类中重写 Runnable接口的run方法，设置线程任务。 创建一个 Runnable接口的实现类对象。 创建Thread类对象，构造方法中传递 Runnable接口的实现类对象。 调用 Threads类中的 start方法，开启新的线程执行run方法 举例12345678910// 创建一个 Runnable接口的实现类。public class MyRunnable implements Runnable { @Override public void run() { // 在实现类中重写 Runnable接口的run方法，设置线程任务。 for (int i = 0; i &lt; 3; i++) { System.out.println(Thread.currentThread().getName() + \" ~~~~~~~~~ \" + i); } }} 1234567891011121314151617public class DemoRunnable { public static void main(String[] args) { // 创建一个 Runnable接口的实现类对象。 MyRunnable myRunnable = new MyRunnable(); // 创建Thread类对象，构造方法中传递 Runnable接口的实现类对象。 Thread thread = new Thread(myRunnable); // 调用 Threads类中的 start方法，开启新的线程执行run方法 thread.start(); // main方法线程 for (int i = 0; i &lt; 3; i++) { System.out.println(Thread.currentThread().getName() + \" ~~~~~~~~~ \" + i); } }} 1234567控制台输出：main ~~~~~~~~~ 0Thread-0 ~~~~~~~~~ 0main ~~~~~~~~~ 1Thread-0 ~~~~~~~~~ 1Thread-0 ~~~~~~~~~ 2main ~~~~~~~~~ 2 使用Runnable相比Thread有哪些优势 适合多个相同的程序代码的线程去共享同一个资源。 可以避兔Java中的单继承的局限性。 増加程序的健壮性，实现解耦（把设置线程任务和开启线程分开）操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现 Runable或 Callable类线程，不能直接放入继承 Thread的类。 内部类实现创建多线程123456789public class MyRunnable implements Runnable { @Override public void run() { // 在实现类中重写 Runnable接口的run方法，设置线程任务。 for (int i = 0; i &lt; 3; i++) { System.out.println(Thread.currentThread().getName() + \" ~~~~~~~~~ \" + i); } }} 1234567891011121314151617public class DemoSimpleThread { public static void main(String[] args) { // 创建一个 Runnable接口的实现类对象。 MyRunnable myRunnable = new MyRunnable(); new Thread(myRunnable) { @Override public void run() { System.out.print(\"匿名内部类的方式实现多线程的创建：\"); System.out.println(Thread.currentThread().getName() + \"线程\"); } }.start(); // main线程 System.out.println(\"main线程\"); }} 123控制台输出：main线程匿名内部类的方式实现多线程的创建：Thread-0线程","link":"/p/381502202005/"},{"title":"理解 Java 方法引用（方法引用符：“双冒号::”）","text":"@Author: YiHua Lee @Address: Guangdong province, China 方法引用在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况:如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑? 冗余的Lambda场景来看一个简单的函数式接口以应用Lambda表达式： 12345678@FunctionalInterfacepublic interface Printable { /** * 接收一个字符串参数，打印显示它 * @param str 字符串 */ public abstract void print(String str);} 在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 1234567891011public class Demo01PrintSimple { public static void main(String[] args) { printString(s -&gt; System.out.println(s)); } private static void printString(Printable data) { data.print(\"Hello, World!\"); }} 其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：拿到 String(类型可推导，所以可省略)数据后，在控制台中输出它。 问题分析这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out 对象中的println(String) 方法。既然Lambda希望做的事情就是调用 println(String) 方法，那何必自己手动调用呢? 用方法引用改进代码1234567891011public class Demo02PrintRef { public static void main(String[] args) { printString(System.out::println); } private static void printString(Printable data) { data.print(\"Hello, World!\"); }} 请注意其中的双冒号 :: 写法，这被称为“方法引用”，而双冒号是一种新的语法。 方法引用符双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 语义分析例如上例中， System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效： 1234// Lambda表达式写法s -&gt; System.out.println(s);// 方法引用写法System.out::println 第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。 第二种等效写法的语义是指:直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。 注：Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会出现编译错误（是错误，不是异常） 如上例中： 1(int s) -&gt; System.out.println(s) 错误如下： 1Error:(x, y) java: 不兼容的类型: lambda 表达式中的参数类型不兼容 x、y为定位错误的位置，可以理解成直角坐标系中的点坐标。 推导与省略如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 下面这段代码将会调用 println 方法的不同重载形式，将函数式接口改为int类型的参数： 12345678@FunctionalInterfacepublic interface PrintableInteger { /** * 接收一个int类型参数，打印显示它 * @param i int类型参数 */ public abstract void print(int i);} 由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化： 12345678910public class Demo03PrintOverload { public static void main(String[] args) { printInteger(System.out::println); } private static void printInteger(PrintableInteger data) { data.print(1024); }} 这次方法引用将会自动匹配到 println(int) 的重载形式。 通过对象名引用成员方法这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： 1234567public class MethodRefObject { public void printUpperCase(String str) { System.out.println(str.toUpperCase()); }} 函数式接口仍然定义为： 12345678@FunctionalInterfacepublic interface Printable { /** * 接收一个字符串参数，打印显示它 * @param str 字符串 */ public abstract void print(String str);} 拿到参数之后经Lambda之手，继而传递给toUpperCase() 方法去处理： 1234567891011public class Demo04MethodRef1 { public static void main(String[] args) { printString(s -&gt; s.toUpperCase()); } private static void printString(Printable lambda) { lambda.print(\"Hello\"); }} 由于上面已经定义了printUpperCase()方法，且方法实现的功能就是：将传入的字符串传递给toUpperCase()方法处理，然后打印输出。 这个时候，当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的Lambda的时候，已经具有了MethodRefObject 类的对象实例，则可以通过对象名引用成员方法，代码为： 123456789101112public class Demo04MethodRef2 { public static void main(String[] args) { MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); } private static void printString(Printable lambda) { lambda.print(\"Hello\"); } } 运行程序，两种方式的输出是一样的： 1HELLO 通过类名称引用静态方法由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： 1234567@FunctionalInterfacepublic interface CalculationAble { /** * 接口传入一个int类型的参数，经过自定义处理，返回一个int类型的数据 */ int calculation(int num);} 第一种写法是使用Lambda表达式： 1234567891011public class Demo5Lambda { public static void main(String[] args) { method(-666, n -&gt; Math.abs(n)); } private static void method(int num, CalculationAble lambda) { System.out.println(lambda.calculation(num)); } } 但是使用方法引用的更好写法是: 1234567891011public class Demo5MethodRef { public static void main(String[] args) { method(-666, Math::abs); } private static void method(int num, CalculationAble reference) { System.out.println(reference.calculation(num)); }} 在这个例子中，下面两种写法是等效的： 1234// Lambda表达式n -&gt; Math.abs(n)// 方法引用Math::abs 通过super引用成员方法如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口： 1234567@FunctionalInterfacepublic interface GreetAble { /** * 问候语 */ void greet();} 然后是父类 Human 的内容： 1234567public class Human { public void sayHello() { System.out.println(\"Hello!\"); }} 最后是子类 Man 的内容，其中使用了Lambda的写法： 12345678910111213141516171819202122232425262728293031public class Man extends Human { @Override public void sayHello() { System.out.println(\"大家好,我是Man!\"); } /** * 定义方法method，参数传递GreetAble接口 * @param g 这里传入的是Lambda表达式 */ public void method(GreetAble g) { g.greet(); } /** * 调用method方法，使用Lambda表达式 */ public void show(){ // 创建Human对象，调用sayHello方法 method(() -&gt; { new Human().sayHello(); }); // 简化Lambda method(() -&gt; new Human().sayHello()); // 使用super关键字代替父类对象 method(() -&gt; super.sayHello()); } } 但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman： 12345678910111213141516171819202122public class Woman extends Human { @Override public void sayHello() { System.out.println(\"大家好,我是Man!\"); } /** * 定义方法method，参数传递GreetAble接口 * @param g 引用方法 */ public void method(GreetAble g) { g.greet(); } /** * 调用method方法，使用引用方法 */ public void show(){ method(super::sayHello); }} 在这个例子中，下面两种写法是等效的： 12345// Lambda表达式() -&gt; super.sayHello()// 方法引用super::sayHello 通过this引用成员方法this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。首先是简单的函数式接口： 1234567@FunctionalInterfacepublic interface RichAble { /** * 买东西 */ void buy();} 下面是一个丈夫 Husband 类： 12345678910111213141516public class Husband01 { /** * 结婚 * @param lambda 函数式接口，买东西 */ private void marry(RichAble lambda) { lambda.buy(); } /** * 要开心 */ public void beHappy() { marry(() -&gt; System.out.println(\"买套房子\")); }} 开心方法 beHappy 调用了结婚方法 marry ，后者的参数为函数式接口 Richable ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 Husband 丈夫类进行修改： 1234567891011121314151617181920212223public class Husband02 { /** * 买房子 */ private void buyHouse() { System.out.println(\"买套房子\"); } /** * 结婚 * @param lambda 函数式接口，买东西 */ private void marry(RichAble lambda) { lambda.buy(); } /** * 要开心 */ public void beHappy() { marry(() -&gt; this.buyHouse()); }} 如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为： 1234567891011121314151617181920212223public class Husband03 { /** * 买房子 */ private void buyHouse() { System.out.println(\"买套房子\"); } /** * 结婚 * @param lambda 函数式接口，买东西 */ private void marry(RichAble lambda) { lambda.buy(); } /** * 要开心 */ public void beHappy() { marry(this::buyHouse); }} 在这个例子中，下面两种写法是等效的： 12345// Lambda表达式() -&gt; this.buyHouse()// 方法引用this::buyHouse 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。首先是一个简单 的 Person 类： 1234567891011121314151617public class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return this.name; } public void setName(String name) { this.name = name; }} 然后是用来创建 Person 对象的函数式接口： 123456789@FunctionalInterfacepublic interface PersonBuilder { /** * 创建 Person 对象 * @param name Person对象名 * @return Person对象 */ Person buildPerson(String name);} 要使用这个函数式接口，可以通过Lambda表达式： 1234567891011public class Demo06Lambda { public static void main(String[] args) { printName(\"Lee Hua\", (name) -&gt; new Person(name)); } public static void printName(String name, PersonBuilder builder) { System.out.println(builder.buildPerson(name).getName()); }} 但是通过构造器引用，有更好的写法： 1234567891011public class Demo07ConstructorRef { public static void main(String[] args) { printName(\"Lee Hua\", Person::new); } public static void printName(String name, PersonBuilder builder) { System.out.println(builder.buildPerson(name).getName()); }} 在这个例子中，下面两种写法是等效的： 12345// Lambda表达式name -&gt; new Person(name)// 方法引用Person::new 数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口： 123456789@FunctionalInterfacepublic interface ArrayBuilder { /** * 创建数组的函数式接口 * @param length 数组长度 * @return 存储int类型的数组 */ int[] buildArray(int length);} 在应用该接口的时候，可以通过Lambda表达式： 1234567891011public class Demo08ArrayInitRef { public static void main(String[] args) { int[] array = initArray(10, length -&gt; new int[length]); } private static int[] initArray(int length, ArrayBuilder builder) { return builder.buildArray(length); }} 但是更好的写法是使用数组的构造器引用： 1234567891011public class Demo09ArrayInitRef { public static void main(String[] args) { int[] array = initArray(10, int[]::new); } private static int[] initArray(int length, ArrayBuilder builder) { return builder.buildArray(length); }} 在这个例子中，下面两种写法是等效的： 12345// Lambda表达式length -&gt; new int[length]// 方法引用int[]::new","link":"/p/401404202005/"},{"title":"理解Java中的IO字节流(File的输入输出理解)","text":"@Author: YiHua Lee @Address: Guangdong province, China IO 概述什么是 IOJava中IO操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输岀也叫做作写出数据。 IO的分类根据数据的流向分为：输入流和输出流。 输入流：把数据从其他设备上读取到内存中的流。 输出流：把数据从内存中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 顶级父类们 字节流一切文件数据（文本、图片、视频等）在存储时，都是以二进制数字的形式保存，都是一个ー个的字节，在传输时也是一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节输出流——OutputStreamjava.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 123456789101112131415java.io.OutputStreampublic abstract void write(int b) throws IOException;// 将指定的字节输出流。public void write(byte b[]) throws IOException{...};// 将b.length字节从指定的字节数组写入此输出流。public void write(byte b[], int off, int len) throws IOException{...};// 从指定的字节数组写入len字节,从偏移量off开始输出到此输出流。public void flush() throws IOException{};// 刷新此输出流并强制任何缓冲的输出字节被写出。public void close() throws IOException {};// 关闭此输出流并释放与此流相关联的任何系统资源。 FileOutputStream类 OutputStream抽象类，有很多的子类，其中FileOutputStream类是它其中一个简单的子类。 java.io.FileOutputStream是文件输出流，用于将数据写出到文件。 写出字节数据写出字节：write(int b)方法，每次可以写出一个字节数据 字节输出流的使用步骤： 创建一个 FileOutputStream对象，构造方法中传递写入数据的目的地。 调用FileOutputStream对象中的方法write，把数据写入到文件中。 释放资源（流使用会占用一定的内存，使用完毕要把内存清空提供程序的效率）。 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;public class DemoFosWrite { public static void main(String[] args) throws IOException { // 使用文件名创建字节流对象 FileOutputStream fos = new FileOutputStream(\"FOS.txt\"); // 写出数据 // 写出第一个字节 fos.write(97); // 写出第二个字节 fos.write(98); // 写出第三个字节 fos.write(99); // 关闭资源 fos.close(); }} 运行结果：生成了一个”FOS.txt”文件 FOS.txt文件大小是3个字节，内容是abc 写入数据的原理（内存–&gt;硬盘）： Java程序 –&gt; Java虚拟机 –&gt; 操作系统 –&gt; 操作系统调用写数据的方法 –&gt; 把数据写到文件中 写数据的时候，会把要写入的数据转换为二进制数。在打开文件的时候，都会查询编码表（例如：ASCII表），把字节转换为字符表示。 write(byte b[])方法作用：将b.length字节从指定的字节数组写入此输出流。 1234567891011121314import java.io.FileOutputStream;import java.io.IOException;public class Demo01Write { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"FOS1.txt\"); byte[] bytes = {97, 98, 99}; // 将3个字节从bytes字节数组写入fos输出流。 fos.write(bytes); fos.close(); }} 运行结果：生成了一个”FOS1.txt”文件 write(byte b[], int off, int len)方法作用：从指定的字节数组写入len字节,从偏移量off开始输出到此输出流。 1234567891011121314import java.io.FileOutputStream;import java.io.IOException;public class Demo02Write { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"FOS2.txt\"); byte[] bytes = {97, 98, 99, 100, 101, 102}; // 将3个字节从bytes字节数组写入fos输出流。 fos.write(bytes, 1, 4); fos.close(); }} 运行结果：生成了一个”FOS2.txt”文件 write方法简单练习 12345678910111213141516171819import java.io.FileOutputStream;import java.io.IOException;import java.util.Arrays;public class Demo03Write { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"FOS3.txt\"); // 调用String类中的getBytes()方法，把一串字符转换为byte数组 byte[] bytes = \"大佬，你好！\".getBytes(); // 将该数组转换为集合输出 System.out.println(Arrays.toString(bytes)); // 将多个字节从bytes字节数组写入fos输出流。 fos.write(bytes); fos.close(); }} 控制台输出 1[-27, -92, -89, -28, -67, -84, -17, -68, -116, -28, -67, -96, -27, -91, -67, -17, -68, -127] 运行结果：还生成了一个”FOS3.txt”文件 字节输出流的续写和换行12345public FileOutputStream(File file, boolean append)// 创建文件输出流以写入由指定的File对象表示的文件。public FileOutputStream(String name, boolean append)// 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个 boolean类型的值，true表示追加数据，false表示清空原有数据这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 123456789101112131415161718import java.io.FileOutputStream;import java.io.IOException;public class Demo01OutputAppend { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"a.txt\", true); // 往\"a.txt\"文件中写入\"大佬，\"内容 byte[] bytes1 = \"大佬，\".getBytes(); fos.write(bytes1); // 往\"a.txt\"文件中追加写入\"你好！\"内容 byte[] bytes2 = \"你好！\".getBytes(); fos.write(bytes2); fos.close(); }} 运行结果：生成了一个”a.txt”文件 如果需要换行： 12345678910111213141516171819202122import java.io.FileOutputStream;import java.io.IOException;public class Demo02OutputAppend { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(\"b.txt\", true); // 往\"a.txt\"文件中写入\"大佬，\"内容 byte[] bytes1 = \"大佬，\".getBytes(); fos.write(bytes1); // 换行 \"\\n\" 或者 \"\\r\" byte[] bytes = \"\\n\".getBytes(); fos.write(bytes); // 往\"a.txt\"文件中追加写入\"你好！\"内容 byte[] bytes2 = \"你好！\".getBytes(); fos.write(bytes2); fos.close(); }} 运行结果：生成了一个”b.txt”文件 字节输入流 —— InputStreamjava.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 12345678public void close()// 关闭此输入流并释放与此流相关联的任何系统资源。public abstract int read()// 从输入流读取数据的下一个字节。public int read(byte[] b)// 从输入流中读取一些字节数，并将它们存储到字节数组b中。 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法12345public FileInputStream(String name) throws FileNotFoundException// 通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名name命名。public FileInputStream(File file) throws FileNotFoundException// 通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的File对象file命名。 当我们创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件，会抛出FileNotFoundException异常。 读取数据的原理（硬盘–&gt;内存）：Java程序 –&gt; Java虚拟机 –&gt; 操作系统 –&gt; 操作系统调用读取数据的方法 –&gt; 读取文件 字节输入流的使用步骤 创建FileInputStream对象，构造方法中绑定要读取的数据源。 使用FileInputStream对象中的方法read，读取文件。 释放资源。 下面这个例子中使用的read()方法是一个字节一个字节的读取的。 123456789101112131415161718192021222324252627282930313233import java.io.FileInputStream;import java.io.IOException;public class DemoInputRead { public static void main(String[] args) throws IOException { // 创建FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/A\"); // 使用FileInputStream对象中的方法read，读取文件 // char=65 对应 A int lien0 = fis.read(); char c0 = (char) lien0; System.out.println(lien0 + \"对应\" + c0); // char=10 对应 /n int lien1 = fis.read(); char c1 = (char) lien1; System.out.println(lien1 + \"对应\" + c1); // char=66 对应 B int lien2 = fis.read(); char c2 = (char) lien2; System.out.println(lien2 + \"对应\" + c2); // char=10 对应 /n int lien3 = fis.read(); char c3 = (char) lien3; System.out.println(lien3 + \"对应\" + c3); // 释放资源 fis.close(); }} 文件A的内容： 如果已经将文件A的内容读取完了，那么再读取的话，会返回-1。 FileInputStream类中的部分方法1234567891011121314151617int available()// 返回此输入流下一个方法调用可以不受阻塞地从此输入流读取(或跳过)的估计字节数。void close()// 关闭此输入流并释放与该流关联的所有系统资源。int read()// 从输入流中读取数据的下一个字节。int read(byte b[])// 从输入流中读取一定数量的字节,并将其存储在緩神区数组b中。int read(byte b[], int off, int len)// 将输入流中最多len个数据字节读入byte数组。long skip(long n)// 跳过和丢弃此输入流中数据的n个字节。 read(byte b[])方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.FileInputStream;import java.io.IOException;public class Demo02InputRead { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/B\"); // 创建一个byte数组，存储读取的字节 byte[] bytes = new byte[2]; // 开始读取，每次读取两个 // 第一次读取： bytes = {97, 98}，len1 = 2 int len1 = fis.read(bytes); System.out.println( \"bytes = \" + new String(bytes) + \"\\t\\t\" + \"len = \" + len1 ); // 开始读取，每次读取两个 // 第二次读取： bytes = {99, 100}，len2 = 2 int len2 = fis.read(bytes); System.out.println( \"bytes = \" + new String(bytes) + \"\\t\\t\" + \"len = \" + len2 ); // 开始读取，每次读取两个 // 第三次读取： bytes = {101, 100}，len3 = 2 int len3 = fis.read(bytes); System.out.println( \"bytes = \" + new String(bytes) + \"\\t\\t\" + \"len = \" + len3 ); // 开始读取，每次读取两个 // 第四次读取： bytes = {101, 100}，len4 = 2 int len4 = fis.read(bytes); System.out.println( \"bytes = \" + new String(bytes) + \"\\t\\t\" + \"len = \" + len4 ); }} 文件B内容： 控制台输出 1234bytes = ab len = 2bytes = cd len = 2bytes = ed len = 1bytes = ed len = -1 解析： 第一次读取：读取第1个字节和第2个字节，将初始数组的{0, 0} 替换为 {a, b} 第二次读取：读取第3个字节和第4个字节，将第一次读取后的数组的{a, b} 替换为 {c, d} 第三次读取：读取第5个字节，发现没有可以读取的了，于是将第二次读取的数组的 {c, d}里面的c替换为e，而d没得替换，即{e, d} 第四次读取：因为第三次读取的时候，已经读取完了，没有可以读取的了，依旧还是原来的数组{e, d} 第一次读取两个字节（len1=2），第二次读取两个字节（len2=2），第三次读取1个字节（len3=2），第四次没得读取（len4=-1）。 读取完后，再读取，返回值是-1。 字节流练习：图片复制文件复制的步骤： 创建一个字节输入流对象，构造方法中绑定要读取的数据源。 创建一个字节输出流对象，构造方法中绑定要写入的目的地。 使用字节输入流对象中的方法read读取文件。 使用字节输出流中的方法write，把读取到的字节写入到目的地的文件中。 释放资源。 123456789101112131415161718192021222324import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class DemoCopyFile { public static void main(String[] args) throws IOException { // 创建一个字节输入流对象，构造方法中绑定要读取的数据源。 FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo30/666.jpg\"); // 创建一个字节输出流对象，构造方法中绑定要写入的目的地。 FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo30/999.jpg\"); // 使用字节输入流对象中的方法read读取文件。 int len = 0; while ((len = fis.read()) != -1) { // 使用字节输出流中的方法write，把读取到的字节写入到目的地的文件中。 fos.write(len); } // 释放资源。先关闭写的，再关闭读的。 fis.close(); fos.close(); }} 运行结果： 程序优化： 12345678910111213141516171819202122232425import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Demo02CopyFile { public static void main(String[] args) throws IOException { // 创建一个字节输入流对象，构造方法中绑定要读取的数据源。 FileInputStream fis = new FileInputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo30/666.jpg\"); // 创建一个字节输出流对象，构造方法中绑定要写入的目的地。 FileOutputStream fos = new FileOutputStream(\"/Users/liyihua/IdeaProjects/Study/src/view/study/demo30/999.jpg\"); // 使用字节输入流对象中的方法read读取文件。 int len = 0; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) { // 使用字节输出流中的方法write，把读取到的字节写入到目的地的文件中。 fos.write(bytes, 0, len); } // 释放资源。 fis.close(); fos.close(); }}","link":"/p/041803202005/"},{"title":"程序的耦合和解耦","text":"@Author: YiHua Lee @Address: Guangdong province, China 什么是程序的耦合 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多， 其耦合性越强， 同时表明其独立性越差 ( 降低耦合性， 可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合 。 它有如下分类： 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。 数据耦合。 模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实 现的。 总结： 耦合是影响程序复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合 内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合， 高内聚。 就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行程序设计时，应力争做到高内聚，低耦合。 什么是程序的解耦 解耦，字面意思就是解除耦合关系。 降低耦合度即可以理解为解耦，模块间有依赖关系必然存在耦合，理论上的绝对零耦合是做不到的，但可以通过一些现有的方法将耦合度降至最低。 设计的核心思想：尽可能减少代码耦合，如果发现代码耦合，就要采取解耦技术。让数据模型，业务逻辑和视图显示三层之间彼此降低耦合，把关联依赖降到最低，而不至于牵一发而动全身。原则就是A功能的代码不要写在B的功能代码中，如果两者之间需要交互，可以通过接口，通过消息，甚至可以引入框架，但总之就是不要直接交叉写。 观察者模式：观察者模式存在的意义就是「解耦」，它使观察者和被观察者的逻辑不再搅在一起，而是彼此独立、互不依赖。比如网易新闻的夜间模式，当用户切换成夜间模式之后，被观察者会通知所有的观察者「设置改变了，大家快蒙上遮罩吧」。QQ消息推送来了之后，既要在通知栏上弹个推送，又要在桌面上标个小红点，也是观察者与被观察者的巧妙配合。 参考文献 什么是耦合、解耦","link":"/p/531023202007/"},{"title":"通过 Python 使用 Selenium 爬取淘宝商品","text":"@Author: YiHua Lee @Address: Guangdong province, China 无注解版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import pymongofrom selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom pyquery import PyQuery as pqfrom urllib.parse import quote# browser = webdriver.Chrome()# browser = webdriver.PhantomJS(service_args=SERVICE_ARGS)chrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--headless')browser = webdriver.Chrome(chrome_options=chrome_options)MONGO_URL = 'localhost'MONGO_DB = 'taobao'MONGO_COLLECTION = 'products'KEYWORD = 'ipad'MAX_PAGE = 100SERVICE_ARGS = ['--load-images=false', '--disk-cache=true']wait = WebDriverWait(browser, 10)client = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]def index_page(page): \"\"\" 抓取索引页 :param page: 页码 \"\"\" print('正在爬取第', page, '页') try: url = 'https://s.taobao.com/search?q=' + quote(KEYWORD) browser.get(url) if page &gt; 1: input = wait.until( EC.presence_of_element_located((By.CSS_SELECTOR, '#mainsrp-pager div.form &gt; input'))) submit = wait.until( EC.element_to_be_clickable((By.CSS_SELECTOR, '#mainsrp-pager div.form &gt; span.btn.J_Submit'))) input.clear() input.send_keys(page) submit.click() wait.until( EC.text_to_be_present_in_element((By.CSS_SELECTOR, '#mainsrp-pager li.item.active &gt; span'), str(page))) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.m-itemlist .items .item'))) get_products() except TimeoutException: index_page(page)def get_products(): \"\"\" 提取商品数据 \"\"\" html = browser.page_source doc = pq(html) items = doc('#mainsrp-itemlist .items .item').items() for item in items: product = { 'image': item.find('.pic .img').attr('data-src'), 'price': item.find('.price').text(), 'deal': item.find('.deal-cnt').text(), 'title': item.find('.title').text(), 'shop': item.find('.shop').text(), 'location': item.find('.location').text() } print(product) save_to_mongo(product)def save_to_mongo(result): \"\"\" 保存至MongoDB :param result: 结果 \"\"\" try: if db[MONGO_COLLECTION].insert(result): print('存储到MongoDB成功') except Exception: print('存储到MongoDB失败')def main(): \"\"\" 遍历每一页 \"\"\" for i in range(1, MAX_PAGE + 1): index_page(i) browser.close()if __name__ == '__main__': main() 有注释版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom urllib.parse import quotefrom pyquery import PyQueryfrom pymongo import MongoClientbrowser = webdriver.Chrome()wait = WebDriverWait(browser, 10)KEYWORD = 'iPad'def index_page(page): \"\"\" 抓取索引页 :param page: 页码 \"\"\" print('正在爬取第', page, '页') try: url = 'https://s.taobao.com/search?q=' + quote(KEYWORD) browser.get(url) if page &gt; 1: input = wait.until( EC.presence_of_element_located( (By.CSS_SELECTOR, '#mainsrp-page div.form &gt; input') ) ) # 利用 CSS 选择器，选择 id=mainsrp-page 的节点的所有元素，再从中选择父节点为 div 的 input 元素 # 其中 div 的属性 class=form。此时选择的是输入框 submit = wait.until( EC.element_to_be_clickable( (By.CSS_SELECTOR, '#mainsrp-pager div.form &gt; span.btn.J_Submit') ) ) # 利用CSS选择器，选择 id=mainsrp-pager 的节点的所有元素，再从中选择父节点为 div 的 span 元素 # 其中 div 的属性 class=form，span 的属性 class=btn J_Submit。此时选择的是\"确定\"按钮 input.clear() # 清除输入框中的内容 input.send_keys(page) # 在输入框中输入页码 page submit.click() # 点击确定按钮 wait.until( EC.text_to_be_present_in_element( (By.CSS_SELECTOR, '#mainsrp-pager li.item.active &gt; span'), str(page) ) ) # 利用CSS选择器，选择 id=mainsrp-pager 的节点的所有元素，在从中选出 span 节点， # 其中span节点的父节点为li节点，li节点的属性class=item active wait.until( EC.presence_of_element_located( (By.CSS_SELECTOR, '.m-itemlist .items .item') ) ) # 利用 CSS 选择器，选择 class=m-iremlist 的节点，从该节点中选择 class-items 的节点，再从中选择 class=item 的节点的所有元素 # 这里对应的是这一页中的每个淘宝商品 get_products() except TimeoutException: index_page(page)def get_products(): \"\"\" 提取商品数据 \"\"\" html = browser.page_source # 获取源代码 doc = PyQuery(html) # 解析html items = doc('#mainsrp-itemlist .items .item').items() for item in items: # 这个 item 中 product = { 'image': item.find('.pic .J_ItemPic.img').attr('data-src'), # 找到 class=pic 的节点，再从中选择 class=J_ItemPic img 的节点，最后通过 attr() 方法获取 data-src 属性 'price': item.find('.price.g_price.g_price-highlight').text(), # 找到属性 class=price g_price g_price-highlight 的节点，获取其文本（价格） 'deal': item.find('.deal-cnt').text(), # 找到 class=deal-cnt 的节点，获取其文本（付款人数） 'title': item.find('row.row-2.title').text(), # 找到属性值 class=row row-2 title 的节点，获取其文本（商品价格） 'shop': item.find('.shop').text(), # 获取 class=shop 的节点的文本（店铺） 'location': item.find('.location').text() # 获取 class=location 的节点的文本（店铺地址） } print(product) save_to_mongo(product)MONGO_URL = 'localhost'MONGO_DB = 'TaoBao'MONGO_COLLECTION = 'products'client = MongoClient(MONGO_URL)db = client[MONGO_DB]def save_to_mongo(result): \"\"\" 将爬取结果保存到MongoDB :param result: 结果 :return: \"\"\" try: if db[MONGO_COLLECTION].insert(result): print('存储到 MongoDB 成功') except Exception: print('存储到 MongoDB 失败')MAX_PAGE = 100def main(): \"\"\" 遍历每一页 :return: \"\"\" for i in range(1, MAX_PAGE + 1): index_page(i) browser.close()if __name__ == '__main__': main()","link":"/p/161730202004/"},{"title":"网络爬虫基础","text":"@Author: YiHua Lee @Address: Guangdong province, China HTTP基本原理URI全称UniformResource Identifier，即统一资源标志符，用来唯一的标识一个资源。 URLUniversal Resource Locator，统一资源定位符。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源 Hypertext网页源代码是一系列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码HTML 就可以称作超文本（Hypertext） HTTP和HTTPS http是一种协议，全称超文本传输协议，所有的www文件都必须遵守这个标准 https，是以安全为目的的http通道，简单讲是http的安全版 安全性：http不安全，https安全 加密：http无法加密，https加密传输 证书：http无需证书，https需证书 HTTP请求过程 HTTPS请求过程 请求Request Method常用的请求方法：GET和POST GET ：请求页面，并返回页面内容 POST：大多用于提交表单或上传文件，数据包含在请求题中 Request URL请求的网址，即统一资源定位符，用 URL 可以唯一确定我们想请求的资源 Request Headers用来说明服务器要使用的附加信息 Request Body请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空 响应Response Status Code举例： 123456789307 临时重定向 请求的资源临时从其他位置响应。400 错误请求 服务器无法解析该请求。401 未授权 请求没有进行身份验证或验证未通过。403 禁止访问 服务器拒绝此请求。404 未找到 服务器找不到请求的网页。405 方法禁用 服务器禁用了请求中指定的方法。406 不接受 无法使用请求的内容响应请求的网页。407 需要代理授权 请求者需要使用代理授权。408 请求超时 服务器请求超时。 Response Headers响应头包含了服务器对请求的应答信息，如： 12345authority: www.google.commethod: GETscheme: httpsuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36x-client-data: CKi1yQEIlbbJAQijtskBCMG2yQEIqZ3KAQiwoMoBCNCvygEIvLDKAQjttcoBCI66ygEI8cbKARi9usoB Response Body最重要的当属响应体内容了，响应的正文数据都是在响应体中 例如：请求一个网页，它的响应体就是网页的 HTML 代码；请求一张图片，它的响应体就是图片的二进制数据。 网页基础网页的组成HTML 定义了网页的内容和结构， css 描述了网页的布局， JavaScript 定义了网页的行为 。 HTMLHyper Text Markup Language，描述网页的一种语言，即超文本标记语言。 CSSCascading Style Sheets，层叠样式表。HTML 定义了网页的结构，但是只有 HTML 页面的布局并不美观，借助CSS，页面会变得更加美观、优雅。 JSJavaScript，是一种脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能 选择器 网页是由一个一个的节点组成的，CSS选择器会根据不同的节点设置不同的样式规则。 CSS 中，选择器是一种模式，用于选择需要添加样式的元素 爬虫的基本原理网络爬虫概述 获取网页，即获取网页的源代码。 提取信息 通用方法：正则表达式 根据网页节点的属性：CSS选择器、XPath 来提取网页信息的库（例如：Beautiful Soup、pyquery、lxml等） 获取网页的源代码，保存数据 提取信息后，保存到数据库，如MySQL和MongoDB等，也可以保存至远程服务器，如借助SFTP进行操作等 自动化程序 爬虫代替人完成操作 JavaScript渲染页面 JavaScript会改变HTML中的节点，向其添加内容，最后得到完整的页面 使用urllib或requests等库请求当前页面时，得到的只是这个HTML代码。可使用Selenium、Splash这样的库来实现模拟JavaScript渲染。 会话（服务端） 和 Cookies（客户端） 静态网页 网页的内容是 HTML 代码编写的，文字、图片等内容均通过写好的 HTML 代码来指定 ， 这种页面叫作静态网页 12优点：加载速度快、编写简单缺点：可维护性差 ，不能根据URL灵活多变地显示内容等 动态网页 页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。 会话其本来的含义是指有始有终的一系列动作/消息。在 Web 中，会话对象用来存储特定用户会话所需的属性及配置信息 Cookies某些网站为了辨别用户身份 、 进行会话跟踪而存储在用户本地终端上的数据 会话维持：Cookies 和会话需要配合，一个处于客户端，一个处于服务端，二者共同协作，实现登录会话控制。 会话 Cookie就是把 Cookie放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效 ; 持久 Cookie则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态 代理的基本原理基本原理 代理服务器（proxy server）—实现IP伪装 功能：代理网络用户去取得网络信息—网络信息的中转站 在本机和服务器之间搭建一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求 代理的作用 突破自身IP的访问限制 访问一些单位或团体的内部资源 提高访问速度 隐藏真实IP 爬虫代理 爬虫爬取速度过快，在爬取过程中可能遇到同一个 IP访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁IP。 使用代理隐藏真实的 IP，让服务器误以为是代理服务器在请求向己 在爬取过程中通过不断更换代理，就不会被封锁，可 以达到很好的爬取效果。 代理分类 根据协议区分 FTP代理服务器、HTTP 代理服务器、SSL厅LS代理、RTSP 代理、Telnet代理、POP3/SMTP 代理、SOCKS 代理 根据匿名程度区分 高度匿名代理、普通匿名代理、透明代理、间谍代理 常见的代理设置 使用网上的免费代理 使用付费代理服务 ADSL 拨号","link":"/p/131529202004/"},{"title":"通过Java程序简单模拟B/S服务器","text":"@Author: YiHua Lee @Address: Guangdong province, China 模拟Browser/Servers服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析准备页面数据创建index.html文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;itheima商城&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=\"1600px\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"img/logo2.png\"&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=\"img/header.jpg\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;登录&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\"&gt;注册&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\"&gt;购物车&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"black\" height=\"40px\"&gt; &lt;td colspan=\"3\"&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\"&gt;首页&lt;/a&gt; &amp;nbsp; &lt;a href=\"#\"&gt;手机数码&lt;/a&gt; &amp;nbsp; &lt;a href=\"#\"&gt;电脑办公&lt;/a&gt; &amp;nbsp; &lt;a href=\"#\"&gt;电脑办公&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"3\"&gt;&lt;img src=\"img/1.jpg\" width=\"\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h1 align=\"center\"&gt;热门商品 &lt;img src=\"img/title2.jpg\"&gt;&lt;/h1&gt; &lt;table width=\"1600px\"align=\"center\"&gt; &lt;tr align=\"center\"&gt; &lt;td rowspan=\"2\"&gt;&lt;img src=\"img/big01.jpg\"&gt;&lt;/td&gt; &lt;td colspan=\"3\"&gt; &lt;img src=\"img/middle01.jpg\" /&gt; &lt;/td&gt; &lt;td &gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align=\"center\"&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table align=\"center\" width=\"100%\"&gt;&lt;tr&gt;&lt;td align=\"center\"&gt;&lt;img src=\"img/ad.jpg\" align=\"center\" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table width=\"1600px\"align=\"center\"&gt; &lt;tr align=\"center\"&gt; &lt;td rowspan=\"2\"&gt;&lt;img src=\"img/big01.jpg\"&gt;&lt;/td&gt; &lt;td colspan=\"3\"&gt; &lt;img src=\"img/middle01.jpg\" /&gt; &lt;/td&gt; &lt;td &gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr align=\"center\"&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"img/small03.jpg\"&gt;&lt;br /&gt; 冬瓜&lt;br /&gt; &lt;font color=\"red\"&gt;$299.99&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table width=\"1024px\" align=\"center\"&gt; &lt;tr align=\"center\"&gt; &lt;td&gt; &lt;img src=\"img/footer.jpg\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr align=\"center\"&gt;&lt;td&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 创建reg.html文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style type=\"text/css\"&gt; /*页面整体背景图*/ body{ background-image: url(img/bg.jpg); } /* * 外层白色背景 */ .formId{ width: 700px; height: 500px; border: 1px solid #333; margin: 150px auto; background-color: #FFFFFF; padding-top: 30px; padding-left:150px; } /* * 表单注册区域 */ .formReg{ width: 500px; height: 450px; border: 0px solid #333; } h3{ color: #0000FF; font-size: 20px; } h3 span{ color: #000000; font-size:16px; } tr{ height: 35px; } .in{ width: 200px; height: 30px; margin-left: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"formId\"&gt; &lt;div class=\"formReg\"&gt; &lt;h3&gt;用户注册 &lt;span&gt; USERREGiSTER&lt;/span&gt;&lt;/h3&gt; &lt;form action=\"#\" method=\"get\"&gt; &lt;table width=\"500px\"&gt; &lt;tr&gt; &lt;td align=\"right\"&gt;用户名&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;input class=\"in\" name=\"username\" placeholder=\"请输入用户名\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt;密码&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;input class=\"in\" type=\"password\" name=\"password\" placeholder=\"请输入用密码\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt;性别&lt;/td&gt; &lt;td colspan=\"2\"&gt;男&lt;input type=\"radio\" name=\"sex\" checked=\"checked\"/&gt; 女&lt;input type=\"radio\" name=\"sex\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"code\"&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=\"img/checkcode.jpg\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"3\" align=\"center\"&gt; &lt;input type=\"image\" src=\"img/btn.jpg\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 图片可以自行准备，不过没图片也可以，只是浏览效果没这么好。 模拟服务器端ServerSocket类监听端口，使用浏览器访问http://localhost:8000/web/index.html 访问前，应该先开启服务器端。 代码实现： 第1步：建立连接 1234// 创建服务端ServerSocket，监听端口为8000ServerSocket serverSocket = new ServerSocket(8000);// 建立连接Socket accept = serverSocket.accept(); 第2步：获取字符缓冲输入流 1234567// 创建流对象// 获取网络字节输入流InputStream is = accept.getInputStream();// 将网络字节输入流转换为网络字符输入流InputStreamReader isr = new InputStreamReader(is);// 传入网络字符输入流，获取字符缓冲输入流BufferedReader br = new BufferedReader(isr); 第3步：读取浏览器的请求信息（包含html文件路径） 12345678// 读取浏览器的请求消息// 把客户端请求信息的第一行取出来：GET /web/index.html HTTP/1.1String request = br.readLine();// 取出请求资源的路径：/web/index.html// 把读取的信息进行切割，只要中间的部分：/web/index.htmlString[] strArr = request.split(\" \");// 获取数组的第二个元素，得到：/web/index.htmlString path = strArr[1]; 第4步：创建本地输入流对象 123// 根据得到的路径：web/index.html// 创建本地字节输入流对象，构造方法中绑定要读取的html路径：/web/index.htmlFileInputStream fis = new FileInputStream(path); 第5步：获取网络字节输出流 12// 获取网络字节输出流，将文件写回客户端：Browser——浏览器端OutputStream out = accept.getOutputStream(); 第6步：写入HTTP响应头 12345// 写入HTTP协议响应头，固定写法out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());out.write(\"Content‐Type:text/html\\r\\n\".getBytes());// 必须要写入空行，否则浏览器不解析out.write(\"\\r\\n\".getBytes()); 第7步：将服务端读取的HTML文件回写到客户端——浏览器端 123456// 一读一写复制文件，将服务端读取的html文件回写到客户端byte[] bytes= new byte[1024];int len = 0 ;while((len = fis.read(bytes)) != -1){ out.write(bytes, 0, len);} 第8步：释放资源 123456// 释放资源fis.close();out.close();br.close();accept.close();serverSocket.close(); 所有代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.FileInputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class BrowserServer { public static void main(String[] args) throws IOException { System.out.println(\"服务端 启动 , 等待连接 .... \"); method(); } private static void method() throws IOException { ServerSocket serverSocket = new ServerSocket(8000); Socket accept = serverSocket.accept(); InputStream is = accept.getInputStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String request = br.readLine(); String[] strArr = request.split(\" \"); String path = strArr[1]; FileInputStream fis = new FileInputStream(path); OutputStream out = accept.getOutputStream(); out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content‐Type:text/html\\r\\n\".getBytes()); out.write(\"\\r\\n\".getBytes()); byte[] bytes= new byte[1024]; int len = 0 ; while((len = fis.read(bytes)) != -1){ out.write(bytes, 0, len); } fis.close(); out.close(); br.close(); accept.close(); serverSocket.close(); }} 运行服务器端，然后用浏览器访问http://localhost:8000/web/index.html，效果如下：","link":"/p/091404202005/"},{"title":"《鸟哥的Linux私房菜--基础篇》第四、五章学习心得","text":"@Author: YiHua Lee @Address: Guangdong province, China 第四章 显示日期与时间的指令 1date 显示日历指令 1cal 简单好用的计算器 1bc 命令后接[Tab]键 [Tab]键 接在一串指令的第一个后面—-命令补全 [Tab]键 接在一串指令的第二个后面—-文件补全 [Tab]键 在一些字符后面接两个[Tab]键—-查看这些字符开头的命令 中断目前的程序 1[control]键 + [c]键 键盘输入结束 1键盘输入结束（End Of File,EOF 或 End Of Input) 的意思 往前翻页 或 往后翻页 1[shift]键 + [PageUp]键 或[PageDown]键 关机指令 1shutdown 1reboot 第五章Linux文件权限与目录配置1ls -al 改变文件的权限与属性 改变所属群组 1chown 群组名称 文件或目录 1chgrp users file 改变权限 1chmod 1234说明：owner = rwx = 4 + 2 + 1 = 7group = rwx = 4 + 2 + 1 = 7others = --- = 0 + 0 + 0 = 0 数字类型改变文件权限 1chown 三个数字 file 12说明：- r : 4 w : 2 x : 1 - : 0 符号类型改变文件权限 例如： 1chmod u=rwx g=rwx o =r file 1说明：文件[ file ] 权限给改为 - r w x r w x r - -","link":"/p/531329202004/"},{"title":"阿里云服务器搭建动态博客","text":"@Author: YiHua Lee @Address: Guangdong province, China 用阿里云服务器部署一个wordpress网站","link":"/p/011706202005/"},{"title":"用户信息案例","text":"@Author: YiHua Lee @Address: Guangdong province, China 案例要求功能要求： 登录功能 添加、修改、删除功能 删除所选项功能 分页查询功能 复杂条件查询功能 准备阶段 下载jar包 将jar包导入到 WEB-INF/lib 目录下 c3p0-0.9.1.2.jar commons-beanutils-1.8.3.jar commons-logging-1.1.1.jar druid-1.0.9.jar javax.servlet.jsp.jstl.jar jstl-impl.jar mysql-connector-java-5.1.18-bin.jar spring-beans-4.2.4.RELEASE.jar spring-core-4.2.4.RELEASE.jar spring-jdbc-4.2.4.RELEASE.jar spring-tx-4.2.4.RELEASE.jar 导入bootstrap.js、jquery-2.1.0.min.js、bootstrap.css、bootstrap-theme.css 导入字体 前端页面展示部分管理员登录页面分析管理员登录页面，分为以下几个部分： 登录页面的实现：login.jsp 头部信息导入css、js 12345678910111213&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;title&gt;管理员登录&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 创建一个模块，该模块包含六个部分 1&lt;div class=\"container\" style=\"width: 400px;\"&gt;&lt;/div&gt; 第一部分： 1&lt;h3 style=\"text-align: center;\"&gt;管理员登录&lt;/h3&gt; 创建一个表单，该表单包含 2～5 部分： 1&lt;form action=\"${pageContext.request.contextPath}/loginServlet\" method=\"post\"&gt;&lt;/form&gt; 将该表单分为四个组： 第二部分：用户名 12345&lt;div class=\"form-group\"&gt; &lt;!-- 创建一个标签用户名，对应用户名输入框id --&gt; &lt;label for=\"user\"&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"user\" class=\"form-control\" id=\"user\" placeholder=\"请输入用户名\"&gt;&lt;/div&gt; 2. 第三部分：密码 1234&lt;div class=\"form-group\"&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" id=\"password\" placeholder=\"请输入密码\"/&gt;&lt;/div&gt; 3. 第四部分：验证码 * 验证码输入框： 123&lt;div class=\"form-inline\"&gt; &lt;input type=\"text\" name=\"verifycode\" class=\"form-control\" id=\"verifycode\" placeholder=\"请输入验证码\" style=\"width: 120px;\"&gt;&lt;/div&gt; * 验证码： 更新验证码功能： 1234567// 切换验证码function refreshCode(){ //1.获取验证码图片对象 var vcode = document.getElementById(\"vcode\"); //2.设置其src属性，加时间戳 vcode.src = \"${pageContext.request.contextPath}/checkCodeServlet?time=\"+new Date().getTime();} 获取验证码图片，绑定对应的Servlet、js： 1234&lt;label for=\"vcode\"&gt;验证码：&lt;/label&gt;&lt;a href=\"javascript:refreshCode();\"&gt; &lt;img src=\"${pageContext.request.contextPath}/checkCodeServlet\" title=\"看不清点击刷新\" id=\"vcode\"/&gt;&lt;/a&gt; 4. 第五部分：登录按钮 1234&lt;!-- 登录按钮 --&gt;&lt;div class=\"form-group\" style=\"text-align: center;\"&gt; &lt;input class=\"btn btn btn-primary\" type=\"submit\" value=\"登录\"&gt;&lt;/div&gt; 登录信息有误，提示功能 123456&lt;div class=\"alert alert-warning alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" &gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;strong&gt;${login_msg}&lt;/strong&gt;&lt;/div&gt; 定义一个提示框，该提示框有关闭按钮，以及提示信息，提示信息，通过Expression Language动态获取。 登录页面的基本结构已经实现，总代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;title&gt;管理员登录&lt;/title&gt; &lt;!-- 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 切换验证码 function refreshCode() { // 1.获取验证码图片对象 var vcode = document.getElementById(\"vcode\"); // 2.设置其src属性，加时间戳 vcode.src = \"${pageContext.request.contextPath}/checkCodeServlet?time=\" + new Date().getTime(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;h3 style=\"text-align: center;\"&gt;管理员登录&lt;/h3&gt; &lt;!-- 用户输入信息部分 --&gt; &lt;form action=\"${pageContext.request.contextPath}/loginServlet\" method=\"post\"&gt; &lt;!-- 用户名 --&gt; &lt;div class=\"form-group\"&gt; &lt;!-- 创建一个标签用户名，对应用户名输入框id --&gt; &lt;label for=\"user\"&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"user\" class=\"form-control\" id=\"user\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;!-- 密码 --&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" id=\"password\" placeholder=\"请输入密码\"/&gt; &lt;/div&gt; &lt;!-- 验证码 --&gt; &lt;div class=\"form-inline\"&gt; &lt;input type=\"text\" name=\"verifycode\" class=\"form-control\" id=\"verifycode\" placeholder=\"请输入验证码\" style=\"width: 120px;\"&gt; &lt;label for=\"vcode\"&gt;验证码：&lt;/label&gt; &lt;a href=\"javascript:refreshCode();\"&gt; &lt;img src=\"${pageContext.request.contextPath}/checkCodeServlet\" title=\"看不清点击刷新\" id=\"vcode\"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;hr/&gt; &lt;!-- 登录按钮 --&gt; &lt;div class=\"form-group\" style=\"text-align: center;\"&gt; &lt;input class=\"btn btn btn-primary\" type=\"submit\" value=\"登录\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 出错显示的信息框 --&gt; &lt;div class=\"alert alert-warning alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" &gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;strong&gt;${login_msg}&lt;/strong&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 登录页面的展示效果： 由于对应的LoginServlet和CheckCodeServlet还没实现，所以信息提示，和验证码图片都没有生成。 首页分析管理员用户登录后，跳转到首页，首页显示欢迎该用户的信息，以及管理员用户查看所有用户的信息跳转。 首页的实现：index.jsp 首页的实现，分为两个部分： 第一部分：某XX，欢迎您！ 第二部分：查询所有用户信息 第一部分： 1&lt;div &gt;${user.name}，欢迎您！&lt;/div&gt; 这里的用户信息类还没编写 第二部分： 1234&lt;div align=\"center\"&gt; &lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet\" style=\"text-decoration:none;font-size:33px\"&gt;查询所有用户信息&lt;/a&gt;&lt;/div&gt; 指定跳转到对应的Servlet –&gt; 所有的用户信息 登录页面的代码： 1234567891011121314151617181920212223&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;title&gt;首页&lt;/title&gt; &lt;!-- 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div &gt;${user.name}，欢迎您！&lt;/div&gt; &lt;div align=\"center\"&gt; &lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet\" style=\"text-decoration:none;font-size:33px\"&gt;查询所有用户信息&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 实现效果： 用户信息页面分析 用户信息页面的实现：list.jsp 头部信息 12345678910111213141516171819202122&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; 创建一个容器，该容器包含用户信息的每个部分 第一部分： 1&lt;h3 style=\"text-align: center\"&gt;用户信息列表&lt;/h3&gt; 第二部分和第三部分，处在同一行，分别在左边和右边： 第二部分：创建一个表单，包含四个小模块，着四个小方框中的值都是从condition中获取 1234567891011121314151617&lt;div style=\"float: left;\"&gt; &lt;form class=\"form-inline\" action=\"${pageContext.request.contextPath}/findUserByPageServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" value=\"${condition.name[0]}\" class=\"form-control\" id=\"exampleInputName2\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName3\"&gt;籍贯&lt;/label&gt; &lt;input type=\"text\" name=\"address\" value=\"${condition.address[0]}\" class=\"form-control\" id=\"exampleInputName3\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"text\" name=\"email\" value=\"${condition.email[0]}\" class=\"form-control\" id=\"exampleInputEmail2\" &gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; 表单指定findUserByPageServlet处理请求。 * 第三部分：包含两个按钮，添加联系人按钮，和删除选中按钮 1234&lt;div&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/add.jsp\"&gt;添加联系人&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"javascript:void(0);\" id=\"delSelected\"&gt;删除选中&lt;/a&gt;&lt;/div&gt; 添加联系人按钮，知道跳转到add.jsp页面。 删除选中按钮，功能提交给javascript转接：javascript的实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; // 用户安全提示：您确定要删除吗？ function deleteUser(id) { if (confirm(\"您确定要删除吗？\")) { // 跳转到delUserServlet location.href = \"${pageContext.request.contextPath}/delUserServlet?id=\" + id; } } window.onload = function () { // 给删除选中按钮添加单击事件 document.getElementById(\"delSelected\").onclick = function () { if (confirm(\"您确定要删除选中条目吗？\")) { var flag = false; // 判断是否有选中的条目 var cbs = document.getElementsByName(\"uid\"); for (var i=0; i&lt;cbs.length; i++) { if (cbs[i].checked) { // 有一个条目选中了 flage = true; break; } } if (flag) { // 有条目被选中 // 表单提交 document.getElementById(\"form\").submit(); } } } } // 获取第一个cb document.getElementById(\"firstCb\").onclick = function () { // 获取下边列表中所有的cb var cbs = document.getElementsByName(\"uid\"); // 遍历获取到的cb for (var i=0; i&lt;cbs.length; i++) { // 设置这些cb的checked状态 = firstCb.checked cbs[i].checked = this.checked; } }&lt;/script&gt; 这里定义的javascript的功能主要是，给删除按钮绑定单击事件，并且将选中的第一个条目提交。将所有的条目状态都修改为first。这里要被删除的条目id会提交给delUserServlet。 第四部分：创建一个表单，它包含两个模块 1&lt;form id=\"form\" action=\"${pageContext.request.contextPath}/delSelectedServlet\" method=\"post\"&gt;&lt;/form&gt; 该表单的请求与响应提交给delSelectedServlet处理。 第一个模块：信息说明行 1234567891011&lt;tr class=\"success\"&gt; &lt;th&gt;&lt;input type=\"checkbox\" id=\"firstCb\"&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt; 其中，这里的inout标签，是第五部分的实现。 第二个模块：信息展示行 12345678910&lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"uid\" value=\"${user.id}\"&gt;&lt;/td&gt; &lt;td&gt;${s.count}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.gender}&lt;/td&gt; &lt;td&gt;${user.age}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;td&gt;${user.qq}&lt;/td&gt; &lt;td&gt;${user.email}&lt;/td&gt;&lt;/tr&gt; 信息都是从各个对象中获取到的。由于不知一条信息，所以还需要通过 JSTL 标签和 Expression Language对信息获取和展示进行迭代： 123456789101112&lt;c:forEach items=\"${pb.list}\" var=\"user\" varStatus=\"s\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"uid\" value=\"${user.id}\"&gt;&lt;/td&gt; &lt;td&gt;${s.count}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.gender}&lt;/td&gt; &lt;td&gt;${user.age}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;td&gt;${user.qq}&lt;/td&gt; &lt;td&gt;${user.email}&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 其中，这里的inout标签，是第五部分的实现。 在展示行中添加删除和修改按钮（第六部分），在forEach中添加即可： 1234&lt;td&gt; &lt;a class=\"btn btn-default btn-sm\" href=\"${pageContext.request.contextPath}/findUserServlet?id=${user.id}\"&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=\"btn btn-default btn-sm\" href=\"javascript:deleteUser(${user.id});\"&gt;删除&lt;/a&gt;&lt;/td&gt; 第七部分、第八部分：页面索引 首先需要判断当前页面是否是第一页，假如是第一页，就关闭前一页按钮，如果不是第一页就开启前一页按钮： 1234567891011&lt;%-- 判断页码是否是1 --%&gt;&lt;c:if test=\"${pb.currentPage == 1}\"&gt; &lt;li class=\"disabled\"&gt;&lt;/c:if&gt;&lt;c:if test=\"${pb.currentPage != 1}\"&gt; &lt;li&gt;&lt;/c:if&gt; &lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${pb.currentPage - 1}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\" aria-label=\"Previous\"&gt; &lt;spen aria-hidden=\"true\"&gt;&amp;laquo;&lt;/spen&gt; &lt;/a&gt;&lt;/li&gt; 这里实现的是向左按钮，即点击该按钮，页面跳转前一页。 从第一页到最后一页 123456789&lt;%-- 从第一页开始，到最后一页的页面索引（迭代） --%&gt;&lt;c:forEach begin=\"1\" end=\"${pb.totalPage}\" var=\"i\" &gt; &lt;c:if test=\"${pb.currentPage == i}\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${i}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\"&gt;${i}&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"${pb.currentPage != i}\"&gt; &lt;li&gt;&lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${i}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\"&gt;${i}&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt;&lt;/c:forEach&gt; 第八部分： 1234&lt;%-- 总共页数&amp;数据条数 --%&gt;&lt;spen style=\"font-size: 25px;margin-left: 5px;\"&gt; 共${pb.totalCount}条记录，共${pb.totalPage}页&lt;/spen&gt; 用户信息管理页面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 用户安全提示：您确定要删除吗？ function deleteUser(id) { if (confirm(\"您确定要删除吗？\")) { // 跳转到delUserServlet location.href = \"${pageContext.request.contextPath}/delUserServlet?id=\" + id; } } window.onload = function () { // 给删除选中按钮添加单击事件 document.getElementById(\"delSelected\").onclick = function () { if (confirm(\"您确定要删除选中条目吗？\")) { var flag = false; // 判断是否有选中的条目 var cbs = document.getElementsByName(\"uid\"); for (var i=0; i&lt;cbs.length; i++) { if (cbs[i].checked) { // 有一个条目选中了 flage = true; break; } } if (flag) { // 有条目被选中 // 表单提交 document.getElementById(\"form\").submit(); } } } } // 获取第一个cb document.getElementById(\"firstCb\").onclick = function () { // 获取下边列表中所有的cb var cbs = document.getElementsByName(\"uid\"); // 遍历获取到的cb for (var i=0; i&lt;cbs.length; i++) { // 设置这些cb的checked状态 = firstCb.checked cbs[i].checked = this.checked; } } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 style=\"text-align: center\"&gt;用户信息列表&lt;/h3&gt; &lt;div style=\"float: left;\"&gt; &lt;form class=\"form-inline\" action=\"${pageContext.request.contextPath}/findUserByPageServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" value=\"${condition.name[0]}\" class=\"form-control\" id=\"exampleInputName2\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName3\"&gt;籍贯&lt;/label&gt; &lt;input type=\"text\" name=\"address\" value=\"${condition.address[0]}\" class=\"form-control\" id=\"exampleInputName3\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"text\" name=\"email\" value=\"${condition.email[0]}\" class=\"form-control\" id=\"exampleInputEmail2\" &gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/add.jsp\"&gt;添加联系人&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"javascript:void(0);\" id=\"delSelected\"&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=\"form\" action=\"${pageContext.request.contextPath}/delSelectedServlet\" method=\"post\"&gt; &lt;table border=\"1\" class=\"table table-bordered table-hover\"&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;&lt;input type=\"checkbox\" id=\"firstCb\"&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"${pb.list}\" var=\"user\" varStatus=\"s\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"uid\" value=\"${user.id}\"&gt;&lt;/td&gt; &lt;td&gt;${s.count}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.gender}&lt;/td&gt; &lt;td&gt;${user.age}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;td&gt;${user.qq}&lt;/td&gt; &lt;td&gt;${user.email}&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-default btn-sm\" href=\"${pageContext.request.contextPath}/findUserServlet?id=${user.id}\"&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=\"btn btn-default btn-sm\" href=\"javascript:deleteUser(${user.id});\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;%-- 判断页码是否是1 --%&gt; &lt;c:if test=\"${pb.currentPage == 1}\"&gt; &lt;li class=\"disabled\"&gt; &lt;/c:if&gt; &lt;c:if test=\"${pb.currentPage != 1}\"&gt; &lt;li&gt; &lt;/c:if&gt; &lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${pb.currentPage - 1}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\" aria-label=\"Previous\"&gt; &lt;spen aria-hidden=\"true\"&gt;&amp;laquo;&lt;/spen&gt; &lt;/a&gt; &lt;/li&gt; &lt;%-- 从第一页开始，到最后一页的页面索引（迭代） --%&gt; &lt;c:forEach begin=\"1\" end=\"${pb.totalPage}\" var=\"i\" &gt; &lt;c:if test=\"${pb.currentPage == i}\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${i}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\"&gt;${i}&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"${pb.currentPage != i}\"&gt; &lt;li&gt;&lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${i}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\"&gt;${i}&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%-- 下一页按钮 --%&gt; &lt;li&gt; &lt;a href=\"${pageContext.request.contextPath}/findUserByPageServlet?currentPage=${pb.currentPage + 1}&amp;rows=5&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;%-- 总共页数&amp;数据条数 --%&gt; &lt;spen style=\"font-size: 25px;margin-left: 5px;\"&gt; 共${pb.totalCount}条记录，共${pb.totalPage}页 &lt;/spen&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 信息修改页面分析 信息修改页面的实现创建一个容器表单，在该容器中编写每个模块： 123&lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;form action=\"${pageContext.request.contextPath}/updateUserServlet\" method=\"post\"&gt;&lt;form&gt;&lt;/div&gt; 首先，我们要知道管理员用户修改的是哪个普通用户的信息 12&lt;!-- 隐藏域 提交id --&gt;&lt;input type=\"hidden\" name=\"id\" value=\"${user.id}\"&gt; 第一部分： 1&lt;h3 style=\"text-align: center;\"&gt;修改联系人&lt;/h3&gt; 第二部分： 12345&lt;!-- 创建一个只读的姓名显示框，姓名不允许更改 --&gt;&lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" value=\"${user.name}\" readonly=\"readonly\" placeholder=\"请输入姓名\" /&gt;&lt;/div&gt; 第三部分： 123456789101112&lt;%-- 性别的修改选择，必须要确认该被修改者的性别是什么 --%&gt;&lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;c:if test=\"${user.gender == '男'}\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" /&gt;女 &lt;/c:if&gt; &lt;c:if test=\"${user.gender == '女'}\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" checked /&gt;女 &lt;/c:if&gt;&lt;/div&gt; 第四部分： 1234&lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" value=\"${user.age}\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\" /&gt;&lt;/div&gt; 第五部分： 1234567891011121314151617181920212223&lt;%-- 管理员修改用户的省份时，需要判断用户的当前省份，以进入修改页面的时候，选择按钮在用户所在省份 --%&gt;&lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" id=\"address\" class=\"form-control\" &gt; &lt;c:if test=\"${user.address == '陕西'}\"&gt; &lt;option value=\"陕西\" selected&gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"${user.address == '北京'}\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\" selected&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"${user.address == '上海'}\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\" selected&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;/select&gt;&lt;/div&gt; 第六部分： 1234&lt;div class=\"form-group\"&gt; &lt;label for=\"qq\"&gt;QQ：&lt;/label&gt; &lt;input type=\"text\" id=\"qq\" class=\"form-control\" value=\"${user.qq}\" name=\"qq\" placeholder=\"请输入QQ号码\"/&gt;&lt;/div&gt; 第七部分： 1234&lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;Email：&lt;/label&gt; &lt;input type=\"text\" id=\"email\" class=\"form-control\" value=\"${user.email}\" name=\"email\" placeholder=\"请输入邮箱地址\"/&gt;&lt;/div&gt; 第八部分： 12345&lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;input class=\"btn btn-default\" type=\"button\" value=\"返回\"/&gt;&lt;/div&gt; 信息修改页面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;修改用户&lt;/title&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;form action=\"${pageContext.request.contextPath}/updateUserServlet\" method=\"post\"&gt; &lt;h3 style=\"text-align: center;\"&gt;修改联系人&lt;/h3&gt; &lt;%-- 隐藏域 提交id--%&gt; &lt;input type=\"hidden\" name=\"id\" value=\"${user.id}\"&gt; &lt;%-- 创建一个只读的姓名显示框，姓名不允许更改 --%&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" value=\"${user.name}\" readonly=\"readonly\" placeholder=\"请输入姓名\" /&gt; &lt;/div&gt; &lt;%-- 性别的修改选择，必须要确认该被修改者的性别是什么 --%&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;c:if test=\"${user.gender == '男'}\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" /&gt;女 &lt;/c:if&gt; &lt;c:if test=\"${user.gender == '女'}\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" checked /&gt;女 &lt;/c:if&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" value=\"${user.age}\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\" /&gt; &lt;/div&gt; &lt;%-- 管理员修改用户的省份时，需要判断用户的当前省份，以进入修改页面的时候，选择按钮在用户所在省份 --%&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" id=\"address\" class=\"form-control\" &gt; &lt;c:if test=\"${user.address == '陕西'}\"&gt; &lt;option value=\"陕西\" selected&gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"${user.address == '北京'}\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\" selected&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"${user.address == '上海'}\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\" selected&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;input class=\"btn btn-default\" type=\"button\" value=\"返回\"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 添加用户信息页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!-- HTML5文档--&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;添加用户&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;center&gt;&lt;h3&gt;添加联系人页面&lt;/h3&gt;&lt;/center&gt; &lt;form action=\"${pageContext.request.contextPath}/my/stringbug/web/servlet/addUserServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" placeholder=\"请输入姓名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked=\"checked\"/&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\"/&gt;女 &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" class=\"form-control\" id=\"address\"&gt; &lt;option value=\"陕西\"&gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"qq\"&gt;QQ：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"qq\" name=\"qq\" placeholder=\"请输入QQ号码\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;Email：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"email\" name=\"email\" placeholder=\"请输入邮箱地址\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;input class=\"btn btn-default\" type=\"button\" value=\"返回\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 数据库的实现创建数据表： 1234567891011CREATE TABLE USER ( id INT PRIMARY KEY AUTO_INCREMENT, -- 用户ID NAME VARCHAR(20) NOT NULL, -- 用户名 gender VARCHAR(5), -- 用户姓名 age INT, -- 用户年龄 address VARCHAR(32), -- 用户地址 qq VARCHAR(20), -- 用户QQ email VARCHAR(50), -- 用户邮箱 username VARCHAR(32), -- 管理员登录用户名 password VARCHAR(50) -- 管理员登录密码); 改变数据表中某些字段的字符集，使其能够插入中文数据： 123ALTER TABLE USER CHANGE NAME NAME VARCHAR(20) CHARACTER SET utf8;ALTER TABLE USER CHANGE gender gender VARCHAR(5) CHARACTER SET utf8;ALTER TABLE USER CHANGE address address VARCHAR(32) CHARACTER SET utf8; 想数据表中插入数据： 1234INSERT INTO USER(id, NAME, gender, age, address, qq, email, username, password) VALUES(1001, '张三', '女', 20, '陕西', '123456', '123456@qq.com', 'manager1', 'password1'),(1002, '李四', '男', 21, '北京', '654321', '654321@qq.com', 'manager2', 'password2'),(1003, '王五', '男', 22, '上海', '111111', '111111@qq.com', 'manager3', 'password3'); 后端的实现首先先创建好配置文件，对接MySQL数据库：druid.properties 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://MySQL地址/数据库名username=用户名password=密码initialSize=初始化连接数maxActive=最大连接数maxWait=最大等待时间（毫秒为单位） Servlet类的基本模版： 1234567891011121314@WebServlet(\"\")public class CheckCodeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 验证码的实现前面登录页面中需要登录的管理员输入验证码，下面实现验证码图片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@WebServlet(\"/my/stringbug/web/servlet/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet { private String getCheckCode() { String base = \"QqWwEeRrTtYyUuIiOoPpAaSsDdFfGgHhJjKkLlZzXxCcVvBbNnMm0123456789\"; int size = base.length(), codeNumber = 4; Random random = new Random(); StringBuilder codeBuffer = new StringBuilder(); for (int i = 0; i &lt; codeNumber; i++) { // 随机产生 base 中的一个字符的索引 int index = random.nextInt(size); // 获取该缩影对应的字符 char c = base.charAt(index); // 将获取到的字符存储到codeBuffer中去 codeBuffer.append(c); } return codeBuffer.toString(); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 服务器通知浏览器，不要缓存 response.setHeader(\"pragma\",\"no-cache\"); response.setHeader(\"cache-control\",\"no-cache\"); response.setHeader(\"expires\",\"0\"); // 在内存中创建一个长为80，宽为30的图片，默认黑色背景。验证码将在这个方框中展示 int width = 80, height = 30; BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 获取画笔对象 Graphics graphics = image.getGraphics(); // 将画笔的颜色设置为灰色，并填充在图片方框中 graphics.setColor(Color.GRAY); graphics.fillRect(0, 0, width, height); // 产生四个随机验证码，并将验证码放入HttpSession中去 String checkCode = getCheckCode(); request.getSession().setAttribute(\"CHECKCODE_SERVER\", checkCode); // 将画笔的颜色设置为黄色，字体的大小设置为24，然后在图片中写入验证码 graphics.setColor(Color.YELLOW); graphics.setFont(new Font(\"黑体\", Font.BOLD, 24)); graphics.drawString(checkCode, 15, 25); // 将在内存中画好的图片输出到浏览器 ImageIO.write(image, \"PNG\", response.getOutputStream()); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 管理与数据库对应的JavabeanUser12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class User { private int id; private String name; private String gender; private int age; private String address; private String qq; private String email; private String username; private String password; public User() { } public User(int id, String name, String gender, int age, String address, String qq, String email, String username, String password) { this.id = id; this.name = name; this.gender = gender; this.age = age; this.address = address; this.qq = qq; this.email = email; this.username = username; this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + \", age=\" + age + \", address='\" + address + '\\'' + \", qq='\" + qq + '\\'' + \", email='\" + email + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getQq() { return qq; } public void setQq(String qq) { this.qq = qq; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; }} PageBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PageBean&lt;T&gt; { /** 总记录数 */ private int totalCount; /** 总页码 */ private int totalPage ; /** 每页的数据 */ private List&lt;T&gt; list ; /** 当前页码 */ private int currentPage ; /** 每页显示的记录数 */ private int rows; public PageBean() { } public PageBean(int totalCount, int totalPage, List&lt;T&gt; list, int currentPage, int rows) { this.totalCount = totalCount; this.totalPage = totalPage; this.list = list; this.currentPage = currentPage; this.rows = rows; } @Override public String toString() { return \"PageBean{\" + \"totalCount=\" + totalCount + \", totalPage=\" + totalPage + \", list=\" + list + \", currentPage=\" + currentPage + \", rows=\" + rows + '}'; } public int getTotalCount() { return totalCount; } public void setTotalCount(int totalCount) { this.totalCount = totalCount; } public int getTotalPage() { return totalPage; } public void setTotalPage(int totalPage) { this.totalPage = totalPage; } public List&lt;T&gt; getList() { return list; } public void setList(List&lt;T&gt; list) { this.list = list; } public int getCurrentPage() { return currentPage; } public void setCurrentPage(int currentPage) { this.currentPage = currentPage; } public int getRows() { return rows; } public void setRows(int rows) { this.rows = rows; }} 创建一个数据库连接池工具类1234567891011121314151617181920212223242526272829303132public class JdbcUtils { /** 数据库连接源 */ private static DataSource dataSource; static { // 创建加载配置文件的对象 Properties properties = new Properties(); // 获取JdbcUtils.java的类加载器 ClassLoader classLoader = JdbcUtils.class.getClassLoader(); // 获取druid.properties配置文件资源字节输入流 InputStream resourceAsStream = classLoader.getResourceAsStream(\"druid.properties\"); try { // 加载配置文件 properties.load(resourceAsStream); // 初始化数据库连接池对象 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } /** * 获取数据库连接池对象 * @return 数据库连接池对象 */ public static DataSource getDataSource() { return dataSource; } /** 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return dataSource.getConnection(); }} 创建数据库操作相关的接口和类UserDao 接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public interface UserDao { /** * 查询用户的所用信息 * @return 用户所有信息 */ public List&lt;User&gt; findAll(); /** * 通过登录用户名和登录密码，查询用户 * @param username 用户名 * @param password 密码 * @return true/false */ User findUserByUsernameAndPassword(String username, String password); /** * 保存User * @param user 被修改的用户 */ void add(User user); /** * 根据id删除User * @param id 要被删除的用户的ID */ void delete(int id); /** * 通过id，查询用户信息 * @param i 用户id * @return 用户信息 */ User findById(int i); /** * 数据库中更新用户信息 * @param user 被修改的用户 */ void update(User user); /** * 查询总记录数 * @return 总记录数 * @param condition 查询条件 */ int findTotalCount(Map&lt;String, String[]&gt; condition); /** * 分页查询每页记录 * @param start 开始 * @param rows 行数 * @param condition 条件 * @return 每页记录 */ List&lt;User&gt; findByPage(int start, int rows, Map&lt;String, String[]&gt; condition);} UserDao 的实现类：UserDaoImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class UserDaoImpl implements UserDao { private JdbcTemplate template = new JdbcTemplate(JdbcUtils.getDataSource()); @Override public List&lt;User&gt; findAll() { // 使用JDBC操作数据库 return template.query( \"SELECT * FROM USER\", new BeanPropertyRowMapper&lt;User&gt;(User.class) ); } @Override public User findUserByUsernameAndPassword(String username, String password) { try { return template.queryForObject( \"SELECT * FROM USER WHERE username = ? AND password = ?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); } catch (Exception e) { e.printStackTrace(); return null; } } @Override public void add(User user) { template.update( \"INSERT INTO USER VALUE (null, ?, ?, ?, ?, ?, ?, null, null)\", user.getName(), user.getGender(), user.getAge(), user.getQq(), user.getEmail()); } @Override public void delete(int id) { template.update(\"DELETE FROM USER WHERE id = ?\", id); } @Override public User findById(int id) { return template.queryForObject( \"SELECT * FROM USER WhERE id = ?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), id); } @Override public void update(User user) { template.update( \"UPDATE USER SET \" + \"name = ?, gender = ?, age = ?, address = ?, qq = ?, email = ? WHERE id = ?\", user.getName(), user.getGender(), user.getAge(), user.getAddress(), user.getQq(), user.getEmail(), user.getId()); } @Override public int findTotalCount(Map&lt;String, String[]&gt; condition) { // 预定义SQL String sql = \"SELECT COUNT(*) FROM USER WHERE 1 = 1\"; StringBuilder stringBuilder = new StringBuilder(); // 遍历map Set&lt;String&gt; keySet = condition.keySet(); // 定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) { // 排除分页条件参数 if (\"currentPage\".equals(key) || \"rows\".equals(key)) { continue; } // 获取Value，并判断该Value是否有值 String value = condition.get(key)[0]; if (value != null &amp;&amp; !\"\".equals(value)) { stringBuilder.append(\" AND \").append(key).append(\" LIKE ? \"); // ? 条件值 params.add(\"%\" + value + \"%\"); } } System.out.println(stringBuilder.toString()); System.out.println(params); return template.queryForObject(stringBuilder.toString(), Integer.class, params.toArray()); } @Override public List&lt;User&gt; findByPage(int start, int rows, Map&lt;String, String[]&gt; condition) { // 预定义SQL String sql = \"SELECT * FROM USER WHERE 1 = 1\"; StringBuilder stringBuilder = new StringBuilder(); // 遍历map Set&lt;String&gt; keySet = condition.keySet(); // 定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) { // 排除分页条件参数 if (\"currentPage\".equals(key) || \"rows\".equals(key)) { continue; } // 获取Value，并判断该Value是否有值 String value = condition.get(key)[0]; if (value != null &amp;&amp; !\"\".equals(value)) { stringBuilder.append(\" AND \").append(key).append(\" LIKE ? \"); // ? 条件值 params.add(\"%\" + value + \"%\"); } } // 添加分页查询 stringBuilder.append(\" LIMIT ?, ? \"); // 添加分页查询参数值 params.add(start); params.add(rows); sql = stringBuilder.toString(); System.out.println(sql); System.out.println(params); return template.query(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), params.toArray()); }} 处理User数据逻辑UserService 接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public interface UserService { /** * 查询用户的所用信息 * @return 用户所有信息 */ public List&lt;User&gt; findAll(); /** * 这是一个登录方法 * @param user 登录的管理员 * @return 登录者对象 */ User login(User user); /** * 保存User * @param user 被修改的用户 */ void addUser(User user); /** * 根据id删除User * @param id 要被删除的用户的ID */ void deleteUser(String id); /** * 根据id查询用户信息 * @param id 用户ID * @return 用户信息 */ User findUserById(String id); /** * 更新用户信息 * @param user 被修改的用户 */ void updateUser(User user); /** * 批量删除用户 * @param ids 用户ID集 */ void delSelectedUser(String[] ids); /** * 分页条件查询 * @param currentPage 当前页面 * @param rows 每页显示的记录数 * @param condition 查询条件 * @return 查询结果 */ PageBean&lt;User&gt; findUserByPage(String currentPage, String rows, Map&lt;String, String[]&gt; condition);} UserService 的实现类：UserServiceImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UserServiceImpl implements UserService { private UserDao dao = new UserDaoImpl(); @Override public List&lt;User&gt; findAll() { // 调用Dao完成查询 return dao.findAll(); } @Override public User login(User user) { return dao.findUserByUsernameAndPassword(user.getUsername(), user.getPassword()); } @Override public void addUser(User user) { dao.add(user); } @Override public void deleteUser(String id) { dao.delete(Integer.parseInt(id)); } @Override public User findUserById(String id) { return dao.findById(Integer.parseInt(id)); } @Override public void updateUser(User user) { dao.update(user); } @Override public void delSelectedUser(String[] ids) { if (ids != null &amp;&amp; ids.length &gt; 0) { for (String id : ids) { dao.delete(Integer.parseInt(id)); } } } @Override public PageBean&lt;User&gt; findUserByPage(String currentPageString, String rowsString, Map&lt;String, String[]&gt; condition) { int currentPage = Integer.parseInt(currentPageString), rows = Integer.parseInt(rowsString); if (currentPage &lt;= 0) { currentPage = 1; } // 创建一个空的PageBean对象 PageBean&lt;User&gt; userPageBean = new PageBean&lt;&gt;(); // 设置PageBean参数 userPageBean.setCurrentPage(currentPage); userPageBean.setRows(rows); // 调用dao查询总记录数 int totalCount = dao.findTotalCount(condition); userPageBean.setTotalCount(totalCount); // 调用dao查询List集合，计算开始的记录索引 int start = (currentPage - 1) * rows; List&lt;User&gt; list = dao.findByPage(start, rows, condition); userPageBean.setList(list); // 计算总页码 int totalPage = (totalCount % rows) == 0 ? totalCount / rows : (totalCount / rows) + 1; userPageBean.setTotalPage(totalPage); return userPageBean; }} 添加用户信息和删除用户信息功能添加用户信息123456789101112131415161718192021222324252627@WebServlet(\"/my/stringbug/web/servlet/addUserServlet\")public class AddUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置参数 request.setCharacterEncoding(\"utf-8\"); // 获取用户输入的数据（获取参数） Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); // 将获取到的数据封装到User对象中 User user = new User(); try { BeanUtils.populate(user, parameterMap); } catch (IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } // 调用 UserServiceImpl 对象，将数据添加到数据库 UserService userService = new UserServiceImpl(); userService.addUser(user); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 删除用户信息 创建一个获取所有用户信息的Servlet 12345678910111213141516171819@WebServlet(\"/my/stringbug/web/servlet/userListServlet\")public class UserListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 调用UserServiceImpl完成查询 UserService userService = new UserServiceImpl(); List&lt;User&gt; userList = userService.findAll(); // 将userList存入Request域，然后转发到list.jsp request.setAttribute(\"users\", userList); request.getRequestDispatcher(request.getContextPath() + \"/list.jsp\").forward(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 创建删除用户信息的Servlet 1234567891011121314151617181920@WebServlet(\"/my/stringbug/web/servlet/delUserServlet\")public class DelUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取要被删除的用户的ID String id = request.getParameter(\"id\"); // 创建UserServiceImpl对象，删除对应ID的用户信息 UserService userService = new UserServiceImpl(); userService.deleteUser(id); // 跳转到查询所有用户信息的servlet request.getRequestDispatcher(request.getContextPath() + \"/my/stringbug/web/Servlet/userListServlet\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 修改用户信息功能查询要被修改的用户信息根据选择要修改的用户的id，查询该用户的信息，转发到修改页面 12345678910111213141516171819202122@WebServlet(\"/my/stringbug/web/servlet/findUserServlet\")public class FindUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取id String id = request.getParameter(\"id\"); // 调用UserServiceImpl UserService userService = new UserServiceImpl(); User userById = userService.findUserById(\"id\"); // 将User存入Request，在update.jsp页面展示该用户的信息 request.setAttribute(\"user\", userById); // 转发到update.jsp页面 request.getRequestDispatcher(request.getContextPath() + \"/update.jsp\").forward(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 数据库修改用户信息1234567891011121314151617181920212223242526272829@WebServlet(\"/my/stringbug/web/servlet/updateUserServlet\")public class UpdateUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置编码 request.setCharacterEncoding(\"utf-8\"); // 获取request中对应被修改用户的所有信息（被修改后的信息） Map&lt;String, String[]&gt; map = request.getParameterMap(); // 将信息封装到User对象中 User user = new User(); try { BeanUtils.populate(user, map); } catch (IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } // 使用UserServiceImpl，修改用户信息 UserService userService = new UserServiceImpl(); userService.updateUser(user); // 修改好用户信息后，将页面重定向到 /userListServlet response.sendRedirect(request.getContextPath()+\"/my/stringbug/web/servlet/userListServlet\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} userListServlet修改好用户信息后，将页面重定向到 userListServlet 12345678910111213141516171819@WebServlet(\"/my/stringbug/web/servlet/userListServlet\")public class UserListServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 调用UserServiceImpl完成查询 UserService userService = new UserServiceImpl(); List&lt;User&gt; userList = userService.findAll(); // 将userList存入Request域，然后转发到list.jsp request.setAttribute(\"users\", userList); request.getRequestDispatcher(request.getContextPath() + \"/list.jsp\").forward(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); }} 各个功能实现的分析 参考文献 黑马程序员 Java EE 57期","link":"/p/151524202006/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Request&Response","slug":"Request-Response","link":"/tags/Request-Response/"},{"name":"Python网络爬虫","slug":"Python网络爬虫","link":"/tags/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"},{"name":"Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"HBase","slug":"HBase","link":"/tags/HBase/"},{"name":"ZooKeeper","slug":"ZooKeeper","link":"/tags/ZooKeeper/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"Hive","slug":"Hive","link":"/tags/Hive/"},{"name":"Java JDBC","slug":"Java-JDBC","link":"/tags/Java-JDBC/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Jsp","slug":"Jsp","link":"/tags/Jsp/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Json","slug":"Json","link":"/tags/Json/"},{"name":"Java数据结构与算法","slug":"Java数据结构与算法","link":"/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java网络编程","slug":"Java网络编程","link":"/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"部署安装","slug":"部署安装","link":"/tags/%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/"},{"name":"MySQL基础","slug":"MySQL基础","link":"/tags/MySQL%E5%9F%BA%E7%A1%80/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Python操作数据库","slug":"Python操作数据库","link":"/tags/Python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Transaction","slug":"Transaction","link":"/tags/Transaction/"},{"name":"Annocation","slug":"Annocation","link":"/tags/Annocation/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"Reeuest&Response","slug":"Reeuest-Response","link":"/tags/Reeuest-Response/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"代理模式","slug":"代理模式","link":"/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"BootStrap","slug":"BootStrap","link":"/tags/BootStrap/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"BeanFactory","slug":"BeanFactory","link":"/tags/BeanFactory/"},{"name":"wordpress博客","slug":"wordpress博客","link":"/tags/wordpress%E5%8D%9A%E5%AE%A2/"},{"name":"Master","slug":"Master","link":"/tags/Master/"}],"categories":[{"name":"Java Web","slug":"Java-Web","link":"/categories/Java-Web/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"部署安装","slug":"部署安装","link":"/categories/%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"踩坑日记","slug":"踩坑日记","link":"/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"MyBatis","slug":"MyBatis","link":"/categories/MyBatis/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/categories/SpringCloud/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java 设计模式","slug":"Java-设计模式","link":"/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}